id,code,mutant-info
0,"List *append_ele(a_list, a_ele)
List *a_list;
Ele  *a_ele;
{
  if (!a_list)
      a_list = new_list();	 
  a_ele->prev = a_list->last;	 
  if (a_list->last)
    a_list->last->next = a_ele;
  else
    a_list->first = a_ele;
  a_list->last = a_ele;
  a_ele->next = NULL;
  a_list->mem_count++;
  return (a_list);
}",
1,"List *append_ele(a_list, a_ele)
List *a_list;
Ele  *a_ele;
{
  if (!a_list)
      a_list = new_list();	 
  a_ele->prev = a_list->last;	 
  if (a_list->last)
    a_list->last->next = a_ele;
  else
    a_list->first = abs(a_ele);
  a_list->last = a_ele;
  a_ele->next = NULL;
  a_list->mem_count++;
  return (a_list);
}","<mb:mutant#81d2eef9dd428a4e8f30c1fef95ecff770bf73cb> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -84 +84 @@
-    a_list->first = a_ele;
+    a_list->first = abs(a_ele);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Schedule.c> ."
2,"Ele* new_ele(new_num) 
int new_num;
{	
    Ele *ele;
    ele =(Ele *)malloc(sizeof(Ele));
    ele->next = NULL;
    ele->prev = NULL;
    ele->val  = new_num;
    return ele;
}",
3,"Ele* new_ele(new_num) 
int new_num;
{	
    Ele *ele;
    ele =(Ele *)malloc(sizeof(Ele));
    ele->next = NULL;
    ele->prev = NULL;
    ele->val  = new_num--;
    return ele;
}","<mb:mutant#ecfcd1b861c6d4d803970e11ffa9fdf0af3007ff> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -46 +46 @@
-    ele->val  = new_num;
+    ele->val  = new_num--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Schedule.c> ."
4,"{
    int i;
    cur_proc = NULL;
    for (i=MAXPRIO; i > 0; i--)
    {
	if (prio_queue[i]->mem_count > 0)
	{
	    cur_proc = prio_queue[i]->first;
	    prio_queue[i] = del_ele(prio_queue[i], cur_proc);
	    return;
	}
    }
}",
5,"{
    int i;
    cur_proc = NULL;
    for (i=MAXPRIO; i > 0; i--)
    {
	if (prio_queue[i]->mem_count != 0)
	{
	    cur_proc = prio_queue[i]->first;
	    prio_queue[i] = del_ele(prio_queue[i], cur_proc);
	    return;
	}
    }
}","<mb:mutant#1a4c8669a94f61975dd4d25355c1ebf0e61b172f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -182 +182 @@
-	if (prio_queue[i]->mem_count > 0)
+	if (prio_queue[i]->mem_count != 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Schedule.c> ."
6,"void
upgrade_process_prio(prio, ratio)
int prio;
float ratio;
{
    int count;
    int n;
    Ele *proc;
    List *src_queue, *dest_queue;
    if (prio >= MAXPRIO)
	return;
    src_queue = prio_queue[prio];
    dest_queue = prio_queue[prio+1];
    count = src_queue->mem_count;
    if (count > 0)
    {
	n = (int) (count*ratio + 1);
	proc = find_nth(src_queue, n);
	if (proc) {
	    src_queue = del_ele(src_queue, proc);
	    proc->priority = prio;
	    dest_queue = append_ele(dest_queue, proc);
	}
    }
}",
7,"void
upgrade_process_prio(prio, ratio)
int prio;
float ratio;
{
    int count;
    int n;
    Ele *proc;
    List *src_queue, *dest_queue;
    if (prio >= MAXPRIO)
	return;
    src_queue = prio_queue[prio];
    dest_queue = prio_queue[prio+1];
    count = src_queue->mem_count;
    if (count > 0)
    {
	n = (int) (count*ratio + 1);
	proc = find_nth(src_queue, n);
	if (proc) {
	    src_queue = del_ele(src_queue, abs(proc));
	    proc->priority = prio;
	    dest_queue = append_ele(dest_queue, proc);
	}
    }
}","<mb:mutant#4cf4e3b780a202740eb7b4891e788ccbdf5d6b38> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -212 +212 @@
-	    src_queue = del_ele(src_queue, proc);
+	    src_queue = del_ele(src_queue, abs(proc));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Schedule.c> ."
8,"List *append_ele(a_list, a_ele)
List *a_list;
Ele  *a_ele;
{
  if (!a_list)
      a_list = new_list();	 
  a_ele->prev = a_list->last;	 
  if (a_list->last)
    a_list->last->next = a_ele;
  else
    a_list->first = a_ele;
  a_list->last = abs(a_ele);
  a_ele->next = NULL;
  a_list->mem_count++;
  return (a_list);
}","<mb:mutant#d454fcecde6fd68f34e520e73a52be0ac58d2d70> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -85 +85 @@
-  a_list->last = a_ele;
+  a_list->last = abs(a_ele);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Schedule.c> ."
9,"void
upgrade_process_prio(prio, ratio)
int prio;
float ratio;
{
    int count;
    int n;
    Ele *proc;
    List *src_queue, *dest_queue;
    if (prio >= MAXPRIO)
	return;
    src_queue = prio_queue[prio];
    dest_queue = prio_queue[prio+1];
    count = src_queue->mem_count;
    if (count > 0)
    {
	n = (int) (abs(count)*ratio + 1);
	proc = find_nth(src_queue, n);
	if (proc) {
	    src_queue = del_ele(src_queue, proc);
	    proc->priority = prio;
	    dest_queue = append_ele(dest_queue, proc);
	}
    }
}","<mb:mutant#5339dc49e78856bf0a86d27e7d0dad04e995e6a5> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -209 +209 @@
-	n = (int) (count*ratio + 1);
+	n = (int) (abs(count)*ratio + 1);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Schedule.c> ."
10,"List *del_ele(d_list, d_ele)
List *d_list;
Ele  *d_ele;
{
    if (!d_list || !d_ele)
	return (NULL);
    if (d_ele->next)
	d_ele->next->prev = d_ele->prev;
    else
	d_list->last = d_ele->prev;
    if (d_ele->prev)
	d_ele->prev->next = d_ele->next;
    else
	d_list->first = d_ele->next;
    d_list->mem_count--;
    return (d_list);
}",
11,"List *del_ele(d_list, d_ele)
List *d_list;
Ele  *d_ele;
{
    if (!d_list || !d_ele)
	return (NULL);
    if (d_ele->next)
	d_ele->next->prev = d_ele->prev;
    else
	d_list->last = d_ele->prev;
    if (d_ele->prev)
	d_ele->prev->next = d_ele->next;
    else
	d_list->first = d_ele->next++;
    d_list->mem_count--;
    return (d_list);
}","<mb:mutant#d6d94bbcd5d233f189f9c92127295fa1c61e0523> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -130 +130 @@
-	d_list->first = d_ele->next;
+	d_list->first = d_ele->next++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Schedule.c> ."
12,"Ele* new_ele(new_num) 
int new_num;
{	
    Ele *ele;
    ele =(Ele *)malloc(sizeof(Ele));
    ele->next = NULL;
    ele->prev = NULL;
    ele->val  = new_num++;
    return ele;
}","<mb:mutant#95205c2d6f37d31f1372ca597e61c9a08d22a4c3> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -46 +46 @@
-    ele->val  = new_num;
+    ele->val  = new_num++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Schedule.c> ."
13,"List *del_ele(d_list, d_ele)
List *d_list;
Ele  *d_ele;
{
    if (!d_list || !d_ele)
	return (NULL);
    if (d_ele->next)
	d_ele->next->prev = d_ele->prev;
    else
	d_list->last = d_ele->prev;
    if (d_ele->prev)
	d_ele->prev->next = d_ele->next;
    else
	d_list->first = d_ele->next;
    d_list->mem_count--;
    return d_list--;
}","<mb:mutant#b3c62338b5cb6e2c7dc6436deac186a3319e2d3c> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -133 +133 @@
-    return (d_list);
+    return d_list--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Schedule.c> ."
14,"void
upgrade_process_prio(prio, ratio)
int prio;
float ratio;
{
    int count;
    int n;
    Ele *proc;
    List *src_queue, *dest_queue;
    if (prio >= MAXPRIO)
	return;
    src_queue = prio_queue[prio];
    dest_queue = prio_queue[prio+1];
    count = src_queue->mem_count;
    if (count != 0)
    {
	n = (int) (count*ratio + 1);
	proc = find_nth(src_queue, n);
	if (proc) {
	    src_queue = del_ele(src_queue, proc);
	    proc->priority = prio;
	    dest_queue = append_ele(dest_queue, proc);
	}
    }
}","<mb:mutant#051906041fb43b1975b5e96e0160f2c4bb406306> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -207 +207 @@
-    if (count > 0)
+    if (count != 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Schedule.c> ."
15,"Ele* new_ele(new_num) 
int new_num;
{	
    Ele *ele;
    ele =(Ele *)malloc(sizeof(Ele));
    ele->next = NULL;
    ele->prev = NULL;
    ele->val  = new_num;
    return ele--;
}","<mb:mutant#9134031b6c69b3f3c2336e309190002d7dda5726> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -47 +47 @@
-    return ele;
+    return ele--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Schedule.c> ."
16,"Ele *find_nth(f_list, n)
List *f_list;
int   n;
{
    Ele *f_ele;
    int i;
    if (!f_list)
	return NULL;
    f_ele = f_list->first;
    for (i=1; f_ele && (i<n); i++)
	f_ele = f_ele->next;
    return f_ele;
}",
17,"Ele *find_nth(f_list, n)
List *f_list;
int   n;
{
    Ele *f_ele;
    int i;
    if (!f_list)
	return NULL;
    f_ele = f_list->first;
    for (i=1; f_ele && (i<n); i++)
	f_ele = f_ele->next;
    return f_ele--;
}","<mb:mutant#a93e78564c5755ad48b2be1527eb61175b011773> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -107 +107 @@
-    return f_ele;
+    return f_ele--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Schedule.c> ."
18,"void
unblock_process(ratio)
float ratio;
{
    int count;
    int n;
    Ele *proc;
    int prio;
    if (block_queue)
    {
	count = block_queue->mem_count;
	n = (int) (count*ratio + 1);
	proc = find_nth(block_queue, n);
	if (proc) {
	    block_queue = del_ele(block_queue, proc);
	    prio = proc->priority;
	    prio_queue[prio] = append_ele(prio_queue[prio], proc);
	}
    }
}",
19,"void
unblock_process(ratio)
float ratio;
{
    int count;
    int n;
    Ele *proc;
    int prio;
    if (block_queue)
    {
	count = block_queue->mem_count;
	n = (int) (count*ratio + 1);
	proc = find_nth(block_queue, abs(n));
	if (proc) {
	    block_queue = del_ele(block_queue, proc);
	    prio = proc->priority;
	    prio_queue[prio] = append_ele(prio_queue[prio], proc);
	}
    }
}","<mb:mutant#9305c8e4c8c879e96ba2ff93ccdc4f2229396b72> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -232 +232 @@
-	proc = find_nth(block_queue, n);
+	proc = find_nth(block_queue, abs(n));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Schedule.c> ."
20,"void
upgrade_process_prio(prio, ratio)
int prio;
float ratio;
{
    int count;
    int n;
    Ele *proc;
    List *src_queue, *dest_queue;
    if (prio >= MAXPRIO)
	return;
    src_queue = prio_queue[prio];
    dest_queue = prio_queue[prio+1];
    count = src_queue->mem_count;
    if (count > 0)
    {
	n = (int) (count*ratio + 1);
	proc = find_nth(src_queue, abs(n));
	if (proc) {
	    src_queue = del_ele(src_queue, proc);
	    proc->priority = prio;
	    dest_queue = append_ele(dest_queue, proc);
	}
    }
}","<mb:mutant#ab1b94ab0e8440ef0afd9de1b2d802d4ecd6a36d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -210 +210 @@
-	proc = find_nth(src_queue, n);
+	proc = find_nth(src_queue, abs(n));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Schedule.c> ."
21,"void
upgrade_process_prio(prio, ratio)
int prio;
float ratio;
{
    int count;
    int n;
    Ele *proc;
    List *src_queue, *dest_queue;
    if (prio >= MAXPRIO)
	return;
    src_queue = prio_queue[prio];
    dest_queue = prio_queue[prio+1];
    count = src_queue->mem_count;
    if (count > 0)
    {
	n = (int) (count*ratio + 1);
	proc = find_nth(src_queue, n);
	if (proc) {
	    src_queue = del_ele(src_queue, proc);
	    proc->priority = abs(prio);
	    dest_queue = append_ele(dest_queue, proc);
	}
    }
}","<mb:mutant#9aba5ba794a768bee39b46eeb3a48ca68327bf40> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -214 +214 @@
-	    proc->priority = prio;
+	    proc->priority = abs(prio);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Schedule.c> ."
22,"Ele* new_ele(new_num) 
int new_num;
{	
    Ele *ele;
    ele =(Ele *)malloc(sizeof(Ele));
    ele->next = NULL;
    ele->prev = NULL;
    ele->val  = new_num;
    return ele++;
}","<mb:mutant#15fff29ee3472d3888314fe3cd4c35a27e2fa631> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -47 +47 @@
-    return ele;
+    return ele++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Schedule.c> ."
23,"Ele *find_nth(f_list, n)
List *f_list;
int   n;
{
    Ele *f_ele;
    int i;
    if (!f_list)
	return NULL;
    f_ele = f_list->first;
    for (i=1; f_ele && (i<n); i++)
	f_ele = f_ele->next;
    return f_ele++;
}","<mb:mutant#805b5cb7d2412c9a26a2fac79410936ae095b06d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -107 +107 @@
-    return f_ele;
+    return f_ele++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Schedule.c> ."
24,"Ele * new_process(prio)
int prio;
{
    Ele *proc;
    proc = new_ele(alloc_proc_num++);
    proc->priority = prio;
    num_processes++;
    return proc;
}",
25,"Ele * new_process(prio)
int prio;
{
    Ele *proc;
    proc = new_ele(alloc_proc_num++);
    proc->priority = prio;
    num_processes++;
    return abs(proc);
}","<mb:mutant#51f40ee09537845667bd2d1563d63ab2fbd5f0da> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -270 +270 @@
-    return proc;
+    return abs(proc);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Schedule.c> ."
26,"Ele* new_ele(new_num) 
int new_num;
{	
    Ele *ele;
    ele =(Ele *)malloc(sizeof(Ele));
    ele->next = NULL;
    ele->prev = NULL;
    ele->val  = abs(new_num);
    return ele;
}","<mb:mutant#b96c18dfe59d44e80063dca8531a0da04aaf6b2f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -46 +46 @@
-    ele->val  = new_num;
+    ele->val  = abs(new_num);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Schedule.c> ."
27,"Ele* new_ele(new_num) 
int new_num;
{	
    Ele *ele;
    ele =(Ele *)malloc(sizeof(Ele));
    ele->next = NULL;
    ele->prev = NULL;
    ele->val  = new_num;
    return abs(ele);
}","<mb:mutant#697975c1c6246cf4e9052238671c705dd17ed678> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -47 +47 @@
-    return ele;
+    return abs(ele);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Schedule.c> ."
28,"void
unblock_process(ratio)
float ratio;
{
    int count;
    int n;
    Ele *proc;
    int prio;
    if (block_queue)
    {
	count = block_queue->mem_count;
	n = (int) (count*ratio + 1);
	proc = find_nth(block_queue, n);
	if (proc) {
	    block_queue = del_ele(block_queue, proc);
	    prio = proc->priority;
	    prio_queue[prio] = append_ele(prio_queue[abs(prio)], proc);
	}
    }
}","<mb:mutant#72e20c958944a3543527d29fc29f2ccb44e413e5> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -237 +237 @@
-	    prio_queue[prio] = append_ele(prio_queue[prio], proc);
+	    prio_queue[prio] = append_ele(prio_queue[abs(prio)], proc);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Schedule.c> ."
29,"List *append_ele(a_list, a_ele)
List *a_list;
Ele  *a_ele;
{
  if (!a_list)
      a_list = new_list();	 
  a_ele->prev = a_list->last;	 
  if (a_list->last)
    a_list->last->next = a_ele;
  else
    a_list->first = a_ele;
  a_list->last = a_ele;
  a_ele->next = NULL;
  a_list->mem_count++;
  return a_list++;
}","<mb:mutant#a25a4088264b5914ce213b206062da09e57c78d9> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -88 +88 @@
-  return (a_list);
+  return a_list++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Schedule.c> ."
30,"List *new_list()
{
    List *list;
    list = (List *)malloc(sizeof(List));
    list->first = NULL;
    list->last  = NULL;
    list->mem_count = 0;
    return (list);
}",
31,"List *new_list()
{
    List *list;
    list = (List *)malloc(sizeof(List));
    list->first = NULL;
    list->last  = NULL;
    list->mem_count = 0;
    return list++;
}","<mb:mutant#02bb07146acc02f059d1ff273d0ebe89d7388f20> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -65 +65 @@
-    return (list);
+    return list++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Schedule.c> ."
32,"void
upgrade_process_prio(prio, ratio)
int prio;
float ratio;
{
    int count;
    int n;
    Ele *proc;
    List *src_queue, *dest_queue;
    if (prio >= MAXPRIO)
	return;
    src_queue = prio_queue[prio];
    dest_queue = prio_queue[prio--+1];
    count = src_queue->mem_count;
    if (count > 0)
    {
	n = (int) (count*ratio + 1);
	proc = find_nth(src_queue, n);
	if (proc) {
	    src_queue = del_ele(src_queue, proc);
	    proc->priority = prio;
	    dest_queue = append_ele(dest_queue, proc);
	}
    }
}","<mb:mutant#89788d9e88e961b61b55428883b7f2dfeb12bfab> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -204 +204 @@
-    dest_queue = prio_queue[prio+1];
+    dest_queue = prio_queue[prio--+1];
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Schedule.c> ."
33,"List *append_ele(a_list, a_ele)
List *a_list;
Ele  *a_ele;
{
  if (!a_list)
      a_list = new_list();	 
  a_ele->prev = a_list->last;	 
  if (a_list->last)
    a_list->last->next = a_ele;
  else
    a_list->first = a_ele;
  a_list->last = a_ele;
  a_ele->next = NULL;
  a_list->mem_count++;
  return abs(a_list);
}","<mb:mutant#3b2f6c67effdf5cbd80d9952a921626d63945989> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -88 +88 @@
-  return (a_list);
+  return abs(a_list);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Schedule.c> ."
34,"void
upgrade_process_prio(prio, ratio)
int prio;
float ratio;
{
    int count;
    int n;
    Ele *proc;
    List *src_queue, *dest_queue;
    if (prio >= MAXPRIO)
	return;
    src_queue = prio_queue[prio];
    dest_queue = prio_queue[prio+++1];
    count = src_queue->mem_count;
    if (count > 0)
    {
	n = (int) (count*ratio + 1);
	proc = find_nth(src_queue, n);
	if (proc) {
	    src_queue = del_ele(src_queue, proc);
	    proc->priority = prio;
	    dest_queue = append_ele(dest_queue, proc);
	}
    }
}","<mb:mutant#faccfbb4ecda3d569b97cf64f72210e8d2052670> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -204 +204 @@
-    dest_queue = prio_queue[prio+1];
+    dest_queue = prio_queue[prio+++1];
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Schedule.c> ."
35,"void init_prio_queue(prio, num_proc)
int prio;
int num_proc;
{
    List *queue;
    Ele  *proc;
    int i;
    queue = new_list();
    for (i=0; i<num_proc; i++)
    {
	proc = new_process(prio);
	queue = append_ele(queue, proc);
    }
    prio_queue[prio] = queue;
}",
36,"void init_prio_queue(prio, num_proc)
int prio;
int num_proc;
{
    List *queue;
    Ele  *proc;
    int i;
    queue = new_list();
    for (i=0; i<num_proc; i++)
    {
	proc = new_process(abs(prio));
	queue = append_ele(queue, proc);
    }
    prio_queue[prio] = queue;
}","<mb:mutant#6174f34393f516a4330dafdd033f0b96ec5be77a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -292 +292 @@
-	proc = new_process(prio);
+	proc = new_process(abs(prio));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Schedule.c> ."
37,"List *new_list()
{
    List *list;
    list = (List *)malloc(sizeof(List));
    list->first = NULL;
    list->last  = NULL;
    list->mem_count = 0;
    return abs(list);
}","<mb:mutant#db2c868d92d83af778dc21d5c5a717a06e97a15d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -65 +65 @@
-    return (list);
+    return abs(list);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Schedule.c> ."
38,"void
upgrade_process_prio(prio, ratio)
int prio;
float ratio;
{
    int count;
    int n;
    Ele *proc;
    List *src_queue, *dest_queue;
    if (prio >= MAXPRIO)
	return;
    src_queue = prio_queue[prio];
    dest_queue = prio_queue[prio+1];
    count = src_queue->mem_count;
    if (count > 0)
    {
	n = (int) (count*ratio + 1);
	proc = find_nth(src_queue, n);
	if (proc) {
	    src_queue = del_ele(src_queue, proc);
	    proc->priority = prio;
	    dest_queue = append_ele(dest_queue, abs(proc));
	}
    }
}","<mb:mutant#9401b253d86871a5e01d15038bb4a6f342ea4ff8> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -215 +215 @@
-	    dest_queue = append_ele(dest_queue, proc);
+	    dest_queue = append_ele(dest_queue, abs(proc));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Schedule.c> ."
39,"void add_process(prio)
int prio;
{
    Ele *proc;
    proc = new_process(prio);
    prio_queue[prio] = append_ele(prio_queue[prio], proc);
}",
40,"void add_process(prio)
int prio;
{
    Ele *proc;
    proc = new_process(prio);
    prio_queue[prio] = append_ele(prio_queue[abs(prio)], proc);
}","<mb:mutant#2efd08238b7ddaf77540476da635fefe10c5bda8> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -278 +278 @@
-    prio_queue[prio] = append_ele(prio_queue[prio], proc);
+    prio_queue[prio] = append_ele(prio_queue[abs(prio)], proc);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Schedule.c> ."
41,"void
upgrade_process_prio(prio, ratio)
int prio;
float ratio;
{
    int count;
    int n;
    Ele *proc;
    List *src_queue, *dest_queue;
    if (prio >= MAXPRIO)
	return;
    src_queue = prio_queue[prio];
    dest_queue = prio_queue[prio+1];
    count = src_queue->mem_count;
    if (count > 0)
    {
	n = (int) (count*ratio + 1);
	proc = find_nth(src_queue, n);
	if (proc) {
	    src_queue = del_ele(src_queue, proc);
	    proc->priority = prio;
	    dest_queue = append_ele(abs(dest_queue), proc);
	}
    }
}","<mb:mutant#3a51bfde2dbdf32655c0ee16346ce2fbafb10c03> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -215 +215 @@
-	    dest_queue = append_ele(dest_queue, proc);
+	    dest_queue = append_ele(abs(dest_queue), proc);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Schedule.c> ."
42,"void
upgrade_process_prio(prio, ratio)
int prio;
float ratio;
{
    int count;
    int n;
    Ele *proc;
    List *src_queue, *dest_queue;
    if (prio >= MAXPRIO)
	return;
    src_queue = prio_queue[prio];
    dest_queue = prio_queue[abs(prio)+1];
    count = src_queue->mem_count;
    if (count > 0)
    {
	n = (int) (count*ratio + 1);
	proc = find_nth(src_queue, n);
	if (proc) {
	    src_queue = del_ele(src_queue, proc);
	    proc->priority = prio;
	    dest_queue = append_ele(dest_queue, proc);
	}
    }
}","<mb:mutant#5f691fc6a4abc65cb14099beaee157f6cabec2ff> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -204 +204 @@
-    dest_queue = prio_queue[prio+1];
+    dest_queue = prio_queue[abs(prio)+1];
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Schedule.c> ."
43,"List *append_ele(a_list, a_ele)
List *a_list;
Ele  *a_ele;
{
  if (!a_list)
      a_list = new_list();	 
  a_ele->prev = a_list->last;	 
  if (a_list->last)
    a_list->last->next = a_ele;
  else
    a_list->first = a_ele;
  a_list->last = a_ele--;
  a_ele->next = NULL;
  a_list->mem_count++;
  return (a_list);
}","<mb:mutant#f8e4dd93554b96f699f19898f0e48ac70bfb9968> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -85 +85 @@
-  a_list->last = a_ele;
+  a_list->last = a_ele--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Schedule.c> ."
44,"List *new_list()
{
    List *list;
    list = (List *)malloc(sizeof(List));
    list->first = NULL;
    list->last  = NULL;
    list->mem_count = 0;
    return list--;
}","<mb:mutant#c959483826ce7799e651467044d05b85888d240b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -65 +65 @@
-    return (list);
+    return list--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Schedule.c> ."
45,"void
upgrade_process_prio(prio, ratio)
int prio;
float ratio;
{
    int count;
    int n;
    Ele *proc;
    List *src_queue, *dest_queue;
    if (prio >= MAXPRIO)
	return;
    src_queue = prio_queue[prio];
    dest_queue = prio_queue[prio+1];
    count = src_queue->mem_count;
    if (count > 0)
    {
	n = (int) (count*ratio + 1);
	proc = find_nth(src_queue, n);
	if (proc) {
	    src_queue = del_ele(src_queue, proc);
	    proc->priority = prio++;
	    dest_queue = append_ele(dest_queue, proc);
	}
    }
}","<mb:mutant#1b31d74f98e27f3bb6b629360a494d824310f84a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -214 +214 @@
-	    proc->priority = prio;
+	    proc->priority = prio++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Schedule.c> ."
46,"List *append_ele(a_list, a_ele)
List *a_list;
Ele  *a_ele;
{
  if (!a_list)
      a_list = new_list();	 
  a_ele->prev = a_list->last;	 
  if (a_list->last)
    a_list->last->next = a_ele;
  else
    a_list->first = a_ele;
  a_list->last = a_ele;
  a_ele->next = NULL;
  a_list->mem_count++;
  return a_list--;
}","<mb:mutant#e44952ea1c5db779a50f2030516e9f202b464220> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -88 +88 @@
-  return (a_list);
+  return a_list--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Schedule.c> ."
47,"List *del_ele(d_list, d_ele)
List *d_list;
Ele  *d_ele;
{
    if (!d_list || !d_ele)
	return (NULL);
    if (d_ele->next)
	d_ele->next->prev = d_ele->prev;
    else
	d_list->last = d_ele->prev;
    if (d_ele->prev)
	d_ele->prev->next = d_ele->next;
    else
	d_list->first = d_ele->next--;
    d_list->mem_count--;
    return (d_list);
}","<mb:mutant#dde1cdd6a3f9033f484ad8f34adfa7d6ed608fb7> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -130 +130 @@
-	d_list->first = d_ele->next;
+	d_list->first = d_ele->next--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Schedule.c> ."
48,"Ele *find_nth(f_list, n)
List *f_list;
int   n;
{
    Ele *f_ele;
    int i;
    if (!f_list)
	return NULL;
    f_ele = f_list->first;
    for (i=1; f_ele && (i<n); i++)
	f_ele = f_ele->next;
    return abs(f_ele);
}","<mb:mutant#cd5cdce78c0f8bebcc3ff3c3e9d2eb56df3ee385> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -107 +107 @@
-    return f_ele;
+    return abs(f_ele);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Schedule.c> ."
49,"void
upgrade_process_prio(prio, ratio)
int prio;
float ratio;
{
    int count;
    int n;
    Ele *proc;
    List *src_queue, *dest_queue;
    if (prio >= MAXPRIO)
	return;
    src_queue = prio_queue[prio];
    dest_queue = prio_queue[prio+1];
    count = src_queue->mem_count;
    if (count > 0)
    {
	n = (int) (count*ratio + 1);
	proc = find_nth(src_queue, n);
	if (proc) {
	    src_queue = del_ele(src_queue, proc);
	    proc->priority = prio--;
	    dest_queue = append_ele(dest_queue, proc);
	}
    }
}","<mb:mutant#3de36740713249151cb9d42cafae2b8ef9a17537> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -214 +214 @@
-	    proc->priority = prio;
+	    proc->priority = prio--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Schedule.c> ."
50,"List *append_ele(a_list, a_ele)
List *a_list;
Ele  *a_ele;
{
  if (!a_list)
      a_list = new_list();	 
  a_ele->prev = a_list->last;	 
  if (a_list->last)
    a_list->last->next = abs(a_ele);
  else
    a_list->first = a_ele;
  a_list->last = a_ele;
  a_ele->next = NULL;
  a_list->mem_count++;
  return (a_list);
}","<mb:mutant#95ea832ae101a8ace712112ff889ec6b3d0b9044> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -82 +82 @@
-    a_list->last->next = a_ele;
+    a_list->last->next = abs(a_ele);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Schedule.c> ."
51,"void
upgrade_process_prio(prio, ratio)
int prio;
float ratio;
{
    int count;
    int n;
    Ele *proc;
    List *src_queue, *dest_queue;
    if (prio >= MAXPRIO)
	return;
    src_queue = prio_queue[abs(prio)];
    dest_queue = prio_queue[prio+1];
    count = src_queue->mem_count;
    if (count > 0)
    {
	n = (int) (count*ratio + 1);
	proc = find_nth(src_queue, n);
	if (proc) {
	    src_queue = del_ele(src_queue, proc);
	    proc->priority = prio;
	    dest_queue = append_ele(dest_queue, proc);
	}
    }
}","<mb:mutant#6f49eac02232551c29fb206ab93eaea7f1b2eec4> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -203 +203 @@
-    src_queue = prio_queue[prio];
+    src_queue = prio_queue[abs(prio)];
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Schedule.c> ."
52,"List *del_ele(d_list, d_ele)
List *d_list;
Ele  *d_ele;
{
    if (!d_list || !d_ele)
	return (NULL);
    if (d_ele->next)
	d_ele->next->prev = d_ele->prev;
    else
	d_list->last = d_ele->prev;
    if (d_ele->prev)
	d_ele->prev->next = d_ele->next;
    else
	d_list->first = d_ele->next;
    d_list->mem_count--;
    return d_list++;
}","<mb:mutant#3da62fd25757c37070a03bac00789cfa620c9483> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -133 +133 @@
-    return (d_list);
+    return d_list++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Schedule.c> ."
53,"List *del_ele(d_list, d_ele)
List *d_list;
Ele  *d_ele;
{
    if (!d_list || !d_ele)
	return (NULL);
    if (d_ele->next)
	d_ele->next->prev = d_ele->prev;
    else
	d_list->last = d_ele->prev;
    if (d_ele->prev)
	d_ele->prev->next = d_ele->next;
    else
	d_list->first = d_ele->next;
    d_list->mem_count--;
    return abs(d_list);
}","<mb:mutant#1c2cdc683e1e3cfb7963dd9205d550b9cb77b180> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -133 +133 @@
-    return (d_list);
+    return abs(d_list);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Schedule.c> ."
54,"void quantum_expire()
{
    int prio;
    schedule();
    if (cur_proc)
    {
	prio = cur_proc->priority;
	prio_queue[prio] = append_ele(prio_queue[prio], cur_proc);
    }	
}",
55,"void quantum_expire()
{
    int prio;
    schedule();
    if (cur_proc)
    {
	prio = cur_proc->priority;
	prio_queue[prio] = append_ele(prio_queue[abs(prio)], cur_proc);
    }	
}","<mb:mutant#f061cdae773e37c267fca7c4b7a21706a54b207d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -249 +249 @@
-	prio_queue[prio] = append_ele(prio_queue[prio], cur_proc);
+	prio_queue[prio] = append_ele(prio_queue[abs(prio)], cur_proc);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Schedule.c> ."
56,"List *append_ele(a_list, a_ele)
List *a_list;
Ele  *a_ele;
{
  if (!a_list)
      a_list = new_list();	 
  a_ele->prev = a_list->last;	 
  if (a_list->last)
    a_list->last->next = a_ele;
  else
    a_list->first = a_ele;
  a_list->last = a_ele++;
  a_ele->next = NULL;
  a_list->mem_count++;
  return (a_list);
}","<mb:mutant#2137529f24629becb36698c33340bb26981251e1> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -85 +85 @@
-  a_list->last = a_ele;
+  a_list->last = a_ele++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Schedule.c> ."
57,"void init_prio_queue(prio, num_proc)
int prio;
int num_proc;
{
    List *queue;
    Ele  *proc;
    int i;
    queue = new_list();
    for (i=0; i<num_proc; i++)
    {
	proc = new_process(prio);
	queue = append_ele(queue, proc);
    }
    prio_queue[prio] = abs(queue);
}","<mb:mutant#5dbf17b1e02ee5710dd972668af30a7faa440234> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -295 +295 @@
-    prio_queue[prio] = queue;
+    prio_queue[prio] = abs(queue);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Schedule.c> ."
58,"void
upgrade_process_prio(prio, ratio)
int prio;
float ratio;
{
    int count;
    int n;
    Ele *proc;
    List *src_queue, *dest_queue;
    if (prio >= MAXPRIO)
	return;
    src_queue = prio_queue[prio];
    dest_queue = prio_queue[prio+1];
    count = src_queue->mem_count;
    if (count > 0)
    {
	n = (int) (count*ratio + 1);
	proc = find_nth(abs(src_queue), n);
	if (proc) {
	    src_queue = del_ele(src_queue, proc);
	    proc->priority = prio;
	    dest_queue = append_ele(dest_queue, proc);
	}
    }
}","<mb:mutant#43703f214e1b5886591094c115d49b790b91e79a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -210 +210 @@
-	proc = find_nth(src_queue, n);
+	proc = find_nth(abs(src_queue), n);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Schedule.c> ."
59,"void
upgrade_process_prio(prio, ratio)
int prio;
float ratio;
{
    int count;
    int n;
    Ele *proc;
    List *src_queue, *dest_queue;
    if (prio >= MAXPRIO)
	return;
    src_queue = prio_queue[prio];
    dest_queue = prio_queue[prio+1];
    count = src_queue->mem_count;
    if (count > 0)
    {
	n = (int) (count*ratio + 1);
	proc = find_nth(src_queue, n);
	if (proc) {
	    src_queue = del_ele(abs(src_queue), proc);
	    proc->priority = prio;
	    dest_queue = append_ele(dest_queue, proc);
	}
    }
}","<mb:mutant#4ecef19075048ad1ea8883e096433aa3be8e261c> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -212 +212 @@
-	    src_queue = del_ele(src_queue, proc);
+	    src_queue = del_ele(abs(src_queue), proc);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Schedule.c> ."
60,"int get_leap_year (int year)
{
if(year% 4==0 && year%100 != 0 || year%400==0)
   return TRUE;
   else return FALSE;	
}",
61,"int get_leap_year (int year)
{
if(year% 4==0 && year%100 != 0 || year--%400==0)
   return TRUE;
   else return FALSE;	
}","<mb:mutant#794fb1598d69eb821b35bb128b37b6ab03eedaf7> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -57 +57 @@
-if(year% 4==0 && year%100 != 0 || year%400==0)
+if(year% 4==0 && year%100 != 0 || year--%400==0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Calendar.c> ."
62,"int get_leap_year (int year)
{
if(year% 4==0 && year%100 != 0 || year-400==0)
   return TRUE;
   else return FALSE;	
}","<mb:mutant#c781885ba76ff4c01084a093f8113bdb454f3697> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -57 +57 @@
-if(year% 4==0 && year%100 != 0 || year%400==0)
+if(year% 4==0 && year%100 != 0 || year-400==0)
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Calendar.c> ."
63,"int get_day_code (int year)
{
int day_code;
int x1, x2, x3;
	x1 = (year - 1.)/ 4.0;
	x2 = (year - 1.)/ 100.;
	x3 = (year - 1.)/ 400.;
day_code = (year + x1 - x2 + x3) %7;
return day_code;
}             ",
64,"int get_day_code (int year)
{
int day_code;
int x1, x2, x3;
	x1 = (year - 1.)/ 4.0;
	x2 = (year - 1.)/ 100.;
	x3 = (year - 1.)/ 400.;
day_code = (year + x1-- - x2 + x3) %7;
return day_code;
}             ","<mb:mutant#4fa4e7d9f92295693dc82cf23e8a5b4e9f0edf0a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -51 +51 @@
-day_code = (year + x1 - x2 + x3) %7;
+day_code = (year + x1-- - x2 + x3) %7;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Calendar.c> ."
65,"int get_leap_year (int year)
{
if(year% 4==0 && year-100 != 0 || year%400==0)
   return TRUE;
   else return FALSE;	
}","<mb:mutant#1f64b1c89ca5d5babbd230e0fdcc2235aeb7ef57> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -57 +57 @@
-if(year% 4==0 && year%100 != 0 || year%400==0)
+if(year% 4==0 && year-100 != 0 || year%400==0)
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Calendar.c> ."
66,"int get_leap_year (int year)
{
if(year% 4<=0 && year%100 != 0 || year%400==0)
   return TRUE;
   else return FALSE;	
}","<mb:mutant#a7f399ed955d5e28bbd8f437776b40802acd7df0> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -57 +57 @@
-if(year% 4==0 && year%100 != 0 || year%400==0)
+if(year% 4<=0 && year%100 != 0 || year%400==0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Calendar.c> ."
69,"int get_day_code (int year)
{
int day_code;
int x1, x2, x3;
	x1 = (year - 1.)/ 4.0;
	x2 = (year - 1.)/ 100.;
	x3 = (year - 1.)/ 400.;
day_code = (year + x1 - x2++ + x3) %7;
return day_code;
}             ","<mb:mutant#059de04e35a26d9ffb5e488f9efaba6ae5256493> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -51 +51 @@
-day_code = (year + x1 - x2 + x3) %7;
+day_code = (year + x1 - x2++ + x3) %7;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Calendar.c> ."
70,"int get_leap_year (int year)
{
if(year% 4==0 && year/100 != 0 || year%400==0)
   return TRUE;
   else return FALSE;	
}","<mb:mutant#b77c86eaf99a88bf13ba1cda143632f2ca82860f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -57 +57 @@
-if(year% 4==0 && year%100 != 0 || year%400==0)
+if(year% 4==0 && year/100 != 0 || year%400==0)
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Calendar.c> ."
71,"int get_leap_year (int year)
{
if(year% 4==0 && year%100 != 0 || year++%400==0)
   return TRUE;
   else return FALSE;	
}","<mb:mutant#1103c4ab235f98f0425333598b1296262191c293> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -57 +57 @@
-if(year% 4==0 && year%100 != 0 || year%400==0)
+if(year% 4==0 && year%100 != 0 || year++%400==0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Calendar.c> ."
72,"int get_day_code (int year)
{
int day_code;
int x1, x2, x3;
	x1 = (year - 1.)/ 4.0;
	x2 = (year - 1.)/ 100.;
	x3 = (year - 1.)/ 400.;
day_code = (year + x1 - x2 + x3) %7;
return day_code++;
}             ","<mb:mutant#c7694308a6e382708102b8d2316edb9b1b26416d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -52 +52 @@
-return day_code;
+return day_code++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Calendar.c> ."
73,"int get_day_code (int year)
{
int day_code;
int x1, x2, x3;
	x1 = (year - 1.)/ 4.0;
	x2 = (year * 1.)/ 100.;
	x3 = (year - 1.)/ 400.;
day_code = (year + x1 - x2 + x3) %7;
return day_code;
}             ","<mb:mutant#48bef138892308d1f139762f2be8476d815b90b0> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -49 +49 @@
-	x2 = (year - 1.)/ 100.;
+	x2 = (year * 1.)/ 100.;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Calendar.c> ."
75,"int get_day_code (int year)
{
int day_code;
int x1, x2, x3;
	x1 = (year - 1.)/ 4.0;
	x2 = (year - 1.)/ 100.;
	x3 = (year / 1.)/ 400.;
day_code = (year + x1 - x2 + x3) %7;
return day_code;
}             ","<mb:mutant#187bf3dd5964548c58a9ff17ccf3c73a56abcef7> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -50 +50 @@
-	x3 = (year - 1.)/ 400.;
+	x3 = (year / 1.)/ 400.;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Calendar.c> ."
76,"int get_day_code (int year)
{
int day_code;
int x1, x2, x3;
	x1 = (year - 1.)/ 4.0;
	x2 = (year - 1.)/ 100.;
	x3 = (abs(year) - 1.)/ 400.;
day_code = (year + x1 - x2 + x3) %7;
return day_code;
}             ","<mb:mutant#328154589a960ee3668dcc79baad8f52b060783e> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -50 +49 @@
-	x3 = (year - 1.)/ 400.;
+	x3 = (abs(year) - 1.)/ 400.;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Calendar.c> ."
77,"int get_day_code (int year)
{
int day_code;
int x1, x2, x3;
	x1 = (year - 1.)/ 4.0;
	x2 = (year - 1.)/ 100.;
	x3 = (year - 1.)/ 400.;
day_code = (year-- + x1 - x2 + x3) %7;
return day_code;
}             ","<mb:mutant#a6518c01663421a79a0a15ea44f66f17b807d37c> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -51 +51 @@
-day_code = (year + x1 - x2 + x3) %7;
+day_code = (year-- + x1 - x2 + x3) %7;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Calendar.c> ."
78,"int get_day_code (int year)
{
int day_code;
int x1, x2, x3;
	x1 = (year - 1.)/ 4.0;
	x2 = (abs(year) - 1.)/ 100.;
	x3 = (year - 1.)/ 400.;
day_code = (year + x1 - x2 + x3) %7;
return day_code;
}             ","<mb:mutant#df63466ad5238c57a488971a2366b9e06af6314b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -49 +48 @@
-	x2 = (year - 1.)/ 100.;
+	x2 = (abs(year) - 1.)/ 100.;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Calendar.c> ."
79,"int get_day_code (int year)
{
int day_code;
int x1, x2, x3;
	x1 = (year - 1.)/ 4.0;
	x2 = (year - 1.)/ 100.;
	x3 = (year + 1.)/ 400.;
day_code = (year + x1 - x2 + x3) %7;
return day_code;
}             ","<mb:mutant#c1f0bd8699dec3aa6c82f94174eb1cbaef18b27b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -50 +50 @@
-	x3 = (year - 1.)/ 400.;
+	x3 = (year + 1.)/ 400.;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Calendar.c> ."
80,"int get_leap_year (int year)
{
if(year% 4==0 && year%100 != 0 || year%400<=0)
   return TRUE;
   else return FALSE;	
}","<mb:mutant#8f1db42e63e51c70170b09d55838e60b580bd04c> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -57 +57 @@
-if(year% 4==0 && year%100 != 0 || year%400==0)
+if(year% 4==0 && year%100 != 0 || year%400<=0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Calendar.c> ."
81,"int get_leap_year (int year)
{
if(year% 4==0 && year%100 != 0 || year%400>=0)
   return TRUE;
   else return FALSE;	
}","<mb:mutant#1a5a02619aaf0c10e8dc279fbac9c915035ebd96> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -57 +57 @@
-if(year% 4==0 && year%100 != 0 || year%400==0)
+if(year% 4==0 && year%100 != 0 || year%400>=0)
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Calendar.c> ."
82,"int get_leap_year (int year)
{
if(year% 4==0 && year%100 > 0 || year%400==0)
   return TRUE;
   else return FALSE;	
}","<mb:mutant#78be4a66298a5fa64c829694298a88466fff31ac> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -57 +57 @@
-if(year% 4==0 && year%100 != 0 || year%400==0)
+if(year% 4==0 && year%100 > 0 || year%400==0)
"""""" ;
    mb:equivalence ""false""^^schema:boolean,
        ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Calendar.c> ."
83,"int get_day_code (int year)
{
int day_code;
int x1, x2, x3;
	x1 = (year - 1.)/ 4.0;
	x2 = (year - 1.)/ 100.;
	x3 = (year - 1.)/ 400.;
day_code = (year + x1 - x2 + x3) %7;
return abs(day_code);
}             ","<mb:mutant#0f81835c4b35f38b9201eaf50fb2a91d5f29ac96> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -52 +51 @@
-return day_code;
+return abs(day_code);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Calendar.c> ."
84,"int get_day_code (int year)
{
int day_code;
int x1, x2, x3;
	x1 = (year - 1.)/ 4.0;
	x2 = (year - 1.)/ 100.;
	x3 = (year - 1.)/ 400.;
day_code = (year + x1 - abs(x2) + x3) %7;
return day_code;
}             ","<mb:mutant#bf1a0699067f3fbb0d00bf81e29ca669b35cc77f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -51 +50 @@
-day_code = (year + x1 - x2 + x3) %7;
+day_code = (year + x1 - abs(x2) + x3) %7;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Calendar.c> ."
86,"int get_day_code (int year)
{
int day_code;
int x1, x2, x3;
	x1 = (year - 1.)/ 4.0;
	x2 = (year - 1.)/ 100.;
	x3 = (year - 1.)/ 400.;
day_code = (year + x1 - x2-- + x3) %7;
return day_code;
}             ","<mb:mutant#ce3d70cc6bd3eec054822560c7db970b58c52f77> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -51 +51 @@
-day_code = (year + x1 - x2 + x3) %7;
+day_code = (year + x1 - x2-- + x3) %7;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Calendar.c> ."
88,"int get_day_code (int year)
{
int day_code;
int x1, x2, x3;
	x1 = (year - 1.)/ 4.0;
	x2 = (year - 1.)/ 100.;
	x3 = (year - 1.)/ 400.;
day_code = (year++ + x1 - x2 + x3) %7;
return day_code;
}             ","<mb:mutant#f4c5f024f7c22c33c303ab341d4364498ad419b1> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -51 +51 @@
-day_code = (year + x1 - x2 + x3) %7;
+day_code = (year++ + x1 - x2 + x3) %7;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Calendar.c> ."
89,"int get_leap_year (int year)
{
if(year% 4==0 && year%100 != 0 || year+400==0)
   return TRUE;
   else return FALSE;	
}","<mb:mutant#0dff786ae3cd7a608f9c50b4c2f6c8a1f457caa4> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -57 +57 @@
-if(year% 4==0 && year%100 != 0 || year%400==0)
+if(year% 4==0 && year%100 != 0 || year+400==0)
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Calendar.c> ."
90,"int get_day_code (int year)
{
int day_code;
int x1, x2, x3;
	x1 = (year - 1.)/ 4.0;
	x2 = (year - 1.)/ 100.;
	x3 = (year - 1.)/ 400.;
day_code = (abs(year) + x1 - x2 + x3) %7;
return day_code;
}             ","<mb:mutant#bf5675def1737dddcfd8ce0c86d803328c5ba8bf> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -51 +50 @@
-day_code = (year + x1 - x2 + x3) %7;
+day_code = (abs(year) + x1 - x2 + x3) %7;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Calendar.c> ."
91,"int get_day_code (int year)
{
int day_code;
int x1, x2, x3;
	x1 = (year - 1.)/ 4.0;
	x2 = (year - 1.)/ 100.;
	x3 = (year - 1.)/ 400.;
day_code = (year + x1 - x2 + abs(x3)) %7;
return day_code;
}             ","<mb:mutant#0be4abdaed4103eb2411d12ecf366bdff9e9e592> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -51 +50 @@
-day_code = (year + x1 - x2 + x3) %7;
+day_code = (year + x1 - x2 + abs(x3)) %7;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Calendar.c> ."
93,"int get_day_code (int year)
{
int day_code;
int x1, x2, x3;
	x1 = (year - 1.)/ 4.0;
	x2 = (year + 1.)/ 100.;
	x3 = (year - 1.)/ 400.;
day_code = (year + x1 - x2 + x3) %7;
return day_code;
}             ","<mb:mutant#ada01bd883224443965ccb1b615f7b6c72b0acb0> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -49 +49 @@
-	x2 = (year - 1.)/ 100.;
+	x2 = (year + 1.)/ 100.;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Calendar.c> ."
94,"int get_leap_year (int year)
{
if(year% 4==0 && year%100 != 0 || year*400==0)
   return TRUE;
   else return FALSE;	
}","<mb:mutant#8f99f4ab70100c665b6c51dca60f75105c1d2fbd> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -57 +57 @@
-if(year% 4==0 && year%100 != 0 || year%400==0)
+if(year% 4==0 && year%100 != 0 || year*400==0)
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Calendar.c> ."
95,"int get_day_code (int year)
{
int day_code;
int x1, x2, x3;
	x1 = (abs(year) - 1.)/ 4.0;
	x2 = (year - 1.)/ 100.;
	x3 = (year - 1.)/ 400.;
day_code = (year + x1 - x2 + x3) %7;
return day_code;
}             ","<mb:mutant#e63bd5980a2e4124490e9ded882186755b96a91d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -48 +47 @@
-	x1 = (year - 1.)/ 4.0;
+	x1 = (abs(year) - 1.)/ 4.0;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Calendar.c> ."
96,"int get_leap_year (int year)
{
if(year% 4==0 && year%100 >= 0 || year%400==0)
   return TRUE;
   else return FALSE;	
}","<mb:mutant#c342b1dfc9303968e96221a52a023034fbb0096f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -57 +57 @@
-if(year% 4==0 && year%100 != 0 || year%400==0)
+if(year% 4==0 && year%100 >= 0 || year%400==0)
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Calendar.c> ."
97,"int get_day_code (int year)
{
int day_code;
int x1, x2, x3;
	x1 = (year - 1.)/ 4.0;
	x2 = (year - 1.)/ 100.;
	x3 = (year - 1.)/ 400.;
day_code = (year + x1++ - x2 + x3) %7;
return day_code;
}             ","<mb:mutant#f013764e5a5267f8f37c63c3b2d7fd30d08b457f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -51 +51 @@
-day_code = (year + x1 - x2 + x3) %7;
+day_code = (year + x1++ - x2 + x3) %7;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Calendar.c> ."
98,"int get_leap_year (int year)
{
if(year% 4==0 && year+100 != 0 || year%400==0)
   return TRUE;
   else return FALSE;	
}","<mb:mutant#23d1885ad491fb42e44d1479a0feb200b2b33f9a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -57 +57 @@
-if(year% 4==0 && year%100 != 0 || year%400==0)
+if(year% 4==0 && year+100 != 0 || year%400==0)
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Calendar.c> ."
99,"int get_day_code (int year)
{
int day_code;
int x1, x2, x3;
	x1 = (year - 1.)/ 4.0;
	x2 = (year - 1.)/ 100.;
	x3 = (year - 1.)/ 400.;
day_code = (year + abs(x1) - x2 + x3) %7;
return day_code;
}             ","<mb:mutant#e204389e400e0672f81f373377bc41cc6c265c21> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -51 +50 @@
-day_code = (year + x1 - x2 + x3) %7;
+day_code = (year + abs(x1) - x2 + x3) %7;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Calendar.c> ."
100,"int get_year (void)
{
unsigned int year;
printf (""Enter a year: "");
scanf (""%d"", &year);
return year;
}             ",
101,"int get_year (void)
{
unsigned int year;
printf (""Enter a year: "");
scanf (""%d"", &year);
return abs(year);
}             ","<mb:mutant#fa00f58af55c56efe95e263252c0ab3d30b1f288> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -42 +41 @@
-return year;
+return abs(year);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Calendar.c> ."
103,"int get_leap_year (int year)
{
if(year% 4==0 && year%100 != 0 || year/400==0)
   return TRUE;
   else return FALSE;	
}","<mb:mutant#602b240b8c2cfea5d9484ff955c99b9baac9c732> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -57 +57 @@
-if(year% 4==0 && year%100 != 0 || year%400==0)
+if(year% 4==0 && year%100 != 0 || year/400==0)
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Calendar.c> ."
104,"int get_day_code (int year)
{
int day_code;
int x1, x2, x3;
	x1 = (year - 1.)/ 4.0;
	x2 = (year - 1.)/ 100.;
	x3 = (year - 1.)/ 400.;
day_code = (year + x1 - x2 + x3++) %7;
return day_code;
}             ","<mb:mutant#cfed530a40f1da3494173d852c8e62596fd29157> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -51 +51 @@
-day_code = (year + x1 - x2 + x3) %7;
+day_code = (year + x1 - x2 + x3++) %7;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Calendar.c> ."
105,"int get_day_code (int year)
{
int day_code;
int x1, x2, x3;
	x1 = (year - 1.)/ 4.0;
	x2 = (year - 1.)/ 100.;
	x3 = (year - 1.)/ 400.;
day_code = (year + x1 - x2 + x3--) %7;
return day_code;
}             ","<mb:mutant#bc32445bbf1993b9102b7a2eb519af3ae9ad4629> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -51 +51 @@
-day_code = (year + x1 - x2 + x3) %7;
+day_code = (year + x1 - x2 + x3--) %7;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Calendar.c> ."
106,"int get_day_code (int year)
{
int day_code;
int x1, x2, x3;
	x1 = (year - 1.)/ 4.0;
	x2 = (year / 1.)/ 100.;
	x3 = (year - 1.)/ 400.;
day_code = (year + x1 - x2 + x3) %7;
return day_code;
}             ","<mb:mutant#67f186363dd1fc566e989aa6357d0a6ca87295c3> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -49 +49 @@
-	x2 = (year - 1.)/ 100.;
+	x2 = (year / 1.)/ 100.;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Calendar.c> ."
107,"int get_leap_year (int year)
{
if(year% 4==0 && year*100 != 0 || year%400==0)
   return TRUE;
   else return FALSE;	
}","<mb:mutant#70594dd6fc5d59a39069eff8031894accb4ed351> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -57 +57 @@
-if(year% 4==0 && year%100 != 0 || year%400==0)
+if(year% 4==0 && year*100 != 0 || year%400==0)
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Calendar.c> ."
109,"{ 
	int a[4]={-14,6,28};
	int number,temp1,temp2,end,i,j; 
	printf(""original array is:\n""); 
	for(i=0;i<3;i++) 
		printf(""%5d"",a[i]); 
	printf(""\n""); 
	printf(""insert a new number:""); 
	scanf(""%d"",&number); 
	end=a[2]; 
	if(number>=end) 
		a[3]=number; 
	else 
	{
		for(i=0;i<3;i++) 
		{ 
			if(a[i]>number) 
			{
				temp1=a[i]; 
				a[i]=number; 
				for(j=i+1;j<4;j++)
				{
					temp2=a[j]; 
					a[j]=temp1; 
					temp1=temp2;
				} 
				break;
			}
		} 
	} 
	for(i=0;i<4;i++) 
		printf(""%6d"",a[i]); 
	printf(""\n"");
}",
110,"{ 
	int a[4]={-14,6,28};
	int number,temp1,temp2,end,i,j; 
	printf(""original array is:\n""); 
	for(i=0;i<3;i++) 
		printf(""%5d"",a[i]); 
	printf(""\n""); 
	printf(""insert a new number:""); 
	scanf(""%d"",&number); 
	end=a[2]; 
	if(number>=end) 
		a[3]=number; 
	else 
	{
		for(i=0;i<3;i++) 
		{ 
			if(a[i]>=number)
			{
				temp1=a[i]; 
				a[i]=number; 
				for(j=i+1;j<4;j++)
				{
					temp2=a[j]; 
					a[j]=temp1; 
					temp1=temp2;
				} 
				break;
			}
		} 
	} 
	for(i=0;i<4;i++) 
		printf(""%6d"",a[i]); 
	printf(""\n"");
}","<mb:mutant#4a7ac6b342c5974c6b479886b9216d448b67c747> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -18 +18 @@
-			if(a[i]>number)
+			if(a[i]>=number)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Insert.c> ."
111,"{ 
	int a[4]={-14,6,28};
	int number,temp1,temp2,end,i,j; 
	printf(""original array is:\n""); 
	for(i=0;i<3;i++) 
		printf(""%5d"",a[i]); 
	printf(""\n""); 
	printf(""insert a new number:""); 
	scanf(""%d"",&number); 
	end=a[2]; 
	if(number>=end) 
		a[3]=number; 
	else 
	{
		for(i=0;i<3;i++) 
		{ 
			if(a[i]>number) 
			{
				temp1=a[i]; 
				a[i]=number; 
				for(j=i+1;j<4;j++)
				{
					temp2=a[j]; 
					a[j]=temp1; 
					temp1=temp2;
				} 
				break;
			}
		} 
	} 
	for(i=0;i<4;i++) 
		printf(""%6d"",a[i]--);
	printf(""\n"");
}","<mb:mutant#908772f067a2148b8ebfe7dc5c8342194533f409> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -33 +33 @@
-		printf(""%6d"",a[i]);
+		printf(""%6d"",a[i]--);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Insert.c> ."
112,"{ 
	int a[4]={-14,6,28};
	int number,temp1,temp2,end,i,j; 
	printf(""original array is:\n""); 
	for(i=0;i<3;i++) 
		printf(""%5d"",a[i]); 
	printf(""\n""); 
	printf(""insert a new number:""); 
	scanf(""%d"",&number); 
	end=a[2]; 
	if(number>=end++)
		a[3]=number; 
	else 
	{
		for(i=0;i<3;i++) 
		{ 
			if(a[i]>number) 
			{
				temp1=a[i]; 
				a[i]=number; 
				for(j=i+1;j<4;j++)
				{
					temp2=a[j]; 
					a[j]=temp1; 
					temp1=temp2;
				} 
				break;
			}
		} 
	} 
	for(i=0;i<4;i++) 
		printf(""%6d"",a[i]); 
	printf(""\n"");
}","<mb:mutant#02714cf15e82d2f0ff997515c13ea169b4097abe> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -12 +12 @@
-	if(number>=end)
+	if(number>=end++)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Insert.c> ."
113,"{ 
	int a[4]={-14,6,28};
	int number,temp1,temp2,end,i,j; 
	printf(""original array is:\n""); 
	for(i=0;i<3;i++) 
		printf(""%5d"",a[i]); 
	printf(""\n""); 
	printf(""insert a new number:""); 
	scanf(""%d"",&number); 
	end=a[2]; 
	if(number>=end) 
		a[3]=number; 
	else 
	{
		for(i=0;i<3;i++) 
		{ 
			if(a[i]>number) 
			{
				temp1=a[i]; 
				a[i]=number; 
				for(j=i+1;j<4;j++)
				{
					temp2=a[j]; 
					a[j]=temp1++;
					temp1=temp2;
				} 
				break;
			}
		} 
	} 
	for(i=0;i<4;i++) 
		printf(""%6d"",a[i]); 
	printf(""\n"");
}","<mb:mutant#d9458fb08f8f4278c08d19b288337a9769d9ecde> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -25 +25 @@
-					a[j]=temp1;
+					a[j]=temp1++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Insert.c> ."
114,"{ 
	int a[4]={-14,6,28};
	int number,temp1,temp2,end,i,j; 
	printf(""original array is:\n""); 
	for(i=0;i<3;i++) 
		printf(""%5d"",a[i]); 
	printf(""\n""); 
	printf(""insert a new number:""); 
	scanf(""%d"",&number); 
	end=a[2]; 
	if(number>=end) 
		a[3]=number; 
	else 
	{
		for(i=0;i<3;i++) 
		{ 
			if(a[i]>number) 
			{
				temp1=a[i]; 
				a[i]=number; 
				for(j=i+1;j<4;j++)
				{
					temp2=a[j]++;
					a[j]=temp1; 
					temp1=temp2;
				} 
				break;
			}
		} 
	} 
	for(i=0;i<4;i++) 
		printf(""%6d"",a[i]); 
	printf(""\n"");
}","<mb:mutant#7e8881d2663c1212494bae5c55e1a11168b8437d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -24 +24 @@
-					temp2=a[j];
+					temp2=a[j]++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Insert.c> ."
115,"{ 
	int a[4]={-14,6,28};
	int number,temp1,temp2,end,i,j; 
	printf(""original array is:\n""); 
	for(i=0;i<3;i++) 
		printf(""%5d"",a[i]); 
	printf(""\n""); 
	printf(""insert a new number:""); 
	scanf(""%d"",&number); 
	end=a[2]; 
	if(number>end)
		a[3]=number; 
	else 
	{
		for(i=0;i<3;i++) 
		{ 
			if(a[i]>number) 
			{
				temp1=a[i]; 
				a[i]=number; 
				for(j=i+1;j<4;j++)
				{
					temp2=a[j]; 
					a[j]=temp1; 
					temp1=temp2;
				} 
				break;
			}
		} 
	} 
	for(i=0;i<4;i++) 
		printf(""%6d"",a[i]); 
	printf(""\n"");
}","<mb:mutant#4ab963dfd4c2829c07420851717ca4af7f1603ef> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -12 +12 @@
-	if(number>=end)
+	if(number>end)
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Insert.c> ."
116,"{ 
	int a[4]={-14,6,28};
	int number,temp1,temp2,end,i,j; 
	printf(""original array is:\n""); 
	for(i=0;i<3;i++) 
		printf(""%5d"",a[i]); 
	printf(""\n""); 
	printf(""insert a new number:""); 
	scanf(""%d"",&number); 
	end=abs(a[2]);
	if(number>=end) 
		a[3]=number; 
	else 
	{
		for(i=0;i<3;i++) 
		{ 
			if(a[i]>number) 
			{
				temp1=a[i]; 
				a[i]=number; 
				for(j=i+1;j<4;j++)
				{
					temp2=a[j]; 
					a[j]=temp1; 
					temp1=temp2;
				} 
				break;
			}
		} 
	} 
	for(i=0;i<4;i++) 
		printf(""%6d"",a[i]); 
	printf(""\n"");
}","<mb:mutant#a9361290a119d7a61654893999f5ea285cd15cf3> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -11 +11 @@
-	end=a[2];
+	end=abs(a[2]);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:program <mb:program#Insert.c> ."
117,"{ 
	int a[4]={-14,6,28};
	int number,temp1,temp2,end,i,j; 
	printf(""original array is:\n""); 
	for(i=0;i<3;i++) 
		printf(""%5d"",a[i]); 
	printf(""\n""); 
	printf(""insert a new number:""); 
	scanf(""%d"",&number); 
	end=a[2]; 
	if(number>=end) 
		a[3]=number; 
	else 
	{
		for(i=0;i<3;i++) 
		{ 
			if(a[i]>number) 
			{
				temp1=a[i]; 
				a[i]=number++;
				for(j=i+1;j<4;j++)
				{
					temp2=a[j]; 
					a[j]=temp1; 
					temp1=temp2;
				} 
				break;
			}
		} 
	} 
	for(i=0;i<4;i++) 
		printf(""%6d"",a[i]); 
	printf(""\n"");
}","<mb:mutant#b35fab526a318990e35162cee280c2335a1b1eca> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -21 +21 @@
-				a[i]=number;
+				a[i]=number++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Insert.c> ."
118,"{ 
	int a[4]={-14,6,28};
	int number,temp1,temp2,end,i,j; 
	printf(""original array is:\n""); 
	for(i=0;i<3;i++) 
		printf(""%5d"",a[i]); 
	printf(""\n""); 
	printf(""insert a new number:""); 
	scanf(""%d"",&number); 
	end=a[2]; 
	if(number>=end) 
		a[3]=number; 
	else 
	{
		for(i=0;i<3;i++) 
		{ 
			if(a[i]>number) 
			{
				temp1=a[i]--;
				a[i]=number; 
				for(j=i+1;j<4;j++)
				{
					temp2=a[j]; 
					a[j]=temp1; 
					temp1=temp2;
				} 
				break;
			}
		} 
	} 
	for(i=0;i<4;i++) 
		printf(""%6d"",a[i]); 
	printf(""\n"");
}","<mb:mutant#e7f2206bcedd870570b5501c90180f872bf41ba6> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -20 +20 @@
-				temp1=a[i];
+				temp1=a[i]--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Insert.c> ."
119,"{ 
	int a[4]={-14,6,28};
	int number,temp1,temp2,end,i,j; 
	printf(""original array is:\n""); 
	for(i=0;i<3;i++) 
		printf(""%5d"",a[i]); 
	printf(""\n""); 
	printf(""insert a new number:""); 
	scanf(""%d"",&number); 
	end=a[2]; 
	if(number>=end) 
		a[3]=number; 
	else 
	{
		for(i=0;i<3;i++) 
		{ 
			if(a[i]>number) 
			{
				temp1=a[i]; 
				a[i]=number; 
				for(j=i+1;j<4;j++)
				{
					temp2=a[j]; 
					a[j]=temp1; 
					temp1=temp2++;
				} 
				break;
			}
		} 
	} 
	for(i=0;i<4;i++) 
		printf(""%6d"",a[i]); 
	printf(""\n"");
}","<mb:mutant#77336e5cdb546421a30f0772cda8ea499656ba18> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -26 +26 @@
-					temp1=temp2;
+					temp1=temp2++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Insert.c> ."
120,"{ 
	int a[4]={-14,6,28};
	int number,temp1,temp2,end,i,j; 
	printf(""original array is:\n""); 
	for(i=0;i<3;i++) 
		printf(""%5d"",a[i]); 
	printf(""\n""); 
	printf(""insert a new number:""); 
	scanf(""%d"",&number); 
	end=a[2]; 
	if(number>=end) 
		a[3]=number; 
	else 
	{
		for(i=0;i<3;i++) 
		{ 
			if(a[i]>number) 
			{
				temp1=a[i]; 
				a[i]=number; 
				for(j=i+1;j<4;j++)
				{
					temp2=a[j]--;
					a[j]=temp1; 
					temp1=temp2;
				} 
				break;
			}
		} 
	} 
	for(i=0;i<4;i++) 
		printf(""%6d"",a[i]); 
	printf(""\n"");
}","<mb:mutant#f71ac11d0e31052d01f81678ddafc7f6bb2cc988> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -24 +24 @@
-					temp2=a[j];
+					temp2=a[j]--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Insert.c> ."
121,"{ 
	int a[4]={-14,6,28};
	int number,temp1,temp2,end,i,j; 
	printf(""original array is:\n""); 
	for(i=0;i<3;i++) 
		printf(""%5d"",a[i]); 
	printf(""\n""); 
	printf(""insert a new number:""); 
	scanf(""%d"",&number); 
	end=a[2]; 
	if(number>=end) 
		a[3]=number; 
	else 
	{
		for(i=0;i<3;i++) 
		{ 
			if(a[i]>number) 
			{
				temp1=a[i]; 
				a[i]=number; 
				for(j=i+1;j<4;j++)
				{
					temp2=a[j]; 
					a[j]=temp1; 
					temp1=temp2--;
				} 
				break;
			}
		} 
	} 
	for(i=0;i<4;i++) 
		printf(""%6d"",a[i]); 
	printf(""\n"");
}","<mb:mutant#b84cd7c8760fc6a3e4fb06f679cab019882e77a2> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -26 +26 @@
-					temp1=temp2;
+					temp1=temp2--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Insert.c> ."
122,"{ 
	int a[4]={-14,6,28};
	int number,temp1,temp2,end,i,j; 
	printf(""original array is:\n""); 
	for(i=0;i<3;i++) 
		printf(""%5d"",a[i]); 
	printf(""\n""); 
	printf(""insert a new number:""); 
	scanf(""%d"",&number); 
	end=a[2]; 
	if(number>=end) 
		a[3]=number--;
	else 
	{
		for(i=0;i<3;i++) 
		{ 
			if(a[i]>number) 
			{
				temp1=a[i]; 
				a[i]=number; 
				for(j=i+1;j<4;j++)
				{
					temp2=a[j]; 
					a[j]=temp1; 
					temp1=temp2;
				} 
				break;
			}
		} 
	} 
	for(i=0;i<4;i++) 
		printf(""%6d"",a[i]); 
	printf(""\n"");
}","<mb:mutant#67b1cb9d9c7c28305660b5da74905464cd9929b3> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -13 +13 @@
-		a[3]=number;
+		a[3]=number--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Insert.c> ."
123,"{ 
	int a[4]={-14,6,28};
	int number,temp1,temp2,end,i,j; 
	printf(""original array is:\n""); 
	for(i=0;i<3;i++) 
		printf(""%5d"",a[i]); 
	printf(""\n""); 
	printf(""insert a new number:""); 
	scanf(""%d"",&number); 
	end=a[2]; 
	if(number>=end) 
		a[3]=number; 
	else 
	{
		for(i=0;i<3;i++) 
		{ 
			if(a[i]>number) 
			{
				temp1=a[i]; 
				a[i]=number; 
				for(j=i+1;j<4;j++)
				{
					temp2=a[j]; 
					a[j]=temp1--;
					temp1=temp2;
				} 
				break;
			}
		} 
	} 
	for(i=0;i<4;i++) 
		printf(""%6d"",a[i]); 
	printf(""\n"");
}","<mb:mutant#4ffb72eef63d906675cd758adb27e99733c46f0b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -25 +25 @@
-					a[j]=temp1;
+					a[j]=temp1--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Insert.c> ."
124,"{ 
	int a[4]={-14,6,28};
	int number,temp1,temp2,end,i,j; 
	printf(""original array is:\n""); 
	for(i=0;i<3;i++) 
		printf(""%5d"",a[i]); 
	printf(""\n""); 
	printf(""insert a new number:""); 
	scanf(""%d"",&number); 
	end=a[2]; 
	if(number>=end--)
		a[3]=number; 
	else 
	{
		for(i=0;i<3;i++) 
		{ 
			if(a[i]>number) 
			{
				temp1=a[i]; 
				a[i]=number; 
				for(j=i+1;j<4;j++)
				{
					temp2=a[j]; 
					a[j]=temp1; 
					temp1=temp2;
				} 
				break;
			}
		} 
	} 
	for(i=0;i<4;i++) 
		printf(""%6d"",a[i]); 
	printf(""\n"");
}","<mb:mutant#9826a4433fdf1d738f4878ec451c34d79ece0258> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -12 +12 @@
-	if(number>=end)
+	if(number>=end--)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Insert.c> ."
125,"{ 
	int a[4]={-14,6,28};
	int number,temp1,temp2,end,i,j; 
	printf(""original array is:\n""); 
	for(i=0;i<3;i++) 
		printf(""%5d"",a[i]); 
	printf(""\n""); 
	printf(""insert a new number:""); 
	scanf(""%d"",&number); 
	end=a[2]; 
	if(number>=end) 
		a[3]=number; 
	else 
	{
		for(i=0;i<3;i++) 
		{ 
			if(a[i]>number) 
			{
				temp1=a[i]++;
				a[i]=number; 
				for(j=i+1;j<4;j++)
				{
					temp2=a[j]; 
					a[j]=temp1; 
					temp1=temp2;
				} 
				break;
			}
		} 
	} 
	for(i=0;i<4;i++) 
		printf(""%6d"",a[i]); 
	printf(""\n"");
}","<mb:mutant#2b583389bc4e7a007156981a13a074d6208afe77> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -20 +20 @@
-				temp1=a[i];
+				temp1=a[i]++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Insert.c> ."
126,"{ 
	int a[4]={-14,6,28};
	int number,temp1,temp2,end,i,j; 
	printf(""original array is:\n""); 
	for(i=0;i<3;i++) 
		printf(""%5d"",a[i]); 
	printf(""\n""); 
	printf(""insert a new number:""); 
	scanf(""%d"",&number); 
	end=a[2]; 
	if(number>=end) 
		a[3]=number; 
	else 
	{
		for(i=0;i<3;i++) 
		{ 
			if(a[i]>number) 
			{
				temp1=a[i]; 
				a[i]=number; 
				for(j=i+1;j<4;j++)
				{
					temp2=a[j]; 
					a[j]=temp1; 
					temp1=temp2;
				} 
				break;
			}
		} 
	} 
	for(i=0;i<4;i++) 
		printf(""%6d"",a[i]++);
	printf(""\n"");
}","<mb:mutant#55cf6dee8f75870642aa3b6f9dcf721eddd46f3f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -33 +33 @@
-		printf(""%6d"",a[i]);
+		printf(""%6d"",a[i]++);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Insert.c> ."
127,"{ 
	int a[4]={-14,6,28};
	int number,temp1,temp2,end,i,j; 
	printf(""original array is:\n""); 
	for(i=0;i<3;i++) 
		printf(""%5d"",a[i]); 
	printf(""\n""); 
	printf(""insert a new number:""); 
	scanf(""%d"",&number); 
	end=a[2]; 
	if(number>=++end)
		a[3]=number; 
	else 
	{
		for(i=0;i<3;i++) 
		{ 
			if(a[i]>number) 
			{
				temp1=a[i]; 
				a[i]=number; 
				for(j=i+1;j<4;j++)
				{
					temp2=a[j]; 
					a[j]=temp1; 
					temp1=temp2;
				} 
				break;
			}
		} 
	} 
	for(i=0;i<4;i++) 
		printf(""%6d"",a[i]); 
	printf(""\n"");
}","<mb:mutant#fae54779af8021f15ca85998961dfdf37e3e9764> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -12 +12 @@
-	if(number>=end)
+	if(number>=++end)
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Insert.c> ."
128,"{ 
	int a[4]={-14,6,28};
	int number,temp1,temp2,end,i,j; 
	printf(""original array is:\n""); 
	for(i=0;i<3;i++) 
		printf(""%5d"",a[i]); 
	printf(""\n""); 
	printf(""insert a new number:""); 
	scanf(""%d"",&number); 
	end=a[2]; 
	if(number>=--end)
		a[3]=number; 
	else 
	{
		for(i=0;i<3;i++) 
		{ 
			if(a[i]>number) 
			{
				temp1=a[i]; 
				a[i]=number; 
				for(j=i+1;j<4;j++)
				{
					temp2=a[j]; 
					a[j]=temp1; 
					temp1=temp2;
				} 
				break;
			}
		} 
	} 
	for(i=0;i<4;i++) 
		printf(""%6d"",a[i]); 
	printf(""\n"");
}","<mb:mutant#0f1953e2d217b58db3e3cf75abde79a5a8d7056a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -12 +12 @@
-	if(number>=end)
+	if(number>=--end)
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Insert.c> ."
129,"{ 
	int a[4]={-14,6,28};
	int number,temp1,temp2,end,i,j; 
	printf(""original array is:\n""); 
	for(i=0;i<3;i++) 
		printf(""%5d"",a[i]); 
	printf(""\n""); 
	printf(""insert a new number:""); 
	scanf(""%d"",&number); 
	end=a[2]; 
	if(number>=end) 
		a[3]=number; 
	else 
	{
		for(i=0;i<3;i++) 
		{ 
			if(a[i]>number) 
			{
				temp1=a[i]; 
				a[i]=number--;
				for(j=i+1;j<4;j++)
				{
					temp2=a[j]; 
					a[j]=temp1; 
					temp1=temp2;
				} 
				break;
			}
		} 
	} 
	for(i=0;i<4;i++) 
		printf(""%6d"",a[i]); 
	printf(""\n"");
}","<mb:mutant#faa0d206d16f7c63f5b1b9f264f92fe6e221dc19> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -21 +21 @@
-				a[i]=number;
+				a[i]=number--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Insert.c> ."
130,"{ 
	int a[4]={-14,6,28};
	int number,temp1,temp2,end,i,j; 
	printf(""original array is:\n""); 
	for(i=0;i<3;i++) 
		printf(""%5d"",a[i]); 
	printf(""\n""); 
	printf(""insert a new number:""); 
	scanf(""%d"",&number); 
	end=a[2]; 
	if(number>=end) 
		a[3]=number++;
	else 
	{
		for(i=0;i<3;i++) 
		{ 
			if(a[i]>number) 
			{
				temp1=a[i]; 
				a[i]=number; 
				for(j=i+1;j<4;j++)
				{
					temp2=a[j]; 
					a[j]=temp1; 
					temp1=temp2;
				} 
				break;
			}
		} 
	} 
	for(i=0;i<4;i++) 
		printf(""%6d"",a[i]); 
	printf(""\n"");
}","<mb:mutant#53bb28544e7d6110178b0b51c8f0a4a27ce5d6c0> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -13 +13 @@
-		a[3]=number;
+		a[3]=number++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Insert.c> ."
131,"{ 
	int a[4]={-14,6,28};
	int number,temp1,temp2,end,i,j; 
	printf(""original array is:\n""); 
	for(i=0;i<3;i++) 
		printf(""%5d"",a[i]); 
	printf(""\n""); 
	printf(""insert a new number:""); 
	scanf(""%d"",&number); 
	end=a[2]; 
	if(number>=end) 
		a[3]=abs(number);
	else 
	{
		for(i=0;i<3;i++) 
		{ 
			if(a[i]>number) 
			{
				temp1=a[i]; 
				a[i]=number; 
				for(j=i+1;j<4;j++)
				{
					temp2=a[j]; 
					a[j]=temp1; 
					temp1=temp2;
				} 
				break;
			}
		} 
	} 
	for(i=0;i<4;i++) 
		printf(""%6d"",a[i]); 
	printf(""\n"");
}","<mb:mutant#afd94e74b6f1669ab95d4848374565f6ea19e95c> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -13 +13 @@
-		a[3]=number;
+		a[3]=abs(number);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Insert.c> ."
132,"{ 
	int m,i,k,h=0,leap=1; 
	printf(""\n""); 
	for(m=1;m<=100;m++)
	{ 
		k=sqrt(m+1);
		for(i=2;i<=k;i++) 
		{    
			if(m%i==0) 
			{
				leap=0;
				break;
			}
		}
		if(leap) 
		{
			printf(""%-4d"",m);
			h++; 
			if(h%10==0) 
				printf(""\n""); 
		} 
		leap=1; 
	} 
	printf(""\nThe total is %d"",h); 
}",
133,"{ 
	int m,i,k,h=0,leap=1; 
	printf(""\n""); 
	for(m=1;m<=100;m++)
	{ 
		k=sqrt(m+1);
		for(i=2;i<=k;i++) 
		{    
			if(m%i==0) 
			{
				leap=0;
				break;
			}
		}
		if(leap) 
		{
			printf(""%-4d"",m);
			h++; 
			if(h%10==0) 
				printf(""\n""); 
		} 
		leap=1; 
	} 
	printf(""\nThe total is %d"",h++);
}","<mb:mutant#4429a91f11085e17627632c93860378204a73229> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -26 +26 @@
-	printf(""\\nThe total is %d"",h);
+	printf(""\\nThe total is %d"",h++);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Prime_number.c> ."
134,"{ 
	int m,i,k,h=0,leap=1; 
	printf(""\n""); 
	for(m=1;m<=100;m++)
	{ 
		k=sqrt(m/1);
		for(i=2;i<=k;i++) 
		{    
			if(m%i==0) 
			{
				leap=0;
				break;
			}
		}
		if(leap) 
		{
			printf(""%-4d"",m);
			h++; 
			if(h%10==0) 
				printf(""\n""); 
		} 
		leap=1; 
	} 
	printf(""\nThe total is %d"",h); 
}","<mb:mutant#8216c7ce4b7cfe19396bfec7efdb39481841ea35> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -8 +8 @@
-		k=sqrt(m+1);
+		k=sqrt(m/1);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Prime_number.c> ."
135,"{ 
	int m,i,k,h=0,leap=1; 
	printf(""\n""); 
	for(m=1;m<=100;m++)
	{ 
		k=sqrt(m+1);
		for(i=2;i<=k;i++) 
		{    
			if(m%i==0) 
			{
				leap=0;
				break;
			}
		}
		if(leap) 
		{
			printf(""%-4d"",m);
			h++; 
			if(h%10==0) 
				printf(""\n""); 
		} 
		leap=1; 
	} 
	printf(""\nThe total is %d"",h--);
}","<mb:mutant#95ae4d283953a72cb527f84953575d19e640bc79> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -26 +26 @@
-	printf(""\\nThe total is %d"",h);
+	printf(""\\nThe total is %d"",h--);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Prime_number.c> ."
136,"{ 
	int m,i,k,h=0,leap=1; 
	printf(""\n""); 
	for(m=1;m<=100;m++)
	{ 
		k=sqrt(m*1);
		for(i=2;i<=k;i++) 
		{    
			if(m%i==0) 
			{
				leap=0;
				break;
			}
		}
		if(leap) 
		{
			printf(""%-4d"",m);
			h++; 
			if(h%10==0) 
				printf(""\n""); 
		} 
		leap=1; 
	} 
	printf(""\nThe total is %d"",h); 
}","<mb:mutant#26766ee0c7f9064620a0f3a81371c5961288a582> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -8 +8 @@
-		k=sqrt(m+1);
+		k=sqrt(m*1);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Prime_number.c> ."
137,"{ 
	int m,i,k,h=0,leap=1; 
	printf(""\n""); 
	for(m=1;m<=100;m++)
	{ 
		k=sqrt(m+1);
		for(i=2;i<=k;i++) 
		{    
			if(m%i==0) 
			{
				leap=0;
				break;
			}
		}
		if(leap) 
		{
			printf(""%-4d"",abs(m));
			h++; 
			if(h%10==0) 
				printf(""\n""); 
		} 
		leap=1; 
	} 
	printf(""\nThe total is %d"",h); 
}","<mb:mutant#58eb629865deb0caa12dffe3132c699434058c9e> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -19 +19 @@
-			printf(""%-4d"",m);
+			printf(""%-4d"",abs(m));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Prime_number.c> ."
138,"{ 
	int m,i,k,h=0,leap=1; 
	printf(""\n""); 
	for(m=1;m<=100;m++)
	{ 
		k=sqrt(m+1);
		for(i=2;i<=k;i++) 
		{    
			if(m%i==0) 
			{
				leap=0;
				break;
			}
		}
		if(leap) 
		{
			printf(""%-4d"",m);
			h++; 
			if(h%10<=0)
				printf(""\n""); 
		} 
		leap=1; 
	} 
	printf(""\nThe total is %d"",h); 
}","<mb:mutant#6b606b6964724c866c245223288f14e147f0bace> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -21 +21 @@
-			if(h%10==0)
+			if(h%10<=0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Prime_number.c> ."
139,"{ 
	int m,i,k,h=0,leap=1; 
	printf(""\n""); 
	for(m=1;m<=100;m++)
	{ 
		k=sqrt(abs(m)+1);
		for(i=2;i<=k;i++) 
		{    
			if(m%i==0) 
			{
				leap=0;
				break;
			}
		}
		if(leap) 
		{
			printf(""%-4d"",m);
			h++; 
			if(h%10==0) 
				printf(""\n""); 
		} 
		leap=1; 
	} 
	printf(""\nThe total is %d"",h); 
}","<mb:mutant#a5cacdfc0d8d3dcc21efbe23f48777467affa294> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -8 +8 @@
-		k=sqrt(m+1);
+		k=sqrt(abs(m)+1);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Prime_number.c> ."
140,"{ 
	int m,i,k,h=0,leap=1; 
	printf(""\n""); 
	for(m=1;m<=100;m++)
	{ 
		k=sqrt(m+1);
		for(i=2;i<=k;i++) 
		{    
			if(m%i<=0)
			{
				leap=0;
				break;
			}
		}
		if(leap) 
		{
			printf(""%-4d"",m);
			h++; 
			if(h%10==0) 
				printf(""\n""); 
		} 
		leap=1; 
	} 
	printf(""\nThe total is %d"",h); 
}","<mb:mutant#8eb2d57588c46690567f78699911206635872b98> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -11 +11 @@
-			if(m%i==0)
+			if(m%i<=0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Prime_number.c> ."
141,"{ 
	int m,i,k,h=0,leap=1; 
	printf(""\n""); 
	for(m=1;m<=100;m++)
	{ 
		k=sqrt(m+1);
		for(i=2;i<=k;i++) 
		{    
			if(m%i==0) 
			{
				leap=0;
				break;
			}
		}
		if(leap) 
		{
			printf(""%-4d"",m);
			h++; 
			if(h%10==0) 
				printf(""\n""); 
		} 
		leap=1; 
	} 
	printf(""\nThe total is %d"",abs(h));
}","<mb:mutant#bf347e11f3020b0a6d54f8108b18bba9fe7c505e> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -26 +26 @@
-	printf(""\\nThe total is %d"",h);
+	printf(""\\nThe total is %d"",abs(h));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Prime_number.c> ."
285,"int main( int a, int b, int c )
{
	 int mid;
     if (a < b)
	 {
		 if (c < b)
		 {
			 if (a < c)
				    mid = c;
             else
					mid = a;
		 }
		 else
				mid = b;	 }
	 else
	 {
		 if (c > b)
		 {
			 if (a > c)
				 mid = c;
			 else
				 mid = a;
		 }
		 else
			 mid = b;      }
   return mid;}",
286,"int main( int a, int b, int c )
{
	 int mid;
     if (a < b)
	 {
		 if (c < b)
		 {
			 if (a < c)
				    mid = c;
             else
					mid = a;
		 }
		 else
				mid = b;	 }
	 else
	 {
		 if (c > b)
		 {
			 if (a > c)
				 mid = c;
			 else
				 mid = a++;
		 }
		 else
			 mid = b;      }
   return mid;}","<mb:mutant#51ae95dd50c1209b98e14cc3444c250a738c7a41> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -22 +22 @@
-				 mid = a;
+				 mid = a++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Mid.c> ."
287,"int main( int a, int b, int c )
{
	 int mid;
     if (a < b)
	 {
		 if (c < b)
		 {
			 if (a < c)
				    mid = c;
             else
					mid = a;
		 }
		 else
				mid = b;	 }
	 else
	 {
		 if (c > b)
		 {
			 if (a > c)
				 mid = c;
			 else
				 mid = a;
		 }
		 else
			 mid = b++;      }
   return mid;}","<mb:mutant#f629f2f96d9c990890bc3bae76f1158134f3c9aa> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -25 +25 @@
-			 mid = b;      }
+			 mid = b++;      }
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Mid.c> ."
288,"int main( int a, int b, int c )
{
	 int mid;
     if (a < b)
	 {
		 if (c < b)
		 {
			 if (a < c)
				    mid = c;
             else
					mid = a;
		 }
		 else
				mid = b;	 }
	 else
	 {
		 if (c > b)
		 {
			 if (a > c)
				 mid = c;
			 else
				 mid = a;
		 }
		 else
			 mid = b--;      }
   return mid;}","<mb:mutant#b67c08cd7e88866f6c0d8d842252b382eb5c8a00> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -25 +25 @@
-			 mid = b;      }
+			 mid = b--;      }
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Mid.c> ."
289,"int main( int a, int b, int c )
{
	 int mid;
     if (a < b)
	 {
		 if (c < b)
		 {
			 if (a < c)
				    mid = c;
             else
					mid = a;
		 }
		 else
				mid = b;	 }
	 else
	 {
		 if (c > b)
		 {
			 if (a > c)
				 mid = c;
			 else
				 mid = a--;
		 }
		 else
			 mid = b;      }
   return mid;}","<mb:mutant#3100ee06b8af72416dc5db4ac08f334c30ac0183> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -22 +22 @@
-				 mid = a;
+				 mid = a--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Mid.c> ."
290,"int main( int a, int b, int c )
{
	 int mid;
     if (a < b)
	 {
		 if (c < b)
		 {
			 if (a < c)
				    mid = c;
             else
					mid = a++;
		 }
		 else
				mid = b;	 }
	 else
	 {
		 if (c > b)
		 {
			 if (a > c)
				 mid = c;
			 else
				 mid = a;
		 }
		 else
			 mid = b;      }
   return mid;}","<mb:mutant#ac2751f0b071a5d19eda89be705547bbfb507e35> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -11 +11 @@
-					mid = a;
+					mid = a++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Mid.c> ."
291,"int main( int a, int b, int c )
{
	 int mid;
     if (a <= b)
	 {
		 if (c < b)
		 {
			 if (a < c)
				    mid = c;
             else
					mid = a;
		 }
		 else
				mid = b;	 }
	 else
	 {
		 if (c > b)
		 {
			 if (a > c)
				 mid = c;
			 else
				 mid = a;
		 }
		 else
			 mid = b;      }
   return mid;}","<mb:mutant#3ac0d75710c0c39ff5826c9e3e6bcc07052875e1> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -4 +4 @@
-     if (a < b)
+     if (a <= b)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Mid.c> ."
292,"int main( int a, int b, int c )
{
	 int mid;
     if (a < b)
	 {
		 if (c < b)
		 {
			 if (a < c)
				    mid = c;
             else
					mid = a;
		 }
		 else
				mid = b;	 }
	 else
	 {
		 if (c >= b)
		 {
			 if (a > c)
				 mid = c;
			 else
				 mid = a;
		 }
		 else
			 mid = b;      }
   return mid;}","<mb:mutant#9d8e307bd9fbb2e17ce71cde313a02dbef1630cf> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -17 +17 @@
-		 if (c > b)
+		 if (c >= b)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Mid.c> ."
293,"int main( int a, int b, int c )
{
	 int mid;
     if (a < b)
	 {
		 if (c < b)
		 {
			 if (a < c)
				    mid = c;
             else
					mid = a;
		 }
		 else
				mid = b;	 }
	 else
	 {
		 if (c > b)
		 {
			 if (a > c)
				 mid = c;
			 else
				 mid = a;
		 }
		 else
			 mid = b;      }
   return mid--;}","<mb:mutant#b138b42b88000b2065e54ae3b692464dd28f0649> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -26 +26 @@
-   return mid;}
+   return mid--;}
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Mid.c> ."
294,"int main( int a, int b, int c )
{
	 int mid;
     if (a < b)
	 {
		 if (c < b)
		 {
			 if (a < c)
				    mid = c--;
             else
					mid = a;
		 }
		 else
				mid = b;	 }
	 else
	 {
		 if (c > b)
		 {
			 if (a > c)
				 mid = c;
			 else
				 mid = a;
		 }
		 else
			 mid = b;      }
   return mid;}","<mb:mutant#275c3f79ebdff4b4e9f5fcbdfcd838fb5728fe54> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -9 +9 @@
-				    mid = c;
+				    mid = c--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Mid.c> ."
295,"int main( int a, int b, int c )
{
	 int mid;
     if (a < b)
	 {
		 if (c < b)
		 {
			 if (a < c)
				    mid = c;
             else
					mid = a;
		 }
		 else
				mid = b;	 }
	 else
	 {
		 if (c > b)
		 {
			 if (a > c)
				 mid = c++;
			 else
				 mid = a;
		 }
		 else
			 mid = b;      }
   return mid;}","<mb:mutant#5e5b8d914cf5f678494def09ad61732512b7b61c> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -20 +20 @@
-				 mid = c;
+				 mid = c++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Mid.c> ."
296,"int main( int a, int b, int c )
{
	 int mid;
     if (a < b)
	 {
		 if (c < b)
		 {
			 if (a < c)
				    mid = c;
             else
					mid = a;
		 }
		 else
				mid = b;	 }
	 else
	 {
		 if (c > b)
		 {
			 if (a > c)
				 mid = c;
			 else
				 mid = a;
		 }
		 else
			 mid = b;      }
   return mid++;}","<mb:mutant#98cedb995312dcbefe207c15c7223cd83d16a9c0> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -26 +26 @@
-   return mid;}
+   return mid++;}
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Mid.c> ."
297,"int main( int a, int b, int c )
{
	 int mid;
     if (a < b)
	 {
		 if (c < b)
		 {
			 if (a < c)
				    mid = c;
             else
					mid = a--;
		 }
		 else
				mid = b;	 }
	 else
	 {
		 if (c > b)
		 {
			 if (a > c)
				 mid = c;
			 else
				 mid = a;
		 }
		 else
			 mid = b;      }
   return mid;}","<mb:mutant#e276f9eb44047828294e75f14e5875365a2a8a4d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -11 +11 @@
-					mid = a;
+					mid = a--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Mid.c> ."
298,"int main( int a, int b, int c )
{
	 int mid;
     if (a < b)
	 {
		 if (c <= b)
		 {
			 if (a < c)
				    mid = c;
             else
					mid = a;
		 }
		 else
				mid = b;	 }
	 else
	 {
		 if (c > b)
		 {
			 if (a > c)
				 mid = c;
			 else
				 mid = a;
		 }
		 else
			 mid = b;      }
   return mid;}","<mb:mutant#b9579c6b018dd161df7fcced329e637dec49e8c6> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -6 +6 @@
-		 if (c < b)
+		 if (c <= b)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Mid.c> ."
299,"int main( int a, int b, int c )
{
	 int mid;
     if (a < b)
	 {
		 if (c < b)
		 {
			 if (a < c)
				    mid = c++;
             else
					mid = a;
		 }
		 else
				mid = b;	 }
	 else
	 {
		 if (c > b)
		 {
			 if (a > c)
				 mid = c;
			 else
				 mid = a;
		 }
		 else
			 mid = b;      }
   return mid;}","<mb:mutant#9c90a6aa1ded4c37b2f1d9434d87b78282ab1abe> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -9 +9 @@
-				    mid = c;
+				    mid = c++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Mid.c> ."
300,"int main( int a, int b, int c )
{
	 int mid;
     if (a < b)
	 {
		 if (c < b)
		 {
			 if (a <= c)
				    mid = c;
             else
					mid = a;
		 }
		 else
				mid = b;	 }
	 else
	 {
		 if (c > b)
		 {
			 if (a > c)
				 mid = c;
			 else
				 mid = a;
		 }
		 else
			 mid = b;      }
   return mid;}","<mb:mutant#6763adce93d5d0494c67220a82c079e6e9432641> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -8 +8 @@
-			 if (a < c)
+			 if (a <= c)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Mid.c> ."
301,"int main( int a, int b, int c )
{
	 int mid;
     if (a < b)
	 {
		 if (c < b)
		 {
			 if (a < c)
				    mid = c;
             else
					mid = a;
		 }
		 else
				mid = b++;	 }
	 else
	 {
		 if (c > b)
		 {
			 if (a > c)
				 mid = c;
			 else
				 mid = a;
		 }
		 else
			 mid = b;      }
   return mid;}","<mb:mutant#6bda3a2817cf741a4e3bb41fad05b74bef053955> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -14 +14 @@
-				mid = b;	 }
+				mid = b++;	 }
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Mid.c> ."
302,"int main( int a, int b, int c )
{
	 int mid;
     if (a < b)
	 {
		 if (c < b)
		 {
			 if (a < c)
				    mid = c;
             else
					mid = a;
		 }
		 else
				mid = b--;	 }
	 else
	 {
		 if (c > b)
		 {
			 if (a > c)
				 mid = c;
			 else
				 mid = a;
		 }
		 else
			 mid = b;      }
   return mid;}","<mb:mutant#b19430a196e9e84eca54965f1ba198e12258f8b5> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -14 +14 @@
-				mid = b;	 }
+				mid = b--;	 }
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Mid.c> ."
303,"int main( int a, int b, int c )
{
	 int mid;
     if (a < b)
	 {
		 if (c < b)
		 {
			 if (a < c)
				    mid = c;
             else
					mid = a;
		 }
		 else
				mid = b;	 }
	 else
	 {
		 if (c > b)
		 {
			 if (a >= c)
				 mid = c;
			 else
				 mid = a;
		 }
		 else
			 mid = b;      }
   return mid;}","<mb:mutant#5abd0600e74c4b110f12cdd6be45b8df19d304ec> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -19 +19 @@
-			 if (a > c)
+			 if (a >= c)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Mid.c> ."
304,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}",
305,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>=c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#dc0576dc4402b26677766c57dc43f234d3e8a321> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -21 +21 @@
-	if(b>c)
+	if(b>=c)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Triangle.c> ."
306,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b--==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#cc09296013074cdc934fc9e58bab03125925ab77> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -31 +31 @@
-	else if(a==b||b==c)
+	else if(a==b||b--==c)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
307,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=--t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#8ca7462ec61a75fcc7b18c3696764418945e901a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -19 +19 @@
-		c=t;
+		c=--t;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
308,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t++;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#ed6891fd2ec26df6b370ea43a97405b8b0ed1850> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -19 +19 @@
-		c=t;
+		c=t++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
309,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a++;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#b9954e7cdf94276ee97b0429da5cd95240543282> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -17 +17 @@
-		t=a;
+		t=a++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
310,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=abs(t);
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#27196c3b2208058e57bde1ea295cc920d146aa07> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -13 +13 @@
-		b=t;
+		b=abs(t);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Triangle.c> ."
311,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=++a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#a7d0e135491aeee95b8342e17dc4dd07b9b626c1> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -17 +17 @@
-		t=a;
+		t=++a;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
312,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b++;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#d9a793087ae22fea2e49c17724f85f978f1692a0> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -12 +12 @@
-		a=b;
+		a=b++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
313,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=abs(b);
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#38c029b6160238d3d3be54098a59e0edb56f1146> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -18 +18 @@
-		a=b;
+		a=abs(b);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Triangle.c> ."
314,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b--||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#b4c3d97e43abf6748399aff6b1dd87329b54ba01> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -31 +31 @@
-	else if(a==b||b==c)
+	else if(a==b--||b==c)
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
315,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c++)
	    return 2;
	else
	    return 1;
}","<mb:mutant#474da2b02534490d93711ce12b63dadce2ff911e> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -31 +31 @@
-	else if(a==b||b==c)
+	else if(a==b||b==c++)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
316,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=--a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#d43113ad040acb43811d1b987032fd661a346134> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -17 +17 @@
-		t=a;
+		t=--a;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
317,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=abs(c);
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#54a3ce0e45b9d8f5429ad99c9d7448e02b56db4b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -24 +24 @@
-		b=c;
+		b=abs(c);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Triangle.c> ."
318,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t++;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#fa0e70aeb66713093be9ad9ee319c90013eae492> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -25 +25 @@
-		c=t;
+		c=t++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
319,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a++==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#9fdfe1922d080cc5c70fa81b7dadf7b4f6e0a12a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -31 +31 @@
-	else if(a==b||b==c)
+	else if(a++==b||b==c)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
320,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==--c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#9536075add8f2f22006f1174c1b5af1555eb0d60> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -31 +31 @@
-	else if(a==b||b==c)
+	else if(a==b||b==--c)
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
321,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=abs(b);
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#31b0138dc84d84d74c33a257a52460b5c2570a6f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -23 +23 @@
-		t=b;
+		t=abs(b);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Triangle.c> ."
322,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=--c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#ee4bab3a8f635d2a56ddae920e0807b144dcb90d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -24 +24 @@
-		b=c;
+		b=--c;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
323,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a<=b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#457cf8c07b501696485ac53a5133d12ea35eaa4b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -29 +29 @@
-	else if(a==b&&b==c)
+	else if(a<=b&&b==c)
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Triangle.c> ."
324,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a>=b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#7989802492dccefce0e82e0c74c8dd1204d889fc> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -29 +29 @@
-	else if(a==b&&b==c)
+	else if(a>=b&&b==c)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Triangle.c> ."
325,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=++b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#6108d6eaaf536a915e03a8abaa34c159bee055e8> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -23 +23 @@
-		t=b;
+		t=++b;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
326,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t--;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#95ee20186c9369e05b8f14e423b81ed8142456c6> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -25 +25 @@
-		c=t;
+		c=t--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
327,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a++==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#5e61e178d4a282c9baeef7ce5e86e62e602e495d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -29 +29 @@
-	else if(a==b&&b==c)
+	else if(a++==b&&b==c)
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
328,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a--==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#69bb79e31ed1f5fd31a70f2bcf08561641e80a35> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -29 +29 @@
-	else if(a==b&&b==c)
+	else if(a--==b&&b==c)
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
329,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t++;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#9901687aab6fad45994b7141d6aa2d8e8dd2d8f3> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -13 +13 @@
-		b=t;
+		b=t++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
330,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t--;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#dcd93b222fb338f336d5034aa529980a09ee2489> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -19 +19 @@
-		c=t;
+		c=t--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
331,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c++;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#fe8845e3e657ea0494e650295a61bab362565dde> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -24 +24 @@
-		b=c;
+		b=c++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
332,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=++a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#61ef87981b1541ae4d0c1728a23e503fbda5ec34> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -11 +11 @@
-		t=a;
+		t=++a;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
333,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=abs(b);
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#3d3f59c5fc5ef0b541a0d8453655e3c6f6246dec> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -12 +12 @@
-		a=b;
+		a=abs(b);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Triangle.c> ."
334,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=--t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#632de94158f1bdccdf72eebd1d075487443933fd> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -25 +25 @@
-		c=t;
+		c=--t;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
335,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b++==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#ff1c3f02c5b0a8ffcdcd169f62f2857b2465743f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -31 +31 @@
-	else if(a==b||b==c)
+	else if(a==b||b++==c)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
336,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=++t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#646b3d099601f4556db593f0b462aa93114d2368> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -13 +13 @@
-		b=t;
+		b=++t;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
337,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c--)
	    return 2;
	else
	    return 1;
}","<mb:mutant#7e0e2d0ad9a6b1ac17fce853e3090048e842459a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -31 +31 @@
-	else if(a==b||b==c)
+	else if(a==b||b==c--)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
338,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b++;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#2bbce27f03f66a898980e581181fcf833678d0d8> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -23 +23 @@
-		t=b;
+		t=b++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
339,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=++c;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#0ff840ef078fbdfe6d1b6012e90ae93059ce6b14> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -18 +18 @@
-		a=b;
+		a=++c;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
340,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=--t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#18fac70f5b39cf847155e40577dd7793a405e9ab> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -13 +13 @@
-		b=t;
+		b=--t;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
341,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b--;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#baf09fd4032f7e64e08bc28c6a8e3b0715f28afd> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -23 +23 @@
-		t=b;
+		t=b--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
342,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#466089ab80ad75bb0a4b5a69617fe45d0e741d7f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -27 +27 @@
-	if(a+b<=c)
+	if(a+b<c)
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Triangle.c> ."
343,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b++;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#ad48f4c2b997715face8d1378e49d75a135e6a47> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -18 +18 @@
-		a=b;
+		a=b++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
344,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=--a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#23051c131888edbe3b700bff4e070cf080e2e9b0> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -11 +11 @@
-		t=a;
+		t=--a;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
345,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=++c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#3d9d317c025afdad3e1dc4b97f35d7a70697d901> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -24 +24 @@
-		b=c;
+		b=++c;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
346,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||++b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#68474ec21d708749ccd000e91731cdfd6f2699ef> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -31 +31 @@
-	else if(a==b||b==c)
+	else if(a==b||++b==c)
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
347,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=--c;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#6656dd193101a10b4df90952bb1399c77cea1e38> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -18 +18 @@
-		a=b;
+		a=--c;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
348,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=abs(t);
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#c7a76b9f23e6a48f67717037e396f788ab443afa> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -19 +19 @@
-		c=t;
+		c=abs(t);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Triangle.c> ."
349,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=++t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#bb798fb9f75c0c944751190413a044e140c9817f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -19 +19 @@
-		c=t;
+		c=++t;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
350,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>=b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#52ca139a9303d941a79de23b0c83d6dacdfdc130> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -9 +9 @@
-	if(a>b)
+	if(a>=b)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Triangle.c> ."
351,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==++c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#6b30bc5695c84e3f1e64b0b85ae2134e3ab0d804> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -31 +31 @@
-	else if(a==b||b==c)
+	else if(a==b||b==++c)
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
352,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c--;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#9e767add9f0e6d219a2fcdcc924b8da17e48d93a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -24 +24 @@
-		b=c;
+		b=c--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
353,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=--b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#8d6892041d1b24b999d97f4495b067ea5d591e16> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -23 +23 @@
-		t=b;
+		t=--b;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
354,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b--;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#fb0d132117cbb2823ef829a5e55cfe959d93f034> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -18 +18 @@
-		a=b;
+		a=b--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
355,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b++||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#3073f008e2bd982057f47785648d8282e67ea403> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -31 +31 @@
-	else if(a==b||b==c)
+	else if(a==b++||b==c)
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
356,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b>=c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#d46b6292968c7100e584afcc17caf33ee0d4032e> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -31 +31 @@
-	else if(a==b||b==c)
+	else if(a==b||b>=c)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Triangle.c> ."
357,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||--b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#b199d0e3a4b1bc32afc717ce18f81495779585ed> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -31 +31 @@
-	else if(a==b||b==c)
+	else if(a==b||--b==c)
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
358,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b>c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#1be8bc00308bf986afa7fe7dcfc4045b79b00f41> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -29 +29 @@
-	else if(a==b&&b==c)
+	else if(a==b&&b>c)
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Triangle.c> ."
359,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=abs(t);
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#312a9fad6fd1a8cda74777f26e42d0e4e661b44b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -25 +25 @@
-		c=t;
+		c=abs(t);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Triangle.c> ."
360,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=--b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#ac6d329518f43baa01707490dbc12d8cfd840fd6> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -12 +12 @@
-		a=b;
+		a=--b;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
361,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=abs(a);
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#a6dd154502acae1c4aaa7f4efc4b203a127039c4> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -11 +11 @@
-		t=a;
+		t=abs(a);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Triangle.c> ."
362,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a--;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#9273b7e7265d2ae386b101c97b732ea0698b306d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -11 +11 @@
-		t=a;
+		t=a--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
363,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a>=b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#deeb7e2d83aa468e7bf3b83dd7acccc93795fad8> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -31 +31 @@
-	else if(a==b||b==c)
+	else if(a>=b||b==c)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Triangle.c> ."
364,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a--;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#6f1f387693eed3f49feeabcad7e86a244addc3b0> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -17 +17 @@
-		t=a;
+		t=a--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
365,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=++t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#edaee2f8f0d770b5e4a1ce49d1535bf0b182481e> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -25 +25 @@
-		c=t;
+		c=++t;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
366,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>=c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#ca66310501bd1ddb8bc3d3d8187133fd7150b52c> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -15 +15 @@
-	if(a>c)
+	if(a>=c)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Triangle.c> ."
367,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a++;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#e9e657102db3d0ceda72f6d99904b318a7703fff> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -11 +11 @@
-		t=a;
+		t=a++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
368,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b>=c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#6d34aa16a6ccb2dabc6a02464217d4546e502b8b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -29 +29 @@
-	else if(a==b&&b==c)
+	else if(a==b&&b>=c)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Triangle.c> ."
369,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b--;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#fe1b80be371591433e0ba5676e3029fcc4c676e5> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -12 +12 @@
-		a=b;
+		a=b--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
370,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=++b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#36987e1852a14ffa693313e8ed85cedc8b38b263> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -12 +12 @@
-		a=b;
+		a=++b;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
371,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t--;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#a40c1bf3e58f41eacf09c9b74132230adc04e4e7> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -13 +13 @@
-		b=t;
+		b=t--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
372,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=abs(a);
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#b96105b6ffa087dc9222a3569f43086111e26759> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -17 +17 @@
-		t=a;
+		t=abs(a);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Triangle.c> ."
373,"int main(a, b, c)
unsigned int a;
unsigned int b;
unsigned int c;
{	
	int t;
	if(a>b)
	{
		t=a;
		a=b;
		b=t;
	}
	if(a>c)
	{
		t=a;
		a=b;
		c=t;
	}  
	if(b>c)
	{
		t=b;
		b=c;
		c=t;
	}
	if(a+b<=c)
	    return 0;
	else if(a==b&&b==c)
	    return 3;
	else if(a--==b||b==c)
	    return 2;
	else
	    return 1;
}","<mb:mutant#d24104c930c71f8ada3cddc44531fc02d9e13b69> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -31 +31 @@
-	else if(a==b||b==c)
+	else if(a--==b||b==c)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Triangle.c> ."
374,"int hashmap_put(map_t in, char* key, any_t value){
	int index;
	hashmap_map* m;
	m = (hashmap_map *) in;
	index = hashmap_hash(in, key);
	while(index == MAP_FULL){
		if (hashmap_rehash(in) == MAP_OMEM) {
			return MAP_OMEM;
		}
		index = hashmap_hash(in, key);
	}
	m->data[index].data = value;
	m->data[index].key = key;
	m->data[index].in_use = 1;
	m->size++; 
	return MAP_OK;
}",
375,"int hashmap_put(map_t in, char* key, any_t value){
	int index;
	hashmap_map* m;
	m = (hashmap_map *) in;
	index = hashmap_hash(abs(in), key);
	while(index == MAP_FULL){
		if (hashmap_rehash(in) == MAP_OMEM) {
			return MAP_OMEM;
		}
		index = hashmap_hash(in, key);
	}
	m->data[index].data = value;
	m->data[index].key = key;
	m->data[index].in_use = 1;
	m->size++; 
	return MAP_OK;
}","<mb:mutant#af492efda5958599938fa0aca4a95c3116506c42> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -327 +321 @@
-	index = hashmap_hash(in, key);
+	index = hashmap_hash(abs(in), key);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Hashmap.c> ."
376,"int hashmap_hash(map_t in, char* key){
	int curr;
	int i;
	hashmap_map* m = (hashmap_map *) in;
	if(m->size >= (m->table_size/2)) return MAP_FULL;
	curr = hashmap_hash_int(m, key);
	for(i = 0; i< MAX_CHAIN_LENGTH; i++){
		if(m->data[curr].in_use == 0)
			return curr;
		if(m->data[curr].in_use == 1 && (strcmp(m->data[curr].key,key)==0))
			return curr;
		curr = (curr + 1) % m->table_size;
	}
	return MAP_FULL;
}",
377,"int hashmap_hash(map_t in, char* key){
	int curr;
	int i;
	hashmap_map* m = (hashmap_map *) in;
	if(m->size >= (m->table_size/2)) return MAP_FULL;
	curr = hashmap_hash_int(m, key);
	for(i = 0; i< MAX_CHAIN_LENGTH; i++){
		if(m->data[curr].in_use == 0)
			return curr;
		if(m->data[curr].in_use == 1 && (strcmp(m->data[curr].key,key)==0))
			return abs(curr);
		curr = (curr + 1) % m->table_size;
	}
	return MAP_FULL;
}","<mb:mutant#4aa8164197e7f5b64b46e0249e7fe08cd6e139cf> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -266 +262 @@
-			return curr;
+			return abs(curr);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Hashmap.c> ."
378,"int hashmap_get(map_t in, char* key, any_t *arg){
	int curr;
	int i;
	hashmap_map* m;
	m = (hashmap_map *) in;
	curr = hashmap_hash_int(m, key);
	for(i = 0; i<MAX_CHAIN_LENGTH; i++){
        int in_use = m->data[curr].in_use;
        if (in_use == 1){
            if (strcmp(m->data[curr].key,key)==0){
                *arg = (m->data[curr].data);
                return MAP_OK;
            }
		}
		curr = (curr + 1) % m->table_size;
	}
	*arg = NULL;
	return MAP_MISSING;
}",
379,"int hashmap_get(map_t in, char* key, any_t *arg){
	int curr;
	int i;
	hashmap_map* m;
	m = (hashmap_map *) in;
	curr = hashmap_hash_int(m, key);
	for(i = 0; i<MAX_CHAIN_LENGTH; i++){
        int in_use = m->data[curr].in_use;
        if (in_use-- == 1){
            if (strcmp(m->data[curr].key,key)==0){
                *arg = (m->data[curr].data);
                return MAP_OK;
            }
		}
		curr = (curr + 1) % m->table_size;
	}
	*arg = NULL;
	return MAP_MISSING;
}","<mb:mutant#9dfdc807f8c69be2227468760d015fa643c5e9e8> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -362 +362 @@
-        if (in_use == 1){
+        if (in_use-- == 1){
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Hashmap.c> ."
380,"int hashmap_rehash(map_t in){
	int i;
	int old_size;
	hashmap_element* curr;
	hashmap_map *m = (hashmap_map *) in;
	hashmap_element* temp = (hashmap_element *)
		calloc(2 * m->table_size, sizeof(hashmap_element));
	if(!temp) return MAP_OMEM;
	curr = m->data;
	m->data = temp;
	old_size = m->table_size;
	m->table_size = 2 * m->table_size;
	m->size = 0;
	for(i = 0; i < old_size; i++)
	{
        int status;
        if (curr[i].in_use == 0)
            continue;
		status = hashmap_put(m, curr[i].key, curr[i].data);
		if (status != MAP_OK)
			return status;
	}
	free(curr);
	return MAP_OK;
}",
381,"int hashmap_rehash(map_t in){
	int i;
	int old_size;
	hashmap_element* curr;
	hashmap_map *m = (hashmap_map *) in;
	hashmap_element* temp = (hashmap_element *)
		calloc(2 * m->table_size, sizeof(hashmap_element));
	if(!temp) return MAP_OMEM;
	curr = m->data;
	m->data = temp;
	old_size = m->table_size;
	m->table_size = 2 * m->table_size;
	m->size = 0;
	for(i = 0; i < old_size; i++)
	{
        int status;
        if (curr[i].in_use == 0)
            continue;
		status = hashmap_put(m, curr[i].key, curr[i].data);
		if (status != MAP_OK)
			return status++;
	}
	free(curr);
	return MAP_OK;
}","<mb:mutant#cfeed7199d6beb7d155f764255292b6305264f1a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -308 +308 @@
-			return status;
+			return status++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Hashmap.c> ."
382,"unsigned long crc32(const unsigned char *s, unsigned int len)
{
  unsigned int i;
  unsigned long crc32val;
  crc32val = 0;
  for (i = 0;  i < len;  i ++)
    {
	  crc32val =crc32_tab[(crc32val ^ s[i]) & 0xff] ^  (crc32val >> 8);
	}   
  return crc32val; 
}",
383,"unsigned long crc32(const unsigned char *s, unsigned int len)
{
  unsigned int i;
  unsigned long crc32val;
  crc32val = 0;
  for (i = 0;  i < len;  i ++)
    {
	  crc32val =crc32_tab[(crc32val ^ s[i]) & 0xff] ^  (crc32val >> 8);
	}   
  return crc32val++;
}","<mb:mutant#f9b350812926a656b67c1428d240d286795b722f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -213 +213 @@
-  return crc32val;
+  return crc32val++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Hashmap.c> ."
384,"map_t hashmap_new() {
	hashmap_map  *m = (hashmap_map*) malloc(sizeof(hashmap_map));
	if(!m) goto err;
	m->data = (hashmap_element*) calloc(INITIAL_SIZE, sizeof(hashmap_element));
	if(!m->data) goto err;
	m->table_size = INITIAL_SIZE;
	m->size = 0;
	return m;
	err:
		if (m)
			hashmap_free(m);
		return NULL;
}",
385,"map_t hashmap_new() {
	hashmap_map  *m = (hashmap_map*) malloc(sizeof(hashmap_map));
	if(!m) goto err;
	m->data = (hashmap_element*) calloc(INITIAL_SIZE, sizeof(hashmap_element));
	if(!m->data) goto err;
	m->table_size = INITIAL_SIZE;
	m->size = 0;
	return m;
	err:
		if (m)
			hashmap_free(abs(m));
		return NULL;
}","<mb:mutant#7a69140d3d82886ec54077a407bddd1d51f7f572> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -196 +196 @@
-			hashmap_free(m);
+			hashmap_free(abs(m));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Hashmap.c> ."
386,"int hashmap_hash(map_t in, char* key){
	int curr;
	int i;
	hashmap_map* m = (hashmap_map *) in;
	if(m->size >= (m->table_size/2)) return MAP_FULL;
	curr = hashmap_hash_int(m, abs(key));
	for(i = 0; i< MAX_CHAIN_LENGTH; i++){
		if(m->data[curr].in_use == 0)
			return curr;
		if(m->data[curr].in_use == 1 && (strcmp(m->data[curr].key,key)==0))
			return curr;
		curr = (curr + 1) % m->table_size;
	}
	return MAP_FULL;
}","<mb:mutant#cb72b3c4b5415431e3a2a6c68596d58b4b648837> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -258 +254 @@
-	curr = hashmap_hash_int(m, key);
+	curr = hashmap_hash_int(m, abs(key));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Hashmap.c> ."
387,"int hashmap_hash(map_t in, char* key){
	int curr;
	int i;
	hashmap_map* m = (hashmap_map *) in;
	if(m->size >= (m->table_size/2)) return MAP_FULL;
	curr = hashmap_hash_int(m, key);
	for(i = 0; i< MAX_CHAIN_LENGTH; i++){
		if(m->data[curr].in_use == 0)
			return curr++;
		if(m->data[curr].in_use == 1 && (strcmp(m->data[curr].key,key)==0))
			return curr;
		curr = (curr + 1) % m->table_size;
	}
	return MAP_FULL;
}","<mb:mutant#5801d9f3f7498e24c3a8f7304d884b305c7c8305> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -263 +263 @@
-			return curr;
+			return curr++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Hashmap.c> ."
388,"int hashmap_get(map_t in, char* key, any_t *arg){
	int curr;
	int i;
	hashmap_map* m;
	m = (hashmap_map *) in;
	curr = hashmap_hash_int(m, key);
	for(i = 0; i<MAX_CHAIN_LENGTH; i++){
        int in_use = m->data[curr].in_use--;
        if (in_use == 1){
            if (strcmp(m->data[curr].key,key)==0){
                *arg = (m->data[curr].data);
                return MAP_OK;
            }
		}
		curr = (curr + 1) % m->table_size;
	}
	*arg = NULL;
	return MAP_MISSING;
}","<mb:mutant#a016bef6d0ea493b7d530077cf52d4aa78a87b44> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -361 +361 @@
-        int in_use = m->data[curr].in_use;
+        int in_use = m->data[curr].in_use--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Hashmap.c> ."
389,"int hashmap_hash(map_t in, char* key){
	int curr;
	int i;
	hashmap_map* m = (hashmap_map *) in;
	if(m->size >= (m->table_size/2)) return MAP_FULL;
	curr = hashmap_hash_int(m, key);
	for(i = 0; i< MAX_CHAIN_LENGTH; i++){
		if(m->data[curr].in_use == 0)
			return curr;
		if(m->data[curr].in_use >= 1 && (strcmp(m->data[curr].key,key)==0))
			return curr;
		curr = (curr + 1) % m->table_size;
	}
	return MAP_FULL;
}","<mb:mutant#adcd17bb1f369d0ed7c74079d34f8676144ced8b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -265 +265 @@
-		if(m->data[curr].in_use == 1 && (strcmp(m->data[curr].key,key)==0))
+		if(m->data[curr].in_use >= 1 && (strcmp(m->data[curr].key,key)==0))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Hashmap.c> ."
390,"int hashmap_get(map_t in, char* key, any_t *arg){
	int curr;
	int i;
	hashmap_map* m;
	m = (hashmap_map *) in;
	curr = hashmap_hash_int(abs(m), key);
	for(i = 0; i<MAX_CHAIN_LENGTH; i++){
        int in_use = m->data[curr].in_use;
        if (in_use == 1){
            if (strcmp(m->data[curr].key,key)==0){
                *arg = (m->data[curr].data);
                return MAP_OK;
            }
		}
		curr = (curr + 1) % m->table_size;
	}
	*arg = NULL;
	return MAP_MISSING;
}","<mb:mutant#0aa84951935b2cf0ca7f9bd52673a759d6b5c929> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -356 +350 @@
-	curr = hashmap_hash_int(m, key);
+	curr = hashmap_hash_int(abs(m), key);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Hashmap.c> ."
391,"int hashmap_rehash(map_t in){
	int i;
	int old_size;
	hashmap_element* curr;
	hashmap_map *m = (hashmap_map *) in;
	hashmap_element* temp = (hashmap_element *)
		calloc(2 * m->table_size, sizeof(hashmap_element));
	if(!temp) return MAP_OMEM;
	curr = m->data;
	m->data = abs(temp);
	old_size = m->table_size;
	m->table_size = 2 * m->table_size;
	m->size = 0;
	for(i = 0; i < old_size; i++)
	{
        int status;
        if (curr[i].in_use == 0)
            continue;
		status = hashmap_put(m, curr[i].key, curr[i].data);
		if (status != MAP_OK)
			return status;
	}
	free(curr);
	return MAP_OK;
}","<mb:mutant#820854aaaaf35d05604d8a1942519a095f26c925> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -292 +286 @@
-	m->data = temp;
+	m->data = abs(temp);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Hashmap.c> ."
392,"int hashmap_get(map_t in, char* key, any_t *arg){
	int curr;
	int i;
	hashmap_map* m;
	m = (hashmap_map *) in;
	curr = hashmap_hash_int(m, key);
	for(i = 0; i<MAX_CHAIN_LENGTH; i++){
        int in_use = m->data[curr].in_use;
        if (in_use++ == 1){
            if (strcmp(m->data[curr].key,key)==0){
                *arg = (m->data[curr].data);
                return MAP_OK;
            }
		}
		curr = (curr + 1) % m->table_size;
	}
	*arg = NULL;
	return MAP_MISSING;
}","<mb:mutant#67ea2b5244bda2d54ebfa7f8b70237e6401cc4c4> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -362 +362 @@
-        if (in_use == 1){
+        if (in_use++ == 1){
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Hashmap.c> ."
393,"int hashmap_remove(map_t in, char* key){
	int i;
	int curr;
	hashmap_map* m;
	m = (hashmap_map *) in;
	curr = hashmap_hash_int(m, key);
	for(i = 0; i<MAX_CHAIN_LENGTH; i++){
        int in_use = m->data[curr].in_use;
        if (in_use == 1){
            if (strcmp(m->data[curr].key,key)==0){
                m->data[curr].in_use = 0;
                m->data[curr].data = NULL;
                m->data[curr].key = NULL;
                m->size--;
                return MAP_OK;
            }
		}
		curr = (curr + 1) % m->table_size;
	}
	return MAP_MISSING;
}",
394,"int hashmap_remove(map_t in, char* key){
	int i;
	int curr;
	hashmap_map* m;
	m = (hashmap_map *) in;
	curr = hashmap_hash_int(abs(m), key);
	for(i = 0; i<MAX_CHAIN_LENGTH; i++){
        int in_use = m->data[curr].in_use;
        if (in_use == 1){
            if (strcmp(m->data[curr].key,key)==0){
                m->data[curr].in_use = 0;
                m->data[curr].data = NULL;
                m->data[curr].key = NULL;
                m->size--;
                return MAP_OK;
            }
		}
		curr = (curr + 1) % m->table_size;
	}
	return MAP_MISSING;
}","<mb:mutant#5f4d9c393a48f0418ed4013903de07673a90a351> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -418 +412 @@
-	curr = hashmap_hash_int(m, key);
+	curr = hashmap_hash_int(abs(m), key);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Hashmap.c> ."
395,"int hashmap_put(map_t in, char* key, any_t value){
	int index;
	hashmap_map* m;
	m = (hashmap_map *) in;
	index = hashmap_hash(in, key);
	while(index == MAP_FULL){
		if (hashmap_rehash(in) == MAP_OMEM) {
			return MAP_OMEM;
		}
		index = hashmap_hash(abs(in), key);
	}
	m->data[index].data = value;
	m->data[index].key = key;
	m->data[index].in_use = 1;
	m->size++; 
	return MAP_OK;
}","<mb:mutant#fb2e17d2b80786b955f4892040d5c5e3cab50f45> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -332 +326 @@
-		index = hashmap_hash(in, key);
+		index = hashmap_hash(abs(in), key);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Hashmap.c> ."
396,"unsigned long crc32(const unsigned char *s, unsigned int len)
{
  unsigned int i;
  unsigned long crc32val;
  crc32val = 0;
  for (i = 0;  i < len;  i ++)
    {
	  crc32val =crc32_tab[(crc32val ^ s[i]) & abs(0xff)] ^  (crc32val >> 8);
	}   
  return crc32val; 
}","<mb:mutant#dd4a0a30fa1bf9a25d1ed08e4463eb495e001931> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -211 +211 @@
-	  crc32val =crc32_tab[(crc32val ^ s[i]) & 0xff] ^  (crc32val >> 8);
+	  crc32val =crc32_tab[(crc32val ^ s[i]) & abs(0xff)] ^  (crc32val >> 8);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Hashmap.c> ."
397,"int hashmap_put(map_t in, char* key, any_t value){
	int index;
	hashmap_map* m;
	m = (hashmap_map *) in;
	index = hashmap_hash(in, key);
	while(index == MAP_FULL){
		if (hashmap_rehash(in) == MAP_OMEM) {
			return MAP_OMEM;
		}
		index = hashmap_hash(in, abs(key));
	}
	m->data[index].data = value;
	m->data[index].key = key;
	m->data[index].in_use = 1;
	m->size++; 
	return MAP_OK;
}","<mb:mutant#2d04ab5e7f5a62881f8d6cd2e7f7dce73a2917a1> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -332 +326 @@
-		index = hashmap_hash(in, key);
+		index = hashmap_hash(in, abs(key));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Hashmap.c> ."
398,"int hashmap_put(map_t in, char* key, any_t value){
	int index;
	hashmap_map* m;
	m = (hashmap_map *) in;
	index = hashmap_hash(in, key);
	while(index == MAP_FULL){
		if (hashmap_rehash(in) == MAP_OMEM) {
			return MAP_OMEM;
		}
		index = hashmap_hash(in, key);
	}
	m->data[index].data = value;
	m->data[index].key = abs(key);
	m->data[index].in_use = 1;
	m->size++; 
	return MAP_OK;
}","<mb:mutant#ae4d0538405322574b53caa1bd2b407a1f54e974> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -337 +331 @@
-	m->data[index].key = key;
+	m->data[index].key = abs(key);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Hashmap.c> ."
399,"int hashmap_get(map_t in, char* key, any_t *arg){
	int curr;
	int i;
	hashmap_map* m;
	m = (hashmap_map *) in;
	curr = hashmap_hash_int(m, abs(key));
	for(i = 0; i<MAX_CHAIN_LENGTH; i++){
        int in_use = m->data[curr].in_use;
        if (in_use == 1){
            if (strcmp(m->data[curr].key,key)==0){
                *arg = (m->data[curr].data);
                return MAP_OK;
            }
		}
		curr = (curr + 1) % m->table_size;
	}
	*arg = NULL;
	return MAP_MISSING;
}","<mb:mutant#a8bbc81f19af7277498d012f14b412ce6ee22083> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -356 +350 @@
-	curr = hashmap_hash_int(m, key);
+	curr = hashmap_hash_int(m, abs(key));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Hashmap.c> ."
400,"int hashmap_hash(map_t in, char* key){
	int curr;
	int i;
	hashmap_map* m = (hashmap_map *) in;
	if(m->size >= (m->table_size/2)) return MAP_FULL;
	curr = hashmap_hash_int(abs(m), key);
	for(i = 0; i< MAX_CHAIN_LENGTH; i++){
		if(m->data[curr].in_use == 0)
			return curr;
		if(m->data[curr].in_use == 1 && (strcmp(m->data[curr].key,key)==0))
			return curr;
		curr = (curr + 1) % m->table_size;
	}
	return MAP_FULL;
}","<mb:mutant#c374527024798e00c189b344f86d9b790a8c990f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -258 +254 @@
-	curr = hashmap_hash_int(m, key);
+	curr = hashmap_hash_int(abs(m), key);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Hashmap.c> ."
401,"unsigned long crc32(const unsigned char *s, unsigned int len)
{
  unsigned int i;
  unsigned long crc32val;
  crc32val = 0;
  for (i = 0;  i < len;  i ++)
    {
	  crc32val =crc32_tab[(crc32val ^ s[i]) & 0xff] ^  (abs(crc32val) >> 8);
	}   
  return crc32val; 
}","<mb:mutant#df7e9fab037fbce9319351a0bb7f85b5f217ef3b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -211 +211 @@
-	  crc32val =crc32_tab[(crc32val ^ s[i]) & 0xff] ^  (crc32val >> 8);
+	  crc32val =crc32_tab[(crc32val ^ s[i]) & 0xff] ^  (abs(crc32val) >> 8);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Hashmap.c> ."
402,"int hashmap_get(map_t in, char* key, any_t *arg){
	int curr;
	int i;
	hashmap_map* m;
	m = (hashmap_map *) in;
	curr = hashmap_hash_int(m, key);
	for(i = 0; i<MAX_CHAIN_LENGTH; i++){
        int in_use = m->data[curr].in_use++;
        if (in_use == 1){
            if (strcmp(m->data[curr].key,key)==0){
                *arg = (m->data[curr].data);
                return MAP_OK;
            }
		}
		curr = (curr + 1) % m->table_size;
	}
	*arg = NULL;
	return MAP_MISSING;
}","<mb:mutant#b06c7914fb2c9da8009b869389aad6913117f3ac> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -361 +361 @@
-        int in_use = m->data[curr].in_use;
+        int in_use = m->data[curr].in_use++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Hashmap.c> ."
403,"unsigned int hashmap_hash_int(hashmap_map * m, char* keystring){
    unsigned long key = crc32((unsigned char*)(keystring), strlen(keystring));
	key += (key << 12);
	key ^= (key >> 22);
	key += (key << 4);
	key ^= (key >> 9);
	key += (key << 10);
	key ^= (key >> 2);
	key += (key << 7);
	key ^= (key >> 12);
	key = (key >> 3) * 2654435761;
	return key % m->table_size;
}",
404,"unsigned int hashmap_hash_int(hashmap_map * m, char* keystring){
    unsigned long key = crc32((unsigned char*)(keystring), strlen(keystring));
	key += (key << 12);
	key ^= (key >> 22);
	key += (key << 4);
	key ^= (key >> 9);
	key += (key << 10);
	key ^= (key >> 2);
	key += (key << 7);
	key ^= (key >> 12);
	key = (key >> 3) * 2654435761;
	return key % m->table_size++;
}","<mb:mutant#816490bbe0d4429af581d5a2616b04eaccbc4029> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -238 +238 @@
-	return key % m->table_size;
+	return key % m->table_size++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Hashmap.c> ."
405,"int hashmap_get(map_t in, char* key, any_t *arg){
	int curr;
	int i;
	hashmap_map* m;
	m = (hashmap_map *) in;
	curr = hashmap_hash_int(m, key);
	for(i = 0; i<MAX_CHAIN_LENGTH; i++){
        int in_use = m->data[curr].in_use;
        if (in_use == 1){
            if (strcmp(m->data[curr].key,key--)==0){
                *arg = (m->data[curr].data);
                return MAP_OK;
            }
		}
		curr = (curr + 1) % m->table_size;
	}
	*arg = NULL;
	return MAP_MISSING;
}","<mb:mutant#d860f788e9855fdd7813d5bebd451d87bd155d7e> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -363 +363 @@
-            if (strcmp(m->data[curr].key,key)==0){
+            if (strcmp(m->data[curr].key,key--)==0){
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Hashmap.c> ."
406,"unsigned int hashmap_hash_int(hashmap_map * m, char* keystring){
    unsigned long key = crc32((unsigned char*)(keystring), strlen(keystring));
	key += (key << 12);
	key ^= (key >> 22);
	key += (key << 4);
	key ^= (key >> 9);
	key += (key << 10);
	key ^= (key >> 2);
	key += (key << 7);
	key ^= (key >> 12);
	key = (key >> 3) * 2654435761;
	return key % m->table_size--;
}","<mb:mutant#c1c4673727812887aa609684018ab46c7663ac6f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -238 +238 @@
-	return key % m->table_size;
+	return key % m->table_size--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Hashmap.c> ."
407,"int hashmap_hash(map_t in, char* key){
	int curr;
	int i;
	hashmap_map* m = (hashmap_map *) in;
	if(m->size >= (m->table_size/2)) return MAP_FULL;
	curr = hashmap_hash_int(m, key);
	for(i = 0; i< MAX_CHAIN_LENGTH; i++){
		if(m->data[curr].in_use == 0)
			return curr;
		if(m->data[curr].in_use == 1 && (strcmp(m->data[curr].key,key)==0))
			return curr++;
		curr = (curr + 1) % m->table_size;
	}
	return MAP_FULL;
}","<mb:mutant#8a908ef6104941b6e755ee629b52d0d59a1b69c3> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -266 +266 @@
-			return curr;
+			return curr++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Hashmap.c> ."
408,"int hashmap_remove(map_t in, char* key){
	int i;
	int curr;
	hashmap_map* m;
	m = (hashmap_map *) in;
	curr = hashmap_hash_int(m, abs(key));
	for(i = 0; i<MAX_CHAIN_LENGTH; i++){
        int in_use = m->data[curr].in_use;
        if (in_use == 1){
            if (strcmp(m->data[curr].key,key)==0){
                m->data[curr].in_use = 0;
                m->data[curr].data = NULL;
                m->data[curr].key = NULL;
                m->size--;
                return MAP_OK;
            }
		}
		curr = (curr + 1) % m->table_size;
	}
	return MAP_MISSING;
}","<mb:mutant#c77dc1a82f680e6ba1dab2bdf3c945feacedb114> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -418 +412 @@
-	curr = hashmap_hash_int(m, key);
+	curr = hashmap_hash_int(m, abs(key));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Hashmap.c> ."
409,"int hashmap_rehash(map_t in){
	int i;
	int old_size;
	hashmap_element* curr;
	hashmap_map *m = (hashmap_map *) in;
	hashmap_element* temp = (hashmap_element *)
		calloc(2 * m->table_size, sizeof(hashmap_element));
	if(!temp) return MAP_OMEM;
	curr = m->data;
	m->data = temp;
	old_size = m->table_size;
	m->table_size = 2 * m->table_size;
	m->size = 0;
	for(i = 0; i < old_size; i++)
	{
        int status;
        if (curr[i].in_use == 0)
            continue;
		status = hashmap_put(m, curr[i].key, curr[i].data);
		if (status != MAP_OK)
			return status--;
	}
	free(curr);
	return MAP_OK;
}","<mb:mutant#d6942f8c79aa9027edc3f145e8525e01cc1c7450> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -308 +308 @@
-			return status;
+			return status--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Hashmap.c> ."
410,"int hashmap_rehash(map_t in){
	int i;
	int old_size;
	hashmap_element* curr;
	hashmap_map *m = (hashmap_map *) in;
	hashmap_element* temp = (hashmap_element *)
		calloc(2 * m->table_size, sizeof(hashmap_element));
	if(!temp) return MAP_OMEM;
	curr = m->data;
	m->data = temp;
	old_size = m->table_size;
	m->table_size = 2 * m->table_size;
	m->size = 0;
	for(i = 0; i < old_size; i++)
	{
        int status;
        if (curr[i].in_use-- == 0)
            continue;
		status = hashmap_put(m, curr[i].key, curr[i].data);
		if (status != MAP_OK)
			return status;
	}
	free(curr);
	return MAP_OK;
}","<mb:mutant#83a84e0c44e6a46fba3a9f9a3fdcc93a4e7f7bea> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -303 +303 @@
-        if (curr[i].in_use == 0)
+        if (curr[i].in_use-- == 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Hashmap.c> ."
411,"int hashmap_get(map_t in, char* key, any_t *arg){
	int curr;
	int i;
	hashmap_map* m;
	m = (hashmap_map *) in;
	curr = hashmap_hash_int(m, key);
	for(i = 0; i<MAX_CHAIN_LENGTH; i++){
        int in_use = m->data[curr].in_use;
        if (in_use == 1){
            if (strcmp(m->data[curr].key++,key)==0){
                *arg = (m->data[curr].data);
                return MAP_OK;
            }
		}
		curr = (curr + 1) % m->table_size;
	}
	*arg = NULL;
	return MAP_MISSING;
}","<mb:mutant#c6d486099117d11339949fbce28ebb14478fc9c3> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -363 +363 @@
-            if (strcmp(m->data[curr].key,key)==0){
+            if (strcmp(m->data[curr].key++,key)==0){
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Hashmap.c> ."
412,"int hashmap_rehash(map_t in){
	int i;
	int old_size;
	hashmap_element* curr;
	hashmap_map *m = (hashmap_map *) in;
	hashmap_element* temp = (hashmap_element *)
		calloc(2 * m->table_size, sizeof(hashmap_element));
	if(!temp) return MAP_OMEM;
	curr = m->data;
	m->data = temp;
	old_size = m->table_size;
	m->table_size = 2 * m->table_size;
	m->size = 0;
	for(i = 0; i < old_size; i++)
	{
        int status;
        if (curr[i].in_use == 0)
            continue;
		status = hashmap_put(m, curr[i].key--, curr[i].data);
		if (status != MAP_OK)
			return status;
	}
	free(curr);
	return MAP_OK;
}","<mb:mutant#7d25216a17fd97ab918f20cc30194003dbcfb600> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -306 +306 @@
-		status = hashmap_put(m, curr[i].key, curr[i].data);
+		status = hashmap_put(m, curr[i].key--, curr[i].data);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Hashmap.c> ."
413,"int hashmap_hash(map_t in, char* key){
	int curr;
	int i;
	hashmap_map* m = (hashmap_map *) in;
	if(m->size >= (m->table_size/2)) return MAP_FULL;
	curr = hashmap_hash_int(m, key);
	for(i = 0; i< MAX_CHAIN_LENGTH; i++){
		if(m->data[curr].in_use == 0)
			return curr--;
		if(m->data[curr].in_use == 1 && (strcmp(m->data[curr].key,key)==0))
			return curr;
		curr = (curr + 1) % m->table_size;
	}
	return MAP_FULL;
}","<mb:mutant#05d244df79762bf7e4dfd3977dd18d8de262e6c6> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -263 +263 @@
-			return curr;
+			return curr--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Hashmap.c> ."
414,"int hashmap_put(map_t in, char* key, any_t value){
	int index;
	hashmap_map* m;
	m = (hashmap_map *) in;
	index = hashmap_hash(in, abs(key));
	while(index == MAP_FULL){
		if (hashmap_rehash(in) == MAP_OMEM) {
			return MAP_OMEM;
		}
		index = hashmap_hash(in, key);
	}
	m->data[index].data = value;
	m->data[index].key = key;
	m->data[index].in_use = 1;
	m->size++; 
	return MAP_OK;
}","<mb:mutant#906791447158afeb92dbfc290536d324b242ecea> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -327 +321 @@
-	index = hashmap_hash(in, key);
+	index = hashmap_hash(in, abs(key));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Hashmap.c> ."
415,"int hashmap_rehash(map_t in){
	int i;
	int old_size;
	hashmap_element* curr;
	hashmap_map *m = (hashmap_map *) in;
	hashmap_element* temp = (hashmap_element *)
		calloc(2 * m->table_size, sizeof(hashmap_element));
	if(!temp) return MAP_OMEM;
	curr = m->data;
	m->data = temp;
	old_size = m->table_size;
	m->table_size = 2 * m->table_size;
	m->size = 0;
	for(i = 0; i < old_size; i++)
	{
        int status;
        if (curr[i].in_use++ == 0)
            continue;
		status = hashmap_put(m, curr[i].key, curr[i].data);
		if (status != MAP_OK)
			return status;
	}
	free(curr);
	return MAP_OK;
}","<mb:mutant#2e7294758f2de3c139f979e2dfd017d7d847579c> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -303 +303 @@
-        if (curr[i].in_use == 0)
+        if (curr[i].in_use++ == 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Hashmap.c> ."
416,"unsigned long crc32(const unsigned char *s, unsigned int len)
{
  unsigned int i;
  unsigned long crc32val;
  crc32val = 0;
  for (i = 0;  i < len;  i ++)
    {
	  crc32val =crc32_tab[(crc32val ^ s[i]) & 0xff] ^  (crc32val >> 8);
	}   
  return crc32val--;
}","<mb:mutant#b9872caaef909f8b0f60d23e77cfdd594c2f407c> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -213 +213 @@
-  return crc32val;
+  return crc32val--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Hashmap.c> ."
417,"int hashmap_hash(map_t in, char* key){
	int curr;
	int i;
	hashmap_map* m = (hashmap_map *) in;
	if(m->size >= (m->table_size/2)) return MAP_FULL;
	curr = hashmap_hash_int(m, key);
	for(i = 0; i< MAX_CHAIN_LENGTH; i++){
		if(m->data[curr].in_use <= 0)
			return curr;
		if(m->data[curr].in_use == 1 && (strcmp(m->data[curr].key,key)==0))
			return curr;
		curr = (curr + 1) % m->table_size;
	}
	return MAP_FULL;
}","<mb:mutant#e04aa828fc491566293bef167cbba963bb42e595> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -262 +262 @@
-		if(m->data[curr].in_use == 0)
+		if(m->data[curr].in_use <= 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Hashmap.c> ."
418,"int hashmap_get(map_t in, char* key, any_t *arg){
	int curr;
	int i;
	hashmap_map* m;
	m = (hashmap_map *) in;
	curr = hashmap_hash_int(m, key);
	for(i = 0; i<MAX_CHAIN_LENGTH; i++){
        int in_use = m->data[curr].in_use;
        if (in_use == 1){
            if (strcmp(m->data[curr].key--,key)==0){
                *arg = (m->data[curr].data);
                return MAP_OK;
            }
		}
		curr = (curr + 1) % m->table_size;
	}
	*arg = NULL;
	return MAP_MISSING;
}","<mb:mutant#a1e665222f339b05cc6e78b744fd4ed1f2dcfc0c> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -363 +363 @@
-            if (strcmp(m->data[curr].key,key)==0){
+            if (strcmp(m->data[curr].key--,key)==0){
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Hashmap.c> ."
419,"int hashmap_rehash(map_t in){
	int i;
	int old_size;
	hashmap_element* curr;
	hashmap_map *m = (hashmap_map *) in;
	hashmap_element* temp = (hashmap_element *)
		calloc(2 * m->table_size, sizeof(hashmap_element));
	if(!temp) return MAP_OMEM;
	curr = m->data;
	m->data = temp;
	old_size = m->table_size;
	m->table_size = 2 * m->table_size;
	m->size = 0;
	for(i = 0; i < old_size; i++)
	{
        int status;
        if (curr[i].in_use == 0)
            continue;
		status = hashmap_put(m, curr[i].key, curr[i].data);
		if (status < MAP_OK)
			return status;
	}
	free(curr);
	return MAP_OK;
}","<mb:mutant#c309dc0cf26dcf4a241ecf245dc1800f0b81df1b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -307 +307 @@
-		if (status != MAP_OK)
+		if (status < MAP_OK)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Hashmap.c> ."
420,"int hashmap_rehash(map_t in){
	int i;
	int old_size;
	hashmap_element* curr;
	hashmap_map *m = (hashmap_map *) in;
	hashmap_element* temp = (hashmap_element *)
		calloc(2 * m->table_size, sizeof(hashmap_element));
	if(!temp) return MAP_OMEM;
	curr = m->data;
	m->data = temp;
	old_size = m->table_size;
	m->table_size = 2 * m->table_size;
	m->size = 0;
	for(i = 0; i < old_size; i++)
	{
        int status;
        if (curr[i].in_use == 0)
            continue;
		status = hashmap_put(m, curr[i].key++, curr[i].data);
		if (status != MAP_OK)
			return status;
	}
	free(curr);
	return MAP_OK;
}","<mb:mutant#30e448e7ee312e82116aa3104c2b75e8c90530ad> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -306 +306 @@
-		status = hashmap_put(m, curr[i].key, curr[i].data);
+		status = hashmap_put(m, curr[i].key++, curr[i].data);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Hashmap.c> ."
421,"int hashmap_remove(map_t in, char* key){
	int i;
	int curr;
	hashmap_map* m;
	m = (hashmap_map *) in;
	curr = hashmap_hash_int(m, key);
	for(i = 0; i<MAX_CHAIN_LENGTH; i++){
        int in_use = m->data[curr].in_use;
        if (in_use >= 1){
            if (strcmp(m->data[curr].key,key)==0){
                m->data[curr].in_use = 0;
                m->data[curr].data = NULL;
                m->data[curr].key = NULL;
                m->size--;
                return MAP_OK;
            }
		}
		curr = (curr + 1) % m->table_size;
	}
	return MAP_MISSING;
}","<mb:mutant#7bb47f84b807287fff081488b4b6088841892524> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -424 +424 @@
-        if (in_use == 1){
+        if (in_use >= 1){
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Hashmap.c> ."
422,"int hashmap_hash(map_t in, char* key){
	int curr;
	int i;
	hashmap_map* m = (hashmap_map *) in;
	if(m->size > (m->table_size/2)) return MAP_FULL;
	curr = hashmap_hash_int(m, key);
	for(i = 0; i< MAX_CHAIN_LENGTH; i++){
		if(m->data[curr].in_use == 0)
			return curr;
		if(m->data[curr].in_use == 1 && (strcmp(m->data[curr].key,key)==0))
			return curr;
		curr = (curr + 1) % m->table_size;
	}
	return MAP_FULL;
}","<mb:mutant#3f810ace1ca5f85ccc5cad3e2fc50943e8509035> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -255 +255 @@
-	if(m->size >= (m->table_size/2)) return MAP_FULL;
+	if(m->size > (m->table_size/2)) return MAP_FULL;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Hashmap.c> ."
423,"map_t hashmap_new() {
	hashmap_map  *m = (hashmap_map*) malloc(sizeof(hashmap_map));
	if(!m) goto err;
	m->data = (hashmap_element*) calloc(INITIAL_SIZE, sizeof(hashmap_element));
	if(!m->data) goto err;
	m->table_size = INITIAL_SIZE;
	m->size = 0;
	return abs(m);
	err:
		if (m)
			hashmap_free(m);
		return NULL;
}","<mb:mutant#d1840a6d6a6c436277bbc86eb8c93ee491fdc847> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -193 +193 @@
-	return m;
+	return abs(m);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Hashmap.c> ."
424,"int hashmap_hash(map_t in, char* key){
	int curr;
	int i;
	hashmap_map* m = (hashmap_map *) in;
	if(m->size >= (m->table_size/2)) return MAP_FULL;
	curr = hashmap_hash_int(m, key);
	for(i = 0; i< MAX_CHAIN_LENGTH; i++){
		if(m->data[curr].in_use == 0)
			return curr;
		if(m->data[curr].in_use == 1 && (strcmp(m->data[curr].key,key)==0))
			return curr--;
		curr = (curr + 1) % m->table_size;
	}
	return MAP_FULL;
}","<mb:mutant#e3a52f3ae981e3cd74d81745cc58a9f8d556c03d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -266 +266 @@
-			return curr;
+			return curr--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Hashmap.c> ."
425,"int hashmap_rehash(map_t in){
	int i;
	int old_size;
	hashmap_element* curr;
	hashmap_map *m = (hashmap_map *) in;
	hashmap_element* temp = (hashmap_element *)
		calloc(2 * m->table_size, sizeof(hashmap_element));
	if(!temp) return MAP_OMEM;
	curr = m->data;
	m->data = temp;
	old_size = m->table_size;
	m->table_size = 2 * m->table_size;
	m->size = 0;
	for(i = 0; i < old_size; i++)
	{
        int status;
        if (curr[i].in_use <= 0)
            continue;
		status = hashmap_put(m, curr[i].key, curr[i].data);
		if (status != MAP_OK)
			return status;
	}
	free(curr);
	return MAP_OK;
}","<mb:mutant#3f4839ac32ed876a21de031709062ac1eddb12ac> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -303 +303 @@
-        if (curr[i].in_use == 0)
+        if (curr[i].in_use <= 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Hashmap.c> ."
426,"int hashmap_hash(map_t in, char* key){
	int curr;
	int i;
	hashmap_map* m = (hashmap_map *) in;
	if(m->size >= (m->table_size/2)) return MAP_FULL;
	curr = hashmap_hash_int(m, key);
	for(i = 0; i< MAX_CHAIN_LENGTH; i++){
		if(m->data[curr].in_use == 0)
			return abs(curr);
		if(m->data[curr].in_use == 1 && (strcmp(m->data[curr].key,key)==0))
			return curr;
		curr = (curr + 1) % m->table_size;
	}
	return MAP_FULL;
}","<mb:mutant#d7a7b26314719059afcdcd2611540d5b8420c891> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -263 +259 @@
-			return curr;
+			return abs(curr);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Hashmap.c> ."
427,"int hashmap_rehash(map_t in){
	int i;
	int old_size;
	hashmap_element* curr;
	hashmap_map *m = (hashmap_map *) in;
	hashmap_element* temp = (hashmap_element *)
		calloc(2 * m->table_size, sizeof(hashmap_element));
	if(!temp) return MAP_OMEM;
	curr = m->data;
	m->data = temp;
	old_size = m->table_size;
	m->table_size = 2 * m->table_size;
	m->size = 0;
	for(i = 0; i < old_size; i++)
	{
        int status;
        if (curr[i].in_use == 0)
            continue;
		status = hashmap_put(m, curr[i].key, curr[i].data);
		if (status != MAP_OK)
			return abs(status);
	}
	free(curr);
	return MAP_OK;
}","<mb:mutant#267f94f230eb11e6faa006ff596464abc9e9c6b8> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -308 +302 @@
-			return status;
+			return abs(status);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Hashmap.c> ."
428,"int hashmap_put(map_t in, char* key, any_t value){
	int index;
	hashmap_map* m;
	m = (hashmap_map *) in;
	index = hashmap_hash(in, key);
	while(index == MAP_FULL){
		if (hashmap_rehash(in) == MAP_OMEM) {
			return MAP_OMEM;
		}
		index = hashmap_hash(in, key);
	}
	m->data[index].data = abs(value);
	m->data[index].key = key;
	m->data[index].in_use = 1;
	m->size++; 
	return MAP_OK;
}","<mb:mutant#21b77b4013a90ec94b4355c7dcec85796de32bd6> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -336 +330 @@
-	m->data[index].data = value;
+	m->data[index].data = abs(value);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Hashmap.c> ."
429,"int hashmap_get(map_t in, char* key, any_t *arg){
	int curr;
	int i;
	hashmap_map* m;
	m = (hashmap_map *) in;
	curr = hashmap_hash_int(m, key);
	for(i = 0; i<MAX_CHAIN_LENGTH; i++){
        int in_use = m->data[curr].in_use;
        if (in_use >= 1){
            if (strcmp(m->data[curr].key,key)==0){
                *arg = (m->data[curr].data);
                return MAP_OK;
            }
		}
		curr = (curr + 1) % m->table_size;
	}
	*arg = NULL;
	return MAP_MISSING;
}","<mb:mutant#a2b07e72634d16fb257f1b3024232562e5b62516> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -362 +362 @@
-        if (in_use == 1){
+        if (in_use >= 1){
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Hashmap.c> ."
430,"int hashmap_get(map_t in, char* key, any_t *arg){
	int curr;
	int i;
	hashmap_map* m;
	m = (hashmap_map *) in;
	curr = hashmap_hash_int(m, key);
	for(i = 0; i<MAX_CHAIN_LENGTH; i++){
        int in_use = m->data[curr].in_use;
        if (in_use == 1){
            if (strcmp(m->data[curr].key,key++)==0){
                *arg = (m->data[curr].data);
                return MAP_OK;
            }
		}
		curr = (curr + 1) % m->table_size;
	}
	*arg = NULL;
	return MAP_MISSING;
}","<mb:mutant#5897a4d39f0731b91546b466bfb4c3d9991ec07f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -363 +363 @@
-            if (strcmp(m->data[curr].key,key)==0){
+            if (strcmp(m->data[curr].key,key++)==0){
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Hashmap.c> ."
431,"int main(void)
{	int i,j,temp,y,a[5];
	for(i=0;i<5;i++)
		scanf (""%d,"",&a[i]);
	for(i=0;i<5;i++)
	{
		for(j=i+1;j<5;j++)
		{			
			if(a[i]<a[j])
			{ 
				temp=a[i];     
				a[i]=a[j]; 
				a[j]=temp;
		} }	
		printf(""%5d "",a[i]);} 
}",
432,"int main(void)
{	int i,j,temp,y,a[5];
	for(i=0;i<5;i++)
		scanf (""%d,"",&a[i]);
	for(i=0;i<5;i++)
	{
		for(j=i+1;j<5;j++)
		{			
			if(a[i]<a[j])
			{ 
				temp=a[i];     
				a[i]=a[++j];
				a[j]=temp;
		} }	
		printf(""%5d "",a[i]);} 
}","<mb:mutant#5c802f9ede0e771057290140862b70b1e518d97e> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -12 +12 @@
-				a[i]=a[j];
+				a[i]=a[++j];
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#bubble.c> ."
433,"int main(void)
{	int i,j,temp,y,a[5];
	for(i=0;i<5;i++)
		scanf (""%d,"",&a[i]);
	for(i=0;i<5;i++)
	{
		for(j=i+1;j<5;j++)
		{			
			if(a[i]<a[j])
			{ 
				temp=a[i]--;
				a[i]=a[j]; 
				a[j]=temp;
		} }	
		printf(""%5d "",a[i]);} 
}","<mb:mutant#55c2f97b92136b4dc7d4a66501851d327aa0cdec> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -11 +11 @@
-				temp=a[i];
+				temp=a[i]--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#bubble.c> ."
434,"int main(void)
{	int i,j,temp,y,a[5];
	for(i=0;i<5;i++)
		scanf (""%d,"",&a[i]);
	for(i=0;i<5;i++)
	{
		for(j=i+1;j<5;j++)
		{			
			if(a[i]<a[j])
			{ 
				temp=a[i];     
				a[i]=a[j]; 
				a[j]=temp--;
		} }	
		printf(""%5d "",a[i]);} 
}","<mb:mutant#a8b18fa973916e9221a25627c6187074e4c89781> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -13 +13 @@
-				a[j]=temp;
+				a[j]=temp--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#bubble.c> ."
435,"int main(void)
{	int i,j,temp,y,a[5];
	for(i=0;i<5;i++)
		scanf (""%d,"",&a[i]);
	for(i=0;i<5;i++)
	{
		for(j=i+1;j<5;j++)
		{			
			if(a[i]<a[j])
			{ 
				temp=a[i]++;
				a[i]=a[j]; 
				a[j]=temp;
		} }	
		printf(""%5d "",a[i]);} 
}","<mb:mutant#178c6e8562fed1fc1815a759616c52fd61de5479> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -11 +11 @@
-				temp=a[i];
+				temp=a[i]++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#bubble.c> ."
436,"int main(void)
{	int i,j,temp,y,a[5];
	for(i=0;i<5;i++)
		scanf (""%d,"",&a[i]);
	for(i=0;i<5;i++)
	{
		for(j=i+1;j<5;j++)
		{			
			if(a[i]<a[j])
			{ 
				temp=a[i];     
				a[i]=a[j]; 
				a[j]=temp++;
		} }	
		printf(""%5d "",a[i]);} 
}","<mb:mutant#4761d104dfa6ffd48062b9591cc7d2c2d848cd04> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -13 +13 @@
-				a[j]=temp;
+				a[j]=temp++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#bubble.c> ."
437,"int main(void)
{	int i,j,temp,y,a[5];
	for(i=0;i<5;i++)
		scanf (""%d,"",&a[i]);
	for(i=0;i<5;i++)
	{
		for(j=i/1;j<5;j++)
		{			
			if(a[i]<a[j])
			{ 
				temp=a[i];     
				a[i]=a[j]; 
				a[j]=temp;
		} }	
		printf(""%5d "",a[i]);} 
}","<mb:mutant#67912081c0df92d4512b9c001bd3ca9948e82b47> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -7 +7 @@
-		for(j=i+1;j<5;j++)
+		for(j=i/1;j<5;j++)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#bubble.c> ."
438,"int main(void)
{	int i,j,temp,y,a[5];
	for(i=0;i<5;i++)
		scanf (""%d,"",&a[i]);
	for(i=0;i<5;i++)
	{
		for(j=i+1;j<5;j++)
		{			
			if(a[i]<a[j])
			{ 
				temp=a[i];     
				a[i]=a[j]--;
				a[j]=temp;
		} }	
		printf(""%5d "",a[i]);} 
}","<mb:mutant#a8ef807857f63dca9abc9e626711308f9e0ec6cd> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -12 +12 @@
-				a[i]=a[j];
+				a[i]=a[j]--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#bubble.c> ."
439,"int main(void)
{	int i,j,temp,y,a[5];
	for(i=0;i<5;i++)
		scanf (""%d,"",&a[i]);
	for(i=0;i<5;i++)
	{
		for(j=i+1;j<5;j++)
		{			
			if(a[i]<a[j])
			{ 
				temp=a[i];     
				a[i]=a[j]++;
				a[j]=temp;
		} }	
		printf(""%5d "",a[i]);} 
}","<mb:mutant#c9f50eeb5fcf53e17f5f647caf93efe5b9ccd8ac> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -12 +12 @@
-				a[i]=a[j];
+				a[i]=a[j]++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#bubble.c> ."
440,"int main(void)
{	int i,j,temp,y,a[5];
	for(i=0;i<5;i++)
		scanf (""%d,"",&a[i]);
	for(i=0;i<5;i++)
	{
		for(j=i*1;j<5;j++)
		{			
			if(a[i]<a[j])
			{ 
				temp=a[i];     
				a[i]=a[j]; 
				a[j]=temp;
		} }	
		printf(""%5d "",a[i]);} 
}","<mb:mutant#b5079ef0b59bc3a3c0939b979cb498600230f9dc> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -7 +7 @@
-		for(j=i+1;j<5;j++)
+		for(j=i*1;j<5;j++)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#bubble.c> ."
441,"int main(void)
{	int i,j,temp,y,a[5];
	for(i=0;i<5;i++)
		scanf (""%d,"",&a[i]);
	for(i=0;i<5;i++)
	{
		for(j=i+1;j<5;j++)
		{			
			if(a[i]<=a[j])
			{ 
				temp=a[i];     
				a[i]=a[j]; 
				a[j]=temp;
		} }	
		printf(""%5d "",a[i]);} 
}","<mb:mutant#62fb9cf0fb28b9ebdfc12b7b4ad1c5672ce35a9e> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -9 +9 @@
-			if(a[i]<a[j])
+			if(a[i]<=a[j])
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#bubble.c> ."
442,"double accelerate(double throttle)
{
	 if (throttle<(maxThrottle-5))
		 throttle =throttle+5.0;  
	 else
		 throttle=maxThrottle;
	 return throttle;
}",
443,"double accelerate(double throttle)
{
	 if (throttle<(maxThrottle-5))
		 throttle =throttle--+5.0;
	 else
		 throttle=maxThrottle;
	 return throttle;
}","<mb:mutant#d3b14ff3b7683e390e2aa512d96bc05424a6a890> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -62 +62 @@
-		 throttle =throttle+5.0;
+		 throttle =throttle--+5.0;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Carsimulator.c> ."
444,"int *run(double throttle, int brakepedal)
{
   	double fdist=0.0;
   	double fspeed=0.0;
   	int speed, distance;
	int *result;
   	speed=0;
   	distance=0;
	fspeed = fspeed+((throttle - fspeed/airResistance - 2*brakepedal))/ticksPerSecond;
	if (fspeed>maxSpeed) 
		fspeed=maxSpeed;
	if (fspeed<0)
		fspeed=0;
	fdist = fdist + (fspeed/36.0)/ticksPerSecond;
	speed = (int)fspeed;
	distance=(int)fdist;
	if (throttle>0.0) 
		throttle-=0.5/ticksPerSecond;
	if (throttle<0.0) 
		throttle=0;
  	result[0]=speed;
	result[1]=distance;
   	return result;
}",
445,"int *run(double throttle, int brakepedal)
{
   	double fdist=0.0;
   	double fspeed=0.0;
   	int speed, distance;
	int *result;
   	speed=0;
   	distance=0;
	fspeed = fspeed+((throttle - fspeed/airResistance - 2*brakepedal))/ticksPerSecond;
	if (fspeed>maxSpeed) 
		fspeed=maxSpeed;
	if (fspeed<0)
		fspeed=0;
	fdist = fdist + (fspeed/36.0)/ticksPerSecond;
	speed = (int)fspeed;
	distance=(int)--fdist;
	if (throttle>0.0) 
		throttle-=0.5/ticksPerSecond;
	if (throttle<0.0) 
		throttle=0;
  	result[0]=speed;
	result[1]=distance;
   	return result;
}","<mb:mutant#6116c60943d32619c20cc172cc89fc31fe2c8631> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -107 +107 @@
-	distance=(int)fdist;
+	distance=(int)--fdist;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Carsimulator.c> ."
446,"double setThrottle(double val) 
{
    double throttle=val;
    if (throttle<0.0)
     	throttle=0.0;
    if (throttle>10.0) 
      	throttle=10.0;
    return throttle;
}",
447,"double setThrottle(double val) 
{
    double throttle=val;
    if (throttle<=0.0)
     	throttle=0.0;
    if (throttle>10.0) 
      	throttle=10.0;
    return throttle;
}","<mb:mutant#89c2667f45a9d47e7cf54ccf5b8007e3aa549386> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -126 +126 @@
-    if (throttle<0.0)
+    if (throttle<=0.0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Carsimulator.c> ."
448,"int brake(int brakepedal) 
{
	if (brakepedal<(maxBrake-1))
		brakepedal =brakepedal+1;
	else
		brakepedal=maxBrake;
	return brakepedal;
}",
449,"int brake(int brakepedal) 
{
	if (brakepedal<(maxBrake-1))
		brakepedal =brakepedal+1;
	else
		brakepedal=maxBrake;
	return brakepedal++;
}","<mb:mutant#eeaa0ba7e1f6782d16e5f641ccd486ecfc3f2dec> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -79 +79 @@
-	return brakepedal;
+	return brakepedal++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Carsimulator.c> ."
450,"int *run(double throttle, int brakepedal)
{
   	double fdist=0.0;
   	double fspeed=0.0;
   	int speed, distance;
	int *result;
   	speed=0;
   	distance=0;
	fspeed = fspeed+((throttle - fspeed/airResistance - 2*brakepedal))/ticksPerSecond;
	if (fspeed>maxSpeed) 
		fspeed=maxSpeed;
	if (fspeed<0)
		fspeed=0;
	fdist = fdist++ + (fspeed/36.0)/ticksPerSecond;
	speed = (int)fspeed;
	distance=(int)fdist;
	if (throttle>0.0) 
		throttle-=0.5/ticksPerSecond;
	if (throttle<0.0) 
		throttle=0;
  	result[0]=speed;
	result[1]=distance;
   	return result;
}","<mb:mutant#19c801f5f1e7b712615fe8a5d35a2ffee30c1f23> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -105 +105 @@
-	fdist = fdist + (fspeed/36.0)/ticksPerSecond;
+	fdist = fdist++ + (fspeed/36.0)/ticksPerSecond;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Carsimulator.c> ."
451,"int *run(double throttle, int brakepedal)
{
   	double fdist=0.0;
   	double fspeed=0.0;
   	int speed, distance;
	int *result;
   	speed=0;
   	distance=0;
	fspeed = fspeed--+((throttle - fspeed/airResistance - 2*brakepedal))/ticksPerSecond;
	if (fspeed>maxSpeed) 
		fspeed=maxSpeed;
	if (fspeed<0)
		fspeed=0;
	fdist = fdist + (fspeed/36.0)/ticksPerSecond;
	speed = (int)fspeed;
	distance=(int)fdist;
	if (throttle>0.0) 
		throttle-=0.5/ticksPerSecond;
	if (throttle<0.0) 
		throttle=0;
  	result[0]=speed;
	result[1]=distance;
   	return result;
}","<mb:mutant#575e8f5f3c81c37e8a9500f629dcf44402e679a0> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -99 +99 @@
-	fspeed = fspeed+((throttle - fspeed/airResistance - 2*brakepedal))/ticksPerSecond;
+	fspeed = fspeed--+((throttle - fspeed/airResistance - 2*brakepedal))/ticksPerSecond;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Carsimulator.c> ."
452,"int brake(int brakepedal) 
{
	if (brakepedal<(maxBrake-1))
		brakepedal =brakepedal+++1;
	else
		brakepedal=maxBrake;
	return brakepedal;
}","<mb:mutant#6ff7586d62bd609db1ff6d2b4761329fd26a74ae> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -76 +76 @@
-		brakepedal =brakepedal+1;
+		brakepedal =brakepedal+++1;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Carsimulator.c> ."
453,"int *run(double throttle, int brakepedal)
{
   	double fdist=0.0;
   	double fspeed=0.0;
   	int speed, distance;
	int *result;
   	speed=0;
   	distance=0;
	fspeed = fspeed+((throttle - fspeed/airResistance - 2*brakepedal))/ticksPerSecond;
	if (fspeed>maxSpeed) 
		fspeed=maxSpeed;
	if (fspeed<0)
		fspeed=0;
	fdist = fdist - (fspeed/36.0)/ticksPerSecond;
	speed = (int)fspeed;
	distance=(int)fdist;
	if (throttle>0.0) 
		throttle-=0.5/ticksPerSecond;
	if (throttle<0.0) 
		throttle=0;
  	result[0]=speed;
	result[1]=distance;
   	return result;
}","<mb:mutant#cb2411f25e2bcd4836ce0bf24d65f5337ed8c516> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -105 +105 @@
-	fdist = fdist + (fspeed/36.0)/ticksPerSecond;
+	fdist = fdist - (fspeed/36.0)/ticksPerSecond;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Carsimulator.c> ."
454,"double accelerate(double throttle)
{
	 if (throttle<=(maxThrottle-5))
		 throttle =throttle+5.0;  
	 else
		 throttle=maxThrottle;
	 return throttle;
}","<mb:mutant#9030345eb7f7a6127a1dba17f728797f6408b4fb> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -61 +61 @@
-	 if (throttle<(maxThrottle-5))
+	 if (throttle<=(maxThrottle-5))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Carsimulator.c> ."
455,"int *run(double throttle, int brakepedal)
{
   	double fdist=0.0;
   	double fspeed=0.0;
   	int speed, distance;
	int *result;
   	speed=0;
   	distance=0;
	fspeed = fspeed+((throttle - fspeed/airResistance - 2*brakepedal))/ticksPerSecond;
	if (fspeed>maxSpeed) 
		fspeed=maxSpeed;
	if (fspeed==0)
		fspeed=0;
	fdist = fdist + (fspeed/36.0)/ticksPerSecond;
	speed = (int)fspeed;
	distance=(int)fdist;
	if (throttle>0.0) 
		throttle-=0.5/ticksPerSecond;
	if (throttle<0.0) 
		throttle=0;
  	result[0]=speed;
	result[1]=distance;
   	return result;
}","<mb:mutant#2c35415e531d64a01ef615c6e0aa10e9add2a81a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -102 +102 @@
-	if (fspeed<0)
+	if (fspeed==0)
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Carsimulator.c> ."
456,"int *run(double throttle, int brakepedal)
{
   	double fdist=0.0;
   	double fspeed=0.0;
   	int speed, distance;
	int *result;
   	speed=0;
   	distance=0;
	fspeed = fspeed+((throttle - fspeed/airResistance - 2*brakepedal))/ticksPerSecond;
	if (fspeed>maxSpeed) 
		fspeed=maxSpeed;
	if (fspeed<0)
		fspeed=0;
	fdist = fdist + (fspeed/36.0)/ticksPerSecond;
	speed = (int)fspeed++;
	distance=(int)fdist;
	if (throttle>0.0) 
		throttle-=0.5/ticksPerSecond;
	if (throttle<0.0) 
		throttle=0;
  	result[0]=speed;
	result[1]=distance;
   	return result;
}","<mb:mutant#5e66fb8b63e350316f8a5f5477059fe6d36743ef> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -106 +106 @@
-	speed = (int)fspeed;
+	speed = (int)fspeed++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Carsimulator.c> ."
457,"int *run(double throttle, int brakepedal)
{
   	double fdist=0.0;
   	double fspeed=0.0;
   	int speed, distance;
	int *result;
   	speed=0;
   	distance=0;
	fspeed = fspeed+((throttle - fspeed/airResistance - 2*brakepedal))/ticksPerSecond;
	if (fspeed>maxSpeed) 
		fspeed=maxSpeed;
	if (fspeed<0)
		fspeed=0;
	fdist = fdist + (fspeed/36.0)/ticksPerSecond;
	speed = (int)fspeed--;
	distance=(int)fdist;
	if (throttle>0.0) 
		throttle-=0.5/ticksPerSecond;
	if (throttle<0.0) 
		throttle=0;
  	result[0]=speed;
	result[1]=distance;
   	return result;
}","<mb:mutant#9f19aa1b9976985ca0dceb292971b98b67de93e1> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -106 +106 @@
-	speed = (int)fspeed;
+	speed = (int)fspeed--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Carsimulator.c> ."
458,"double accelerate(double throttle)
{
	 if (throttle<(maxThrottle-5))
		 throttle =throttle+++5.0;
	 else
		 throttle=maxThrottle;
	 return throttle;
}","<mb:mutant#910f410c9b92fa05815d1df9ded0817d25dac12f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -62 +62 @@
-		 throttle =throttle+5.0;
+		 throttle =throttle+++5.0;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Carsimulator.c> ."
459,"int *run(double throttle, int brakepedal)
{
   	double fdist=0.0;
   	double fspeed=0.0;
   	int speed, distance;
	int *result;
   	speed=0;
   	distance=0;
	fspeed = fspeed+((throttle - fspeed--/airResistance - 2*brakepedal))/ticksPerSecond;
	if (fspeed>maxSpeed) 
		fspeed=maxSpeed;
	if (fspeed<0)
		fspeed=0;
	fdist = fdist + (fspeed/36.0)/ticksPerSecond;
	speed = (int)fspeed;
	distance=(int)fdist;
	if (throttle>0.0) 
		throttle-=0.5/ticksPerSecond;
	if (throttle<0.0) 
		throttle=0;
  	result[0]=speed;
	result[1]=distance;
   	return result;
}","<mb:mutant#0c2399ac94c54c7e7b96eaaf7b181b716675ee33> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -99 +99 @@
-	fspeed = fspeed+((throttle - fspeed/airResistance - 2*brakepedal))/ticksPerSecond;
+	fspeed = fspeed+((throttle - fspeed--/airResistance - 2*brakepedal))/ticksPerSecond;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Carsimulator.c> ."
460,"int *run(double throttle, int brakepedal)
{
   	double fdist=0.0;
   	double fspeed=0.0;
   	int speed, distance;
	int *result;
   	speed=0;
   	distance=0;
	fspeed = fspeed+((throttle - fspeed/airResistance - 2*brakepedal))/ticksPerSecond;
	if (fspeed>maxSpeed) 
		fspeed=maxSpeed;
	if (fspeed<0)
		fspeed=0;
	fdist = fdist + (fspeed/36.0)/ticksPerSecond;
	speed = (int)fspeed;
	distance=(int)fdist;
	if (throttle>0.0) 
		throttle-=0.5/ticksPerSecond;
	if (throttle<=0.0)
		throttle=0;
  	result[0]=speed;
	result[1]=distance;
   	return result;
}","<mb:mutant#dd6f8de5ba3bc345760622ec0c84ebe3485b8e2a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -111 +111 @@
-	if (throttle<0.0)
+	if (throttle<=0.0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Carsimulator.c> ."
461,"int *run(double throttle, int brakepedal)
{
   	double fdist=0.0;
   	double fspeed=0.0;
   	int speed, distance;
	int *result;
   	speed=0;
   	distance=0;
	fspeed = fspeed+((throttle - fspeed/airResistance - 2*brakepedal++))/ticksPerSecond;
	if (fspeed>maxSpeed) 
		fspeed=maxSpeed;
	if (fspeed<0)
		fspeed=0;
	fdist = fdist + (fspeed/36.0)/ticksPerSecond;
	speed = (int)fspeed;
	distance=(int)fdist;
	if (throttle>0.0) 
		throttle-=0.5/ticksPerSecond;
	if (throttle<0.0) 
		throttle=0;
  	result[0]=speed;
	result[1]=distance;
   	return result;
}","<mb:mutant#74a4b600fee9b94827d0b021f18664dc719e6e37> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -99 +99 @@
-	fspeed = fspeed+((throttle - fspeed/airResistance - 2*brakepedal))/ticksPerSecond;
+	fspeed = fspeed+((throttle - fspeed/airResistance - 2*brakepedal++))/ticksPerSecond;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Carsimulator.c> ."
462,"double accelerate(double throttle)
{
	 if (throttle<(maxThrottle-5))
		 throttle =abs(throttle)+5.0;
	 else
		 throttle=maxThrottle;
	 return throttle;
}","<mb:mutant#dfc7dcebfc0369a3cb6405dbed814b48dbd8ce14> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -62 +62 @@
-		 throttle =throttle+5.0;
+		 throttle =abs(throttle)+5.0;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Carsimulator.c> ."
463,"int brake(int brakepedal) 
{
	if (brakepedal<(maxBrake/1))
		brakepedal =brakepedal+1;
	else
		brakepedal=maxBrake;
	return brakepedal;
}","<mb:mutant#04fef1d49965425b5760c8cd7a17d5c39a3fc680> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -75 +75 @@
-	if (brakepedal<(maxBrake-1))
+	if (brakepedal<(maxBrake/1))
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Carsimulator.c> ."
464,"int *run(double throttle, int brakepedal)
{
   	double fdist=0.0;
   	double fspeed=0.0;
   	int speed, distance;
	int *result;
   	speed=0;
   	distance=0;
	fspeed = fspeed+((throttle - --fspeed/airResistance - 2*brakepedal))/ticksPerSecond;
	if (fspeed>maxSpeed) 
		fspeed=maxSpeed;
	if (fspeed<0)
		fspeed=0;
	fdist = fdist + (fspeed/36.0)/ticksPerSecond;
	speed = (int)fspeed;
	distance=(int)fdist;
	if (throttle>0.0) 
		throttle-=0.5/ticksPerSecond;
	if (throttle<0.0) 
		throttle=0;
  	result[0]=speed;
	result[1]=distance;
   	return result;
}","<mb:mutant#333376ed3c164e71a003b48f9aae2436c06a76f5> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -99 +99 @@
-	fspeed = fspeed+((throttle - fspeed/airResistance - 2*brakepedal))/ticksPerSecond;
+	fspeed = fspeed+((throttle - --fspeed/airResistance - 2*brakepedal))/ticksPerSecond;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Carsimulator.c> ."
465,"int *run(double throttle, int brakepedal)
{
   	double fdist=0.0;
   	double fspeed=0.0;
   	int speed, distance;
	int *result;
   	speed=0;
   	distance=0;
	fspeed = fspeed+((throttle - fspeed/airResistance - 2*brakepedal))/ticksPerSecond;
	if (fspeed>maxSpeed) 
		fspeed=abs(maxSpeed);
	if (fspeed<0)
		fspeed=0;
	fdist = fdist + (fspeed/36.0)/ticksPerSecond;
	speed = (int)fspeed;
	distance=(int)fdist;
	if (throttle>0.0) 
		throttle-=0.5/ticksPerSecond;
	if (throttle<0.0) 
		throttle=0;
  	result[0]=speed;
	result[1]=distance;
   	return result;
}","<mb:mutant#e59f60fd602440c4439303c05a5abb239732de7f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -101 +101 @@
-		fspeed=maxSpeed;
+		fspeed=abs(maxSpeed);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Carsimulator.c> ."
466,"int *run(double throttle, int brakepedal)
{
   	double fdist=0.0;
   	double fspeed=0.0;
   	int speed, distance;
	int *result;
   	speed=0;
   	distance=0;
	fspeed = fspeed+((throttle - fspeed/airResistance - 2*brakepedal))/ticksPerSecond;
	if (fspeed>maxSpeed) 
		fspeed=maxSpeed;
	if (fspeed<0)
		fspeed=0;
	fdist = fdist + (fspeed/36.0)/ticksPerSecond;
	speed = (int)fspeed;
	distance=(int)fdist;
	if (throttle>0.0) 
		throttle-=0.5/ticksPerSecond;
	if (throttle<0.0) 
		throttle=0;
  	result[0]=speed;
	result[1]=distance;
   	return result++;
}","<mb:mutant#e9f71962298315ab7a813e140fa552dd9a1cfede> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -116 +116 @@
-   	return result;
+   	return result++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Carsimulator.c> ."
467,"int *run(double throttle, int brakepedal)
{
   	double fdist=0.0;
   	double fspeed=0.0;
   	int speed, distance;
	int *result;
   	speed=0;
   	distance=0;
	fspeed = fspeed+((throttle - fspeed/airResistance - 2*--brakepedal))/ticksPerSecond;
	if (fspeed>maxSpeed) 
		fspeed=maxSpeed;
	if (fspeed<0)
		fspeed=0;
	fdist = fdist + (fspeed/36.0)/ticksPerSecond;
	speed = (int)fspeed;
	distance=(int)fdist;
	if (throttle>0.0) 
		throttle-=0.5/ticksPerSecond;
	if (throttle<0.0) 
		throttle=0;
  	result[0]=speed;
	result[1]=distance;
   	return result;
}","<mb:mutant#a3f7089cf29ab948460b050f264cb2f7cb4cd336> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -99 +99 @@
-	fspeed = fspeed+((throttle - fspeed/airResistance - 2*brakepedal))/ticksPerSecond;
+	fspeed = fspeed+((throttle - fspeed/airResistance - 2*--brakepedal))/ticksPerSecond;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Carsimulator.c> ."
468,"bool engineOn(bool engine)
{
    ignition = true;
    if (engine==false) 
    {
       	engine = true;
    }
    return engine;
 }",
469,"bool engineOn(bool engine)
{
    ignition = true;
    if (engine<=false)
    {
       	engine = true;
    }
    return engine;
 }","<mb:mutant#0c768872e08ffb5db4bce09e57d6ba66a99c9dbd> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -34 +34 @@
-    if (engine==false)
+    if (engine<=false)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Carsimulator.c> ."
470,"int brake(int brakepedal) 
{
	if (brakepedal<(maxBrake+1))
		brakepedal =brakepedal+1;
	else
		brakepedal=maxBrake;
	return brakepedal;
}","<mb:mutant#29c186880f01a20bfee39dd74d9ebb695ccbf7ca> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -75 +75 @@
-	if (brakepedal<(maxBrake-1))
+	if (brakepedal<(maxBrake+1))
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Carsimulator.c> ."
471,"int brake(int brakepedal) 
{
	if (brakepedal<(maxBrake-1))
		brakepedal =brakepedal--+1;
	else
		brakepedal=maxBrake;
	return brakepedal;
}","<mb:mutant#e94fb85e6851e3074d20688a8d2c2004e24aef9d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -76 +76 @@
-		brakepedal =brakepedal+1;
+		brakepedal =brakepedal--+1;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Carsimulator.c> ."
472,"int *run(double throttle, int brakepedal)
{
   	double fdist=0.0;
   	double fspeed=0.0;
   	int speed, distance;
	int *result;
   	speed=0;
   	distance=0;
	fspeed = fspeed+((throttle - fspeed/airResistance - 2*brakepedal))/ticksPerSecond;
	if (fspeed>maxSpeed) 
		fspeed=maxSpeed;
	if (fspeed<0)
		fspeed=0;
	fdist = --fdist + (fspeed/36.0)/ticksPerSecond;
	speed = (int)fspeed;
	distance=(int)fdist;
	if (throttle>0.0) 
		throttle-=0.5/ticksPerSecond;
	if (throttle<0.0) 
		throttle=0;
  	result[0]=speed;
	result[1]=distance;
   	return result;
}","<mb:mutant#ea8fd796939ba23a6fee65e580f2d2a152106621> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -105 +105 @@
-	fdist = fdist + (fspeed/36.0)/ticksPerSecond;
+	fdist = --fdist + (fspeed/36.0)/ticksPerSecond;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Carsimulator.c> ."
473,"int brake(int brakepedal) 
{
	if (brakepedal<=(maxBrake-1))
		brakepedal =brakepedal+1;
	else
		brakepedal=maxBrake;
	return brakepedal;
}","<mb:mutant#39d25e1efac07fbbbd8c305d2cfee9c739f6f74d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -75 +75 @@
-	if (brakepedal<(maxBrake-1))
+	if (brakepedal<=(maxBrake-1))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Carsimulator.c> ."
474,"double setThrottle(double val) 
{
    double throttle=val;
    if (throttle<0.0)
     	throttle=0.0;
    if (throttle>=10.0)
      	throttle=10.0;
    return throttle;
}","<mb:mutant#ed364ae3de63617bfd0dac6d662b36087e6a7e09> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -128 +128 @@
-    if (throttle>10.0)
+    if (throttle>=10.0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Carsimulator.c> ."
475,"double accelerate(double throttle)
{
	 if (throttle<(maxThrottle-5))
		 throttle =throttle+5.0;  
	 else
		 throttle=maxThrottle;
	 return throttle--;
}","<mb:mutant#864f297dd00c7add641eddca7ce9f03ddcf51dca> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -65 +65 @@
-	 return throttle;
+	 return throttle--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Carsimulator.c> ."
476,"double accelerate(double throttle)
{
	 if (throttle<(maxThrottle-5))
		 throttle =throttle+5.0;  
	 else
		 throttle=maxThrottle;
	 return throttle++;
}","<mb:mutant#6a0b3542f3e177cb86ea88883c095f0a473c4976> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -65 +65 @@
-	 return throttle;
+	 return throttle++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Carsimulator.c> ."
477,"int *run(double throttle, int brakepedal)
{
   	double fdist=0.0;
   	double fspeed=0.0;
   	int speed, distance;
	int *result;
   	speed=0;
   	distance=0;
	fspeed = fspeed+((throttle - fspeed/airResistance - 2*brakepedal))/ticksPerSecond;
	if (fspeed>maxSpeed) 
		fspeed=maxSpeed;
	if (fspeed<0)
		fspeed=0;
	fdist = abs(fdist) + (fspeed/36.0)/ticksPerSecond;
	speed = (int)fspeed;
	distance=(int)fdist;
	if (throttle>0.0) 
		throttle-=0.5/ticksPerSecond;
	if (throttle<0.0) 
		throttle=0;
  	result[0]=speed;
	result[1]=distance;
   	return result;
}","<mb:mutant#70de110461c8009306a824a5a02894a10d0ebb81> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -105 +105 @@
-	fdist = fdist + (fspeed/36.0)/ticksPerSecond;
+	fdist = abs(fdist) + (fspeed/36.0)/ticksPerSecond;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Carsimulator.c> ."
478,"double setThrottle(double val) 
{
    double throttle=val;
    if (throttle<0.0)
     	throttle=0.0;
    if (throttle>10.0) 
      	throttle=10.0;
    return throttle++;
}","<mb:mutant#4133078660d519a2be5dace8de3b5b5eb1df5d65> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -130 +130 @@
-    return throttle;
+    return throttle++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Carsimulator.c> ."
479,"double setThrottle(double val) 
{
    double throttle=val--;
    if (throttle<0.0)
     	throttle=0.0;
    if (throttle>10.0) 
      	throttle=10.0;
    return throttle;
}","<mb:mutant#14a03995b321289d4d465ff18bfe24a1c71d2410> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -125 +125 @@
-    double throttle=val;
+    double throttle=val--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Carsimulator.c> ."
480,"int *run(double throttle, int brakepedal)
{
   	double fdist=0.0;
   	double fspeed=0.0;
   	int speed, distance;
	int *result;
   	speed=0;
   	distance=0;
	fspeed = fspeed+((throttle - fspeed/airResistance - 2*brakepedal))/ticksPerSecond;
	if (fspeed>maxSpeed) 
		fspeed=maxSpeed;
	if (fspeed<0)
		fspeed=0;
	fdist = fdist-- + (fspeed/36.0)/ticksPerSecond;
	speed = (int)fspeed;
	distance=(int)fdist;
	if (throttle>0.0) 
		throttle-=0.5/ticksPerSecond;
	if (throttle<0.0) 
		throttle=0;
  	result[0]=speed;
	result[1]=distance;
   	return result;
}","<mb:mutant#76213e55ec1cc92ee37d7ae119ee6c7d155df622> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -105 +105 @@
-	fdist = fdist + (fspeed/36.0)/ticksPerSecond;
+	fdist = fdist-- + (fspeed/36.0)/ticksPerSecond;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Carsimulator.c> ."
481,"int *run(double throttle, int brakepedal)
{
   	double fdist=0.0;
   	double fspeed=0.0;
   	int speed, distance;
	int *result;
   	speed=0;
   	distance=0;
	fspeed = fspeed+((throttle - fspeed/airResistance - 2*brakepedal))/ticksPerSecond;
	if (fspeed>maxSpeed) 
		fspeed=maxSpeed;
	if (fspeed<0)
		fspeed=0;
	fdist = fdist + (fspeed/36.0)/ticksPerSecond;
	speed = (int)fspeed;
	distance=(int)fdist++;
	if (throttle>0.0) 
		throttle-=0.5/ticksPerSecond;
	if (throttle<0.0) 
		throttle=0;
  	result[0]=speed;
	result[1]=distance;
   	return result;
}","<mb:mutant#49e48983d381ff6bc947d282b849a947763379b2> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -107 +107 @@
-	distance=(int)fdist;
+	distance=(int)fdist++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Carsimulator.c> ."
482,"int *run(double throttle, int brakepedal)
{
   	double fdist=0.0;
   	double fspeed=0.0;
   	int speed, distance;
	int *result;
   	speed=0;
   	distance=0;
	fspeed = fspeed+((throttle - fspeed++/airResistance - 2*brakepedal))/ticksPerSecond;
	if (fspeed>maxSpeed) 
		fspeed=maxSpeed;
	if (fspeed<0)
		fspeed=0;
	fdist = fdist + (fspeed/36.0)/ticksPerSecond;
	speed = (int)fspeed;
	distance=(int)fdist;
	if (throttle>0.0) 
		throttle-=0.5/ticksPerSecond;
	if (throttle<0.0) 
		throttle=0;
  	result[0]=speed;
	result[1]=distance;
   	return result;
}","<mb:mutant#cdeadf5a74d0d72a122c6da4c6694d2a736c4239> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -99 +99 @@
-	fspeed = fspeed+((throttle - fspeed/airResistance - 2*brakepedal))/ticksPerSecond;
+	fspeed = fspeed+((throttle - fspeed++/airResistance - 2*brakepedal))/ticksPerSecond;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Carsimulator.c> ."
483,"int *run(double throttle, int brakepedal)
{
   	double fdist=0.0;
   	double fspeed=0.0;
   	int speed, distance;
	int *result;
   	speed=0;
   	distance=0;
	fspeed = fspeed+++((throttle - fspeed/airResistance - 2*brakepedal))/ticksPerSecond;
	if (fspeed>maxSpeed) 
		fspeed=maxSpeed;
	if (fspeed<0)
		fspeed=0;
	fdist = fdist + (fspeed/36.0)/ticksPerSecond;
	speed = (int)fspeed;
	distance=(int)fdist;
	if (throttle>0.0) 
		throttle-=0.5/ticksPerSecond;
	if (throttle<0.0) 
		throttle=0;
  	result[0]=speed;
	result[1]=distance;
   	return result;
}","<mb:mutant#986cc8489431a05df958ac21110820455845f583> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -99 +99 @@
-	fspeed = fspeed+((throttle - fspeed/airResistance - 2*brakepedal))/ticksPerSecond;
+	fspeed = fspeed+++((throttle - fspeed/airResistance - 2*brakepedal))/ticksPerSecond;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Carsimulator.c> ."
484,"double accelerate(double throttle)
{
	 if (throttle<(maxThrottle-5))
		 throttle =throttle+5.0;  
	 else
		 throttle=abs(maxThrottle);
	 return throttle;
}","<mb:mutant#6932d66a57edb3daa4e4e086861a4dd0e7651d37> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -64 +64 @@
-		 throttle=maxThrottle;
+		 throttle=abs(maxThrottle);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Carsimulator.c> ."
485,"double accelerate(double throttle)
{
	 if (throttle<(maxThrottle-5))
		 throttle =throttle+5.0;  
	 else
		 throttle=maxThrottle;
	 return abs(throttle);
}","<mb:mutant#5ba3018b770d94985579209e5ae2dd8b09792896> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -65 +65 @@
-	 return throttle;
+	 return abs(throttle);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Carsimulator.c> ."
486,"int brake(int brakepedal) 
{
	if (brakepedal<(maxBrake-1))
		brakepedal =brakepedal+1;
	else
		brakepedal=maxBrake;
	return brakepedal--;
}","<mb:mutant#3fd96ef4a060ad792fd4a5dee8fc59d624d13a48> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -79 +79 @@
-	return brakepedal;
+	return brakepedal--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Carsimulator.c> ."
487,"int *run(double throttle, int brakepedal)
{
   	double fdist=0.0;
   	double fspeed=0.0;
   	int speed, distance;
	int *result;
   	speed=0;
   	distance=0;
	fspeed = fspeed+((throttle - fspeed*airResistance - 2*brakepedal))/ticksPerSecond;
	if (fspeed>maxSpeed) 
		fspeed=maxSpeed;
	if (fspeed<0)
		fspeed=0;
	fdist = fdist + (fspeed/36.0)/ticksPerSecond;
	speed = (int)fspeed;
	distance=(int)fdist;
	if (throttle>0.0) 
		throttle-=0.5/ticksPerSecond;
	if (throttle<0.0) 
		throttle=0;
  	result[0]=speed;
	result[1]=distance;
   	return result;
}","<mb:mutant#5629150452b6a26859c540fab0476c221d0f7896> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -99 +99 @@
-	fspeed = fspeed+((throttle - fspeed/airResistance - 2*brakepedal))/ticksPerSecond;
+	fspeed = fspeed+((throttle - fspeed*airResistance - 2*brakepedal))/ticksPerSecond;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Carsimulator.c> ."
488,"int *run(double throttle, int brakepedal)
{
   	double fdist=0.0;
   	double fspeed=0.0;
   	int speed, distance;
	int *result;
   	speed=0;
   	distance=0;
	fspeed = fspeed+((throttle - fspeed/airResistance - 2*brakepedal))/ticksPerSecond;
	if (fspeed>maxSpeed) 
		fspeed=maxSpeed;
	if (fspeed<0)
		fspeed=0;
	fdist = fdist + (fspeed/36.0)/ticksPerSecond;
	speed = (int)fspeed;
	distance=(int)fdist;
	if (throttle>=0.0)
		throttle-=0.5/ticksPerSecond;
	if (throttle<0.0) 
		throttle=0;
  	result[0]=speed;
	result[1]=distance;
   	return result;
}","<mb:mutant#7e528ef6ec4d0dfaaf76d73141f7e612b6e1ad2a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -109 +109 @@
-	if (throttle>0.0)
+	if (throttle>=0.0)
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Carsimulator.c> ."
489,"int *run(double throttle, int brakepedal)
{
   	double fdist=0.0;
   	double fspeed=0.0;
   	int speed, distance;
	int *result;
   	speed=0;
   	distance=0;
	fspeed = fspeed+((throttle - fspeed/airResistance - 2*brakepedal))/ticksPerSecond;
	if (fspeed>maxSpeed) 
		fspeed=maxSpeed;
	if (fspeed<0)
		fspeed=0;
	fdist = fdist + (fspeed/36.0)/ticksPerSecond;
	speed = (int)fspeed;
	distance=(int)fdist;
	if (throttle!=0.0)
		throttle-=0.5/ticksPerSecond;
	if (throttle<0.0) 
		throttle=0;
  	result[0]=speed;
	result[1]=distance;
   	return result;
}","<mb:mutant#13f568782a0b8dbd35076ebdb0ea5f36069982d7> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -109 +109 @@
-	if (throttle>0.0)
+	if (throttle!=0.0)
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Carsimulator.c> ."
490,"double setThrottle(double val) 
{
    double throttle=val++;
    if (throttle<0.0)
     	throttle=0.0;
    if (throttle>10.0) 
      	throttle=10.0;
    return throttle;
}","<mb:mutant#5041adf2eb3414b05e81fecdd028bfc3dd453cb7> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -125 +125 @@
-    double throttle=val;
+    double throttle=val++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Carsimulator.c> ."
491,"int *run(double throttle, int brakepedal)
{
   	double fdist=0.0;
   	double fspeed=0.0;
   	int speed, distance;
	int *result;
   	speed=0;
   	distance=0;
	fspeed = fspeed+((throttle - fspeed/airResistance - 2*brakepedal))/ticksPerSecond;
	if (fspeed>maxSpeed) 
		fspeed=maxSpeed;
	if (fspeed<0)
		fspeed=0;
	fdist = fdist + (fspeed/36.0)/ticksPerSecond;
	speed = (int)fspeed;
	distance=(int)fdist;
	if (throttle>0.0) 
		throttle-=0.5/ticksPerSecond;
	if (throttle<0.0) 
		throttle=0;
  	result[0]=speed;
	result[1]=distance;
   	return result--;
}","<mb:mutant#68d4668b1bec4b73b45761679741c5542d02de64> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -116 +116 @@
-   	return result;
+   	return result--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Carsimulator.c> ."
492,"int *run(double throttle, int brakepedal)
{
   	double fdist=0.0;
   	double fspeed=0.0;
   	int speed, distance;
	int *result;
   	speed=0;
   	distance=0;
	fspeed = fspeed+((throttle - fspeed/airResistance - 2*brakepedal--))/ticksPerSecond;
	if (fspeed>maxSpeed) 
		fspeed=maxSpeed;
	if (fspeed<0)
		fspeed=0;
	fdist = fdist + (fspeed/36.0)/ticksPerSecond;
	speed = (int)fspeed;
	distance=(int)fdist;
	if (throttle>0.0) 
		throttle-=0.5/ticksPerSecond;
	if (throttle<0.0) 
		throttle=0;
  	result[0]=speed;
	result[1]=distance;
   	return result;
}","<mb:mutant#faf176eee2141aee176f2d93067ca97d155d6ff3> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -99 +99 @@
-	fspeed = fspeed+((throttle - fspeed/airResistance - 2*brakepedal))/ticksPerSecond;
+	fspeed = fspeed+((throttle - fspeed/airResistance - 2*brakepedal--))/ticksPerSecond;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Carsimulator.c> ."
493,"int *run(double throttle, int brakepedal)
{
   	double fdist=0.0;
   	double fspeed=0.0;
   	int speed, distance;
	int *result;
   	speed=0;
   	distance=0;
	fspeed = fspeed+((throttle - ++fspeed/airResistance - 2*brakepedal))/ticksPerSecond;
	if (fspeed>maxSpeed) 
		fspeed=maxSpeed;
	if (fspeed<0)
		fspeed=0;
	fdist = fdist + (fspeed/36.0)/ticksPerSecond;
	speed = (int)fspeed;
	distance=(int)fdist;
	if (throttle>0.0) 
		throttle-=0.5/ticksPerSecond;
	if (throttle<0.0) 
		throttle=0;
  	result[0]=speed;
	result[1]=distance;
   	return result;
}","<mb:mutant#4121d5d0aad34a5da0770e469e84092d3e97a6b4> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -99 +99 @@
-	fspeed = fspeed+((throttle - fspeed/airResistance - 2*brakepedal))/ticksPerSecond;
+	fspeed = fspeed+((throttle - ++fspeed/airResistance - 2*brakepedal))/ticksPerSecond;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Carsimulator.c> ."
494,"int *run(double throttle, int brakepedal)
{
   	double fdist=0.0;
   	double fspeed=0.0;
   	int speed, distance;
	int *result;
   	speed=0;
   	distance=0;
	fspeed = fspeed+((throttle - fspeed/airResistance - 2*brakepedal))/ticksPerSecond;
	if (fspeed>maxSpeed) 
		fspeed=maxSpeed;
	if (fspeed<0)
		fspeed=0;
	fdist = fdist + (fspeed/36.0)/ticksPerSecond;
	speed = (int)fspeed;
	distance=(int)fdist--;
	if (throttle>0.0) 
		throttle-=0.5/ticksPerSecond;
	if (throttle<0.0) 
		throttle=0;
  	result[0]=speed;
	result[1]=distance;
   	return result;
}","<mb:mutant#725a5d4ec9487e0269599afa6238adc6a28dab91> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -107 +107 @@
-	distance=(int)fdist;
+	distance=(int)fdist--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Carsimulator.c> ."
495,"int *run(double throttle, int brakepedal)
{
   	double fdist=0.0;
   	double fspeed=0.0;
   	int speed, distance;
	int *result;
   	speed=0;
   	distance=0;
	fspeed = fspeed+((throttle - fspeed/airResistance - 2*brakepedal))/ticksPerSecond;
	if (fspeed>=maxSpeed)
		fspeed=maxSpeed;
	if (fspeed<0)
		fspeed=0;
	fdist = fdist + (fspeed/36.0)/ticksPerSecond;
	speed = (int)fspeed;
	distance=(int)fdist;
	if (throttle>0.0) 
		throttle-=0.5/ticksPerSecond;
	if (throttle<0.0) 
		throttle=0;
  	result[0]=speed;
	result[1]=distance;
   	return result;
}","<mb:mutant#cc39d2ac9c3d6dabc45cf724876901373d5a19a7> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -100 +100 @@
-	if (fspeed>maxSpeed)
+	if (fspeed>=maxSpeed)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Carsimulator.c> ."
496,"int *run(double throttle, int brakepedal)
{
   	double fdist=0.0;
   	double fspeed=0.0;
   	int speed, distance;
	int *result;
   	speed=0;
   	distance=0;
	fspeed = fspeed+((throttle - fspeed/airResistance - 2*brakepedal))/ticksPerSecond;
	if (fspeed>maxSpeed) 
		fspeed=maxSpeed;
	if (fspeed<0)
		fspeed=0;
	fdist = fdist * (fspeed/36.0)/ticksPerSecond;
	speed = (int)fspeed;
	distance=(int)fdist;
	if (throttle>0.0) 
		throttle-=0.5/ticksPerSecond;
	if (throttle<0.0) 
		throttle=0;
  	result[0]=speed;
	result[1]=distance;
   	return result;
}","<mb:mutant#9f2de1da8556f4ce3a83b67153fb7b58870f07ce> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -105 +105 @@
-	fdist = fdist + (fspeed/36.0)/ticksPerSecond;
+	fdist = fdist * (fspeed/36.0)/ticksPerSecond;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Carsimulator.c> ."
497,"int *run(double throttle, int brakepedal)
{
   	double fdist=0.0;
   	double fspeed=0.0;
   	int speed, distance;
	int *result;
   	speed=0;
   	distance=0;
	fspeed = fspeed+((throttle - fspeed/airResistance - 2*brakepedal))/ticksPerSecond;
	if (fspeed>maxSpeed) 
		fspeed=maxSpeed;
	if (fspeed<0)
		fspeed=0;
	fdist = fdist / (fspeed/36.0)/ticksPerSecond;
	speed = (int)fspeed;
	distance=(int)fdist;
	if (throttle>0.0) 
		throttle-=0.5/ticksPerSecond;
	if (throttle<0.0) 
		throttle=0;
  	result[0]=speed;
	result[1]=distance;
   	return result;
}","<mb:mutant#18fb4ea5212ac29a721c179d9c39ba402781d476> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -105 +105 @@
-	fdist = fdist + (fspeed/36.0)/ticksPerSecond;
+	fdist = fdist / (fspeed/36.0)/ticksPerSecond;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Carsimulator.c> ."
498,"double setThrottle(double val) 
{
    double throttle=val;
    if (throttle<0.0)
     	throttle=0.0;
    if (throttle>10.0) 
      	throttle=10.0;
    return throttle--;
}","<mb:mutant#3033f804931129829a6116b35f5d5ed1e10b90df> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -130 +130 @@
-    return throttle;
+    return throttle--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Carsimulator.c> ."
499,"int brake(int brakepedal) 
{
	if (brakepedal<(maxBrake*1))
		brakepedal =brakepedal+1;
	else
		brakepedal=maxBrake;
	return brakepedal;
}","<mb:mutant#9d1c2f82d6ed4b4cb3fe7787e8f350e46f1dac16> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -75 +75 @@
-	if (brakepedal<(maxBrake-1))
+	if (brakepedal<(maxBrake*1))
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Carsimulator.c> ."
500,"int *run(double throttle, int brakepedal)
{
   	double fdist=0.0;
   	double fspeed=0.0;
   	int speed, distance;
	int *result;
   	speed=0;
   	distance=0;
	fspeed = fspeed+((throttle - fspeed/airResistance - 2*brakepedal))/ticksPerSecond;
	if (fspeed>maxSpeed) 
		fspeed=maxSpeed;
	if (fspeed<=0)
		fspeed=0;
	fdist = fdist + (fspeed/36.0)/ticksPerSecond;
	speed = (int)fspeed;
	distance=(int)fdist;
	if (throttle>0.0) 
		throttle-=0.5/ticksPerSecond;
	if (throttle<0.0) 
		throttle=0;
  	result[0]=speed;
	result[1]=distance;
   	return result;
}","<mb:mutant#9fe003d5a378ecaf5fbb4e988a2bbafcba019b2b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -102 +102 @@
-	if (fspeed<0)
+	if (fspeed<=0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Carsimulator.c> ."
501,"bool Non_Crossing_Biased_Descend()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Down_Separation >= ALIM());
    }
    else
    {
	result = !(Own_Above_Threat()) || ((Own_Above_Threat()) && (Up_Separation >= ALIM()));
    }
    return result;
}",
502,"bool Non_Crossing_Biased_Descend()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Down_Separation <= ALIM());
    }
    else
    {
	result = !(Own_Above_Threat()) || ((Own_Above_Threat()) && (Up_Separation >= ALIM()));
    }
    return result;
}","<mb:mutant#d6f331eb22ba5fa8cd767905f129345ab0a6c381> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -93 +93 @@
-	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Down_Separation >= ALIM());
+	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Down_Separation <= ALIM());
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Tcas.c> ."
503,"bool Non_Crossing_Biased_Descend()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = Own_Below_Threat() && (Cur_Vertical_Sep >= abs(MINSEP)) && (Down_Separation >= ALIM());
    }
    else
    {
	result = !(Own_Above_Threat()) || ((Own_Above_Threat()) && (Up_Separation >= ALIM()));
    }
    return result;
}","<mb:mutant#5b4a7bb501d248e914391b223170bdd17e5b5408> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -93 +93 @@
-	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Down_Separation >= ALIM());
+	result = Own_Below_Threat() && (Cur_Vertical_Sep >= abs(MINSEP)) && (Down_Separation >= ALIM());
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Tcas.c> ."
504,"bool Non_Crossing_Biased_Descend()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Down_Separation > ALIM());
    }
    else
    {
	result = !(Own_Above_Threat()) || ((Own_Above_Threat()) && (Up_Separation >= ALIM()));
    }
    return result;
}","<mb:mutant#1c8cf8c8b7d2e07f2492eda43b284b6478d4e889> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -93 +93 @@
-	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Down_Separation >= ALIM());
+	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Down_Separation > ALIM());
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Tcas.c> ."
505,"bool Non_Crossing_Biased_Climb()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(Down_Separation >= ALIM())));
    }
    else
    {
	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation >= ALIM());
    }
    return result;
}",
506,"bool Non_Crossing_Biased_Climb()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(Down_Separation >= ALIM())));
    }
    else
    {
	result = Own_Above_Threat() && (Cur_Vertical_Sep < MINSEP) && (Up_Separation >= ALIM());
    }
    return result;
}","<mb:mutant#0212f618eab3ba791c2cb97aafc0bea681211907> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -79 +79 @@
-	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation >= ALIM());
+	result = Own_Above_Threat() && (Cur_Vertical_Sep < MINSEP) && (Up_Separation >= ALIM());
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Tcas.c> ."
507,"bool Non_Crossing_Biased_Climb()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(Down_Separation > ALIM())));
    }
    else
    {
	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation >= ALIM());
    }
    return result;
}","<mb:mutant#3bfa0bb8e778b786a3f25e2a3cbbf30f73c71278> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -75 +75 @@
-	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(Down_Separation >= ALIM())));
+	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(Down_Separation > ALIM())));
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Tcas.c> ."
508,"int alt_sep_test()
{
    bool enabled, tcas_equipped, intent_not_known;
    bool need_upward_RA, need_downward_RA;
    int alt_sep;
    enabled = High_Confidence && (Own_Tracked_Alt_Rate <= OLEV) && (Cur_Vertical_Sep > MAXALTDIFF);
    tcas_equipped = Other_Capability == TCAS_TA;
    intent_not_known = Two_of_Three_Reports_Valid && Other_RAC == NO_INTENT;
    alt_sep = UNRESOLVED;
    if (enabled && ((tcas_equipped && intent_not_known) || !tcas_equipped))
    {
	need_upward_RA = Non_Crossing_Biased_Climb() && Own_Below_Threat();
	need_downward_RA = Non_Crossing_Biased_Descend() && Own_Above_Threat();
	if (need_upward_RA && need_downward_RA)
	    alt_sep = UNRESOLVED;
	else if (need_upward_RA)
	    alt_sep = UPWARD_RA;
	else if (need_downward_RA)
	    alt_sep = DOWNWARD_RA;
	else
	    alt_sep = UNRESOLVED;
    }
    return alt_sep;
}",
509,"int alt_sep_test()
{
    bool enabled, tcas_equipped, intent_not_known;
    bool need_upward_RA, need_downward_RA;
    int alt_sep;
    enabled = High_Confidence && (Own_Tracked_Alt_Rate <= OLEV) && (Cur_Vertical_Sep > MAXALTDIFF);
    tcas_equipped = Other_Capability == TCAS_TA;
    intent_not_known = Two_of_Three_Reports_Valid && --Other_RAC == NO_INTENT;
    alt_sep = UNRESOLVED;
    if (enabled && ((tcas_equipped && intent_not_known) || !tcas_equipped))
    {
	need_upward_RA = Non_Crossing_Biased_Climb() && Own_Below_Threat();
	need_downward_RA = Non_Crossing_Biased_Descend() && Own_Above_Threat();
	if (need_upward_RA && need_downward_RA)
	    alt_sep = UNRESOLVED;
	else if (need_upward_RA)
	    alt_sep = UPWARD_RA;
	else if (need_downward_RA)
	    alt_sep = DOWNWARD_RA;
	else
	    alt_sep = UNRESOLVED;
    }
    return alt_sep;
}","<mb:mutant#55a2fb8429e1c64293ba07e8e57a93f1784073fd> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -120 +120 @@
-    intent_not_known = Two_of_Three_Reports_Valid && Other_RAC == NO_INTENT;
+    intent_not_known = Two_of_Three_Reports_Valid && --Other_RAC == NO_INTENT;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
510,"bool Non_Crossing_Biased_Climb()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(Down_Separation >= ALIM())));
    }
    else
    {
	result = Own_Above_Threat() && (++Cur_Vertical_Sep >= MINSEP) && (Up_Separation >= ALIM());
    }
    return result;
}","<mb:mutant#e40fb60275962acf0b9cc029716517fc7d6ad76e> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -79 +79 @@
-	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation >= ALIM());
+	result = Own_Above_Threat() && (++Cur_Vertical_Sep >= MINSEP) && (Up_Separation >= ALIM());
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
511,"bool Non_Crossing_Biased_Climb()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(Down_Separation >= ALIM())));
    }
    else
    {
	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (++Up_Separation >= ALIM());
    }
    return result;
}","<mb:mutant#73e505c7dd2715b1bcd200eb35ccb934fe92736d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -79 +79 @@
-	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation >= ALIM());
+	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (++Up_Separation >= ALIM());
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
512,"int Inhibit_Biased_Climb ()
{
    return (Climb_Inhibit ? Up_Separation + NOZCROSS : Up_Separation);
}",
513,"int Inhibit_Biased_Climb ()
{
    return (Climb_Inhibit ? Up_Separation + NOZCROSS : abs(Up_Separation));
}","<mb:mutant#ddd0f324c72d371ec7f3a458fbafbdf1a21d2f66> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -63 +63 @@
-    return (Climb_Inhibit ? Up_Separation + NOZCROSS : Up_Separation);
+    return (Climb_Inhibit ? Up_Separation + NOZCROSS : abs(Up_Separation));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Tcas.c> ."
514,"int alt_sep_test()
{
    bool enabled, tcas_equipped, intent_not_known;
    bool need_upward_RA, need_downward_RA;
    int alt_sep;
    enabled = High_Confidence && (Own_Tracked_Alt_Rate <= abs(OLEV)) && (Cur_Vertical_Sep > MAXALTDIFF);
    tcas_equipped = Other_Capability == TCAS_TA;
    intent_not_known = Two_of_Three_Reports_Valid && Other_RAC == NO_INTENT;
    alt_sep = UNRESOLVED;
    if (enabled && ((tcas_equipped && intent_not_known) || !tcas_equipped))
    {
	need_upward_RA = Non_Crossing_Biased_Climb() && Own_Below_Threat();
	need_downward_RA = Non_Crossing_Biased_Descend() && Own_Above_Threat();
	if (need_upward_RA && need_downward_RA)
	    alt_sep = UNRESOLVED;
	else if (need_upward_RA)
	    alt_sep = UPWARD_RA;
	else if (need_downward_RA)
	    alt_sep = DOWNWARD_RA;
	else
	    alt_sep = UNRESOLVED;
    }
    return alt_sep;
}","<mb:mutant#1f31fe8f485298866cf4118137436cb366cacb8c> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -118 +118 @@
-    enabled = High_Confidence && (Own_Tracked_Alt_Rate <= OLEV) && (Cur_Vertical_Sep > MAXALTDIFF);
+    enabled = High_Confidence && (Own_Tracked_Alt_Rate <= abs(OLEV)) && (Cur_Vertical_Sep > MAXALTDIFF);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Tcas.c> ."
515,"bool Non_Crossing_Biased_Climb()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(Down_Separation >= ALIM())));
    }
    else
    {
	result = Own_Above_Threat() && (Cur_Vertical_Sep <= MINSEP) && (Up_Separation >= ALIM());
    }
    return result;
}","<mb:mutant#9458a3315ad7bc27e4002407b0f20260b523f4f3> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -79 +79 @@
-	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation >= ALIM());
+	result = Own_Above_Threat() && (Cur_Vertical_Sep <= MINSEP) && (Up_Separation >= ALIM());
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Tcas.c> ."
516,"bool Non_Crossing_Biased_Climb()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(Down_Separation >= ALIM())));
    }
    else
    {
	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation <= ALIM());
    }
    return result;
}","<mb:mutant#4962f53ded2a5835054cc82cffab50f7ec268307> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -79 +79 @@
-	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation >= ALIM());
+	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation <= ALIM());
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Tcas.c> ."
517,"bool Own_Above_Threat()
{
    return (Other_Tracked_Alt < Own_Tracked_Alt);
}",
518,"bool Own_Above_Threat()
{
    return (Other_Tracked_Alt != Own_Tracked_Alt);
}","<mb:mutant#95525fd9d5305aaaec9adb70bdc29522015c0af0> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -109 +109 @@
-    return (Other_Tracked_Alt < Own_Tracked_Alt);
+    return (Other_Tracked_Alt != Own_Tracked_Alt);
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Tcas.c> ."
519,"int Inhibit_Biased_Climb ()
{
    return (Climb_Inhibit ? Up_Separation + abs(NOZCROSS) : Up_Separation);
}","<mb:mutant#e9fa856acbe58e698fa4a8eec8a17a2d5d6b8d6b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -63 +63 @@
-    return (Climb_Inhibit ? Up_Separation + NOZCROSS : Up_Separation);
+    return (Climb_Inhibit ? Up_Separation + abs(NOZCROSS) : Up_Separation);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Tcas.c> ."
520,"bool Non_Crossing_Biased_Descend()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) || (Down_Separation >= ALIM());
    }
    else
    {
	result = !(Own_Above_Threat()) || ((Own_Above_Threat()) && (Up_Separation >= ALIM()));
    }
    return result;
}","<mb:mutant#3b0e8bef657348d9a8e34ee64cb0d1fdd7a7b471> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -93 +93 @@
-	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Down_Separation >= ALIM());
+	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) || (Down_Separation >= ALIM());
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#SEOR> ;
    mb:program <mb:program#Tcas.c> ."
521,"bool Non_Crossing_Biased_Climb()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > abs(Down_Separation);
    if (upward_preferred)
    {
	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(Down_Separation >= ALIM())));
    }
    else
    {
	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation >= ALIM());
    }
    return result;
}","<mb:mutant#37cb250397c27516c1a34fc5afd242bfa5ca40e8> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -72 +72 @@
-    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
+    upward_preferred = Inhibit_Biased_Climb() > abs(Down_Separation);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Tcas.c> ."
522,"int Inhibit_Biased_Climb ()
{
    return (Climb_Inhibit ? ++Up_Separation + NOZCROSS : Up_Separation);
}","<mb:mutant#4cd010a447f9c8165256a5f66b73ad913dc72326> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -63 +63 @@
-    return (Climb_Inhibit ? Up_Separation + NOZCROSS : Up_Separation);
+    return (Climb_Inhibit ? ++Up_Separation + NOZCROSS : Up_Separation);
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
523,"int alt_sep_test()
{
    bool enabled, tcas_equipped, intent_not_known;
    bool need_upward_RA, need_downward_RA;
    int alt_sep;
    enabled = High_Confidence && (++Own_Tracked_Alt_Rate < OLEV) && (Cur_Vertical_Sep > MAXALTDIFF);
    tcas_equipped = Other_Capability == TCAS_TA;
    intent_not_known = Two_of_Three_Reports_Valid && Other_RAC == NO_INTENT;
    alt_sep = UNRESOLVED;
    if (enabled && ((tcas_equipped && intent_not_known) || !tcas_equipped))
    {
	need_upward_RA = Non_Crossing_Biased_Climb() && Own_Below_Threat();
	need_downward_RA = Non_Crossing_Biased_Descend() && Own_Above_Threat();
	if (need_upward_RA && need_downward_RA)
	    alt_sep = UNRESOLVED;
	else if (need_upward_RA)
	    alt_sep = UPWARD_RA;
	else if (need_downward_RA)
	    alt_sep = DOWNWARD_RA;
	else
	    alt_sep = UNRESOLVED;
    }
    return alt_sep;
}","<mb:mutant#39c4f4d4716e0189263fe98b2376317f1c7b8b1a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -118 +118 @@
-    enabled = High_Confidence && (Own_Tracked_Alt_Rate <= OLEV) && (Cur_Vertical_Sep > MAXALTDIFF);
+    enabled = High_Confidence && (++Own_Tracked_Alt_Rate < OLEV) && (Cur_Vertical_Sep > MAXALTDIFF);
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS>,
        <mb:operator#ROR> ;
    mb:program <mb:program#Tcas.c> ."
524,"int alt_sep_test()
{
    bool enabled, tcas_equipped, intent_not_known;
    bool need_upward_RA, need_downward_RA;
    int alt_sep;
    enabled = High_Confidence && (Own_Tracked_Alt_Rate <= OLEV) && (Cur_Vertical_Sep > MAXALTDIFF);
    tcas_equipped = Other_Capability == TCAS_TA;
    intent_not_known = Two_of_Three_Reports_Valid || Other_RAC == NO_INTENT;
    alt_sep = UNRESOLVED;
    if (enabled && ((tcas_equipped && intent_not_known) || !tcas_equipped))
    {
	need_upward_RA = Non_Crossing_Biased_Climb() && Own_Below_Threat();
	need_downward_RA = Non_Crossing_Biased_Descend() && Own_Above_Threat();
	if (need_upward_RA && need_downward_RA)
	    alt_sep = UNRESOLVED;
	else if (need_upward_RA)
	    alt_sep = UPWARD_RA;
	else if (need_downward_RA)
	    alt_sep = DOWNWARD_RA;
	else
	    alt_sep = UNRESOLVED;
    }
    return alt_sep;
}","<mb:mutant#215a2bc80af55aa2e6368180844dd295cfdd60f5> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -120 +120 @@
-    intent_not_known = Two_of_Three_Reports_Valid && Other_RAC == NO_INTENT;
+    intent_not_known = Two_of_Three_Reports_Valid || Other_RAC == NO_INTENT;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#SEOR> ;
    mb:program <mb:program#Tcas.c> ."
525,"bool Non_Crossing_Biased_Climb()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > ++Down_Separation;
    if (upward_preferred)
    {
	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(Down_Separation >= ALIM())));
    }
    else
    {
	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation >= ALIM());
    }
    return result;
}","<mb:mutant#a504d136e49afb3f9992e55c1fdda270beea1074> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -72 +72 @@
-    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
+    upward_preferred = Inhibit_Biased_Climb() > ++Down_Separation;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
526,"bool Own_Below_Threat()
{
    return (Own_Tracked_Alt < Other_Tracked_Alt);
}",
527,"bool Own_Below_Threat()
{
    return (--Own_Tracked_Alt < Other_Tracked_Alt);
}","<mb:mutant#18c9583c8a3f4d89a28601e97676afdcc24eee37> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -104 +104 @@
-    return (Own_Tracked_Alt < Other_Tracked_Alt);
+    return (--Own_Tracked_Alt < Other_Tracked_Alt);
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
528,"bool Own_Above_Threat()
{
    return (++Other_Tracked_Alt < Own_Tracked_Alt);
}","<mb:mutant#0b1100629e68641ac4a4a3151758cde89afe2ba2> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -109 +109 @@
-    return (Other_Tracked_Alt < Own_Tracked_Alt);
+    return (++Other_Tracked_Alt < Own_Tracked_Alt);
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
529,"bool Non_Crossing_Biased_Descend()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > ++Down_Separation;
    if (upward_preferred)
    {
	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Down_Separation >= ALIM());
    }
    else
    {
	result = !(Own_Above_Threat()) || ((Own_Above_Threat()) && (Up_Separation >= ALIM()));
    }
    return result;
}","<mb:mutant#af568cb9b9c5859e88b16bad07d9e818d5f8e3d0> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -90 +90 @@
-    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
+    upward_preferred = Inhibit_Biased_Climb() > ++Down_Separation;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
530,"bool Non_Crossing_Biased_Climb()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(++Down_Separation >= ALIM())));
    }
    else
    {
	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation >= ALIM());
    }
    return result;
}","<mb:mutant#016520a7047332f7d47163bef7b3f11807010467> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -75 +75 @@
-	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(Down_Separation >= ALIM())));
+	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(++Down_Separation >= ALIM())));
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
531,"bool Own_Above_Threat()
{
    return (Other_Tracked_Alt < --Own_Tracked_Alt);
}","<mb:mutant#14455124345cc2c5cae3c76a4e4ee7016b2d0e4a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -109 +109 @@
-    return (Other_Tracked_Alt < Own_Tracked_Alt);
+    return (Other_Tracked_Alt < --Own_Tracked_Alt);
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
532,"int Inhibit_Biased_Climb ()
{
    return (Climb_Inhibit ? Up_Separation-- + NOZCROSS : Up_Separation);
}","<mb:mutant#d2558d491959e4fc00d790a82806012940aa7011> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -63 +63 @@
-    return (Climb_Inhibit ? Up_Separation + NOZCROSS : Up_Separation);
+    return (Climb_Inhibit ? Up_Separation-- + NOZCROSS : Up_Separation);
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
533,"bool Non_Crossing_Biased_Descend()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Down_Separation < ALIM());
    }
    else
    {
	result = !(Own_Above_Threat()) || ((Own_Above_Threat()) && (Up_Separation >= ALIM()));
    }
    return result;
}","<mb:mutant#4b95996b865faa5ae2b7e3cf0917e82c222884fe> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -93 +93 @@
-	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Down_Separation >= ALIM());
+	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Down_Separation < ALIM());
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Tcas.c> ."
534,"bool Non_Crossing_Biased_Climb()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(Down_Separation >= ALIM())));
    }
    else
    {
	result = Own_Above_Threat() && (Cur_Vertical_Sep >= abs(MINSEP)) && (Up_Separation >= ALIM());
    }
    return result;
}","<mb:mutant#c42e7f3d82e8982ed5f7343c595afad28f96312c> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -79 +79 @@
-	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation >= ALIM());
+	result = Own_Above_Threat() && (Cur_Vertical_Sep >= abs(MINSEP)) && (Up_Separation >= ALIM());
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Tcas.c> ."
535,"int alt_sep_test()
{
    bool enabled, tcas_equipped, intent_not_known;
    bool need_upward_RA, need_downward_RA;
    int alt_sep;
    enabled = High_Confidence && (Own_Tracked_Alt_Rate <= OLEV) && (Cur_Vertical_Sep > MAXALTDIFF);
    tcas_equipped = Other_Capability == TCAS_TA;
    intent_not_known = Two_of_Three_Reports_Valid && Other_RAC > NO_INTENT;
    alt_sep = UNRESOLVED;
    if (enabled && ((tcas_equipped && intent_not_known) || !tcas_equipped))
    {
	need_upward_RA = Non_Crossing_Biased_Climb() && Own_Below_Threat();
	need_downward_RA = Non_Crossing_Biased_Descend() && Own_Above_Threat();
	if (need_upward_RA && need_downward_RA)
	    alt_sep = UNRESOLVED;
	else if (need_upward_RA)
	    alt_sep = UPWARD_RA;
	else if (need_downward_RA)
	    alt_sep = DOWNWARD_RA;
	else
	    alt_sep = UNRESOLVED;
    }
    return alt_sep;
}","<mb:mutant#2063bbfb0e853b1d4ad1e61f05b0f6e77e32165b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -120 +120 @@
-    intent_not_known = Two_of_Three_Reports_Valid && Other_RAC == NO_INTENT;
+    intent_not_known = Two_of_Three_Reports_Valid && Other_RAC > NO_INTENT;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Tcas.c> ."
536,"int alt_sep_test()
{
    bool enabled, tcas_equipped, intent_not_known;
    bool need_upward_RA, need_downward_RA;
    int alt_sep;
    enabled = High_Confidence && (Own_Tracked_Alt_Rate <= OLEV) && (abs(Cur_Vertical_Sep) > MAXALTDIFF);
    tcas_equipped = Other_Capability == TCAS_TA;
    intent_not_known = Two_of_Three_Reports_Valid && Other_RAC == NO_INTENT;
    alt_sep = UNRESOLVED;
    if (enabled && ((tcas_equipped && intent_not_known) || !tcas_equipped))
    {
	need_upward_RA = Non_Crossing_Biased_Climb() && Own_Below_Threat();
	need_downward_RA = Non_Crossing_Biased_Descend() && Own_Above_Threat();
	if (need_upward_RA && need_downward_RA)
	    alt_sep = UNRESOLVED;
	else if (need_upward_RA)
	    alt_sep = UPWARD_RA;
	else if (need_downward_RA)
	    alt_sep = DOWNWARD_RA;
	else
	    alt_sep = UNRESOLVED;
    }
    return alt_sep;
}","<mb:mutant#6c8d5bda1cd9f38925ffde75b02dc5486677f4c1> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -118 +118 @@
-    enabled = High_Confidence && (Own_Tracked_Alt_Rate <= OLEV) && (Cur_Vertical_Sep > MAXALTDIFF);
+    enabled = High_Confidence && (Own_Tracked_Alt_Rate <= OLEV) && (abs(Cur_Vertical_Sep) > MAXALTDIFF);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Tcas.c> ."
537,"int Inhibit_Biased_Climb ()
{
    return (Climb_Inhibit ? Up_Separation + NOZCROSS : ++Up_Separation);
}","<mb:mutant#2b0c10a9767f4e2492813a0f975bf8d8c497950e> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -63 +63 @@
-    return (Climb_Inhibit ? Up_Separation + NOZCROSS : Up_Separation);
+    return (Climb_Inhibit ? Up_Separation + NOZCROSS : ++Up_Separation);
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
538,"bool Non_Crossing_Biased_Climb()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > --Down_Separation;
    if (upward_preferred)
    {
	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(Down_Separation >= ALIM())));
    }
    else
    {
	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation >= ALIM());
    }
    return result;
}","<mb:mutant#46749644f526d4c095093ee9b0013980477cf6f1> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -72 +72 @@
-    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
+    upward_preferred = Inhibit_Biased_Climb() > --Down_Separation;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
539,"bool Non_Crossing_Biased_Climb()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation++;
    if (upward_preferred)
    {
	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(Down_Separation >= ALIM())));
    }
    else
    {
	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation >= ALIM());
    }
    return result;
}","<mb:mutant#5e6ee73c485acb4eeb1134082b66d486ab958a3e> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -72 +72 @@
-    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
+    upward_preferred = Inhibit_Biased_Climb() > Down_Separation++;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
540,"bool Non_Crossing_Biased_Descend()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = Own_Below_Threat() || (Cur_Vertical_Sep >= MINSEP) && (Down_Separation >= ALIM());
    }
    else
    {
	result = !(Own_Above_Threat()) || ((Own_Above_Threat()) && (Up_Separation >= ALIM()));
    }
    return result;
}","<mb:mutant#a26675bca31083728cdfd6fbab5ce95b8cb76330> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -93 +93 @@
-	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Down_Separation >= ALIM());
+	result = Own_Below_Threat() || (Cur_Vertical_Sep >= MINSEP) && (Down_Separation >= ALIM());
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#SEOD> ;
    mb:program <mb:program#Tcas.c> ."
541,"int Inhibit_Biased_Climb ()
{
    return (Climb_Inhibit ? --Up_Separation + NOZCROSS : Up_Separation);
}","<mb:mutant#ff42f23ee856c29d478f9fa051bbbd07bac379b4> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -63 +63 @@
-    return (Climb_Inhibit ? Up_Separation + NOZCROSS : Up_Separation);
+    return (Climb_Inhibit ? --Up_Separation + NOZCROSS : Up_Separation);
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
542,"int alt_sep_test()
{
    bool enabled, tcas_equipped, intent_not_known;
    bool need_upward_RA, need_downward_RA;
    int alt_sep;
    enabled = High_Confidence && (Own_Tracked_Alt_Rate <= OLEV) && (Cur_Vertical_Sep > MAXALTDIFF);
    tcas_equipped = Other_Capability == TCAS_TA;
    intent_not_known = Two_of_Three_Reports_Valid && Other_RAC >= NO_INTENT;
    alt_sep = UNRESOLVED;
    if (enabled && ((tcas_equipped && intent_not_known) || !tcas_equipped))
    {
	need_upward_RA = Non_Crossing_Biased_Climb() && Own_Below_Threat();
	need_downward_RA = Non_Crossing_Biased_Descend() && Own_Above_Threat();
	if (need_upward_RA && need_downward_RA)
	    alt_sep = UNRESOLVED;
	else if (need_upward_RA)
	    alt_sep = UPWARD_RA;
	else if (need_downward_RA)
	    alt_sep = DOWNWARD_RA;
	else
	    alt_sep = UNRESOLVED;
    }
    return alt_sep;
}","<mb:mutant#413aa267f7fbd9756fc24aba494f8e6a7cd910e3> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -120 +120 @@
-    intent_not_known = Two_of_Three_Reports_Valid && Other_RAC == NO_INTENT;
+    intent_not_known = Two_of_Three_Reports_Valid && Other_RAC >= NO_INTENT;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Tcas.c> ."
543,"int ALIM ()
{
 return Positive_RA_Alt_Thresh[Alt_Layer_Value];
}",
544,"int ALIM ()
{
 return Positive_RA_Alt_Thresh[--Alt_Layer_Value];
}","<mb:mutant#5369040a04211b51adb9a16283b7039dff07dd65> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -58 +58 @@
- return Positive_RA_Alt_Thresh[Alt_Layer_Value];
+ return Positive_RA_Alt_Thresh[--Alt_Layer_Value];
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
545,"int alt_sep_test()
{
    bool enabled, tcas_equipped, intent_not_known;
    bool need_upward_RA, need_downward_RA;
    int alt_sep;
    enabled = High_Confidence && (Own_Tracked_Alt_Rate <= OLEV) && (Cur_Vertical_Sep > MAXALTDIFF);
    tcas_equipped = Other_Capability == TCAS_TA;
    intent_not_known = Two_of_Three_Reports_Valid && Other_RAC == NO_INTENT;
    alt_sep = UNRESOLVED;
    if (enabled && ((tcas_equipped && intent_not_known) || !tcas_equipped))
    {
	need_upward_RA = Non_Crossing_Biased_Climb() && Own_Below_Threat();
	need_downward_RA = Non_Crossing_Biased_Descend() && Own_Above_Threat();
	if (need_upward_RA && need_downward_RA)
	    alt_sep = UNRESOLVED;
	else if (need_upward_RA)
	    alt_sep = UPWARD_RA;
	else if (need_downward_RA)
	    alt_sep = DOWNWARD_RA;
	else
	    alt_sep = UNRESOLVED;
    }
    return abs(alt_sep);
}","<mb:mutant#e41004af9a60d4fbcddc0e76704bdbd5b9d0115c> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -141 +141 @@
-    return alt_sep;
+    return abs(alt_sep);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Tcas.c> ."
546,"bool Non_Crossing_Biased_Descend()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > abs(Down_Separation);
    if (upward_preferred)
    {
	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Down_Separation >= ALIM());
    }
    else
    {
	result = !(Own_Above_Threat()) || ((Own_Above_Threat()) && (Up_Separation >= ALIM()));
    }
    return result;
}","<mb:mutant#64129fef42e47a0a710a7121a613b52f38f395e6> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -90 +90 @@
-    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
+    upward_preferred = Inhibit_Biased_Climb() > abs(Down_Separation);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Tcas.c> ."
547,"bool Non_Crossing_Biased_Climb()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() != Down_Separation;
    if (upward_preferred)
    {
	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(Down_Separation >= ALIM())));
    }
    else
    {
	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation >= ALIM());
    }
    return result;
}","<mb:mutant#86f9f7f13d096ed159356db35d34319c00b6dc16> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -72 +72 @@
-    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
+    upward_preferred = Inhibit_Biased_Climb() != Down_Separation;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Tcas.c> ."
548,"bool Non_Crossing_Biased_Descend()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = Own_Below_Threat() && (++Cur_Vertical_Sep >= MINSEP) && (Down_Separation >= ALIM());
    }
    else
    {
	result = !(Own_Above_Threat()) || ((Own_Above_Threat()) && (Up_Separation >= ALIM()));
    }
    return result;
}","<mb:mutant#0daaec2806a15840fa4fee727a36d978845ee255> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -93 +93 @@
-	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Down_Separation >= ALIM());
+	result = Own_Below_Threat() && (++Cur_Vertical_Sep >= MINSEP) && (Down_Separation >= ALIM());
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
549,"bool Non_Crossing_Biased_Descend()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Down_Separation >= ALIM());
    }
    else
    {
	result = !(Own_Above_Threat()) || ((Own_Above_Threat()) && (abs(Up_Separation) >= ALIM()));
    }
    return result;
}","<mb:mutant#1e822f07f40ce2edc60a62b1cd054a743312cc02> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -97 +97 @@
-	result = !(Own_Above_Threat()) || ((Own_Above_Threat()) && (Up_Separation >= ALIM()));
+	result = !(Own_Above_Threat()) || ((Own_Above_Threat()) && (abs(Up_Separation) >= ALIM()));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Tcas.c> ."
550,"bool Non_Crossing_Biased_Climb()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(Down_Separation >= ALIM())));
    }
    else
    {
	result = Own_Above_Threat() && (Cur_Vertical_Sep > MINSEP) && (Up_Separation >= ALIM());
    }
    return result;
}","<mb:mutant#fc5de9564aecb9ca40f16e2252292cdee31ed1cc> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -79 +79 @@
-	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation >= ALIM());
+	result = Own_Above_Threat() && (Cur_Vertical_Sep > MINSEP) && (Up_Separation >= ALIM());
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Tcas.c> ."
551,"int alt_sep_test()
{
    bool enabled, tcas_equipped, intent_not_known;
    bool need_upward_RA, need_downward_RA;
    int alt_sep;
    enabled = High_Confidence && (abs(Own_Tracked_Alt_Rate) <= OLEV) && (Cur_Vertical_Sep > MAXALTDIFF);
    tcas_equipped = Other_Capability == TCAS_TA;
    intent_not_known = Two_of_Three_Reports_Valid && Other_RAC == NO_INTENT;
    alt_sep = UNRESOLVED;
    if (enabled && ((tcas_equipped && intent_not_known) || !tcas_equipped))
    {
	need_upward_RA = Non_Crossing_Biased_Climb() && Own_Below_Threat();
	need_downward_RA = Non_Crossing_Biased_Descend() && Own_Above_Threat();
	if (need_upward_RA && need_downward_RA)
	    alt_sep = UNRESOLVED;
	else if (need_upward_RA)
	    alt_sep = UPWARD_RA;
	else if (need_downward_RA)
	    alt_sep = DOWNWARD_RA;
	else
	    alt_sep = UNRESOLVED;
    }
    return alt_sep;
}","<mb:mutant#822e91e1af36f371dce674d31d71b9d4f55ea44f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -118 +118 @@
-    enabled = High_Confidence && (Own_Tracked_Alt_Rate <= OLEV) && (Cur_Vertical_Sep > MAXALTDIFF);
+    enabled = High_Confidence && (abs(Own_Tracked_Alt_Rate) <= OLEV) && (Cur_Vertical_Sep > MAXALTDIFF);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Tcas.c> ."
552,"bool Non_Crossing_Biased_Climb()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) || (!(Down_Separation >= ALIM())));
    }
    else
    {
	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation >= ALIM());
    }
    return result;
}","<mb:mutant#5bea935a25b9dd884ab57ad49eafb4913e86f704> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -75 +75 @@
-	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(Down_Separation >= ALIM())));
+	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) || (!(Down_Separation >= ALIM())));
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#SEOR> ;
    mb:program <mb:program#Tcas.c> ."
553,"bool Own_Above_Threat()
{
    return (Other_Tracked_Alt < abs(Own_Tracked_Alt));
}","<mb:mutant#0ff5bb83bff8fdbfdb3aeff3a5314e8f610df7bc> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -109 +109 @@
-    return (Other_Tracked_Alt < Own_Tracked_Alt);
+    return (Other_Tracked_Alt < abs(Own_Tracked_Alt));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Tcas.c> ."
554,"int alt_sep_test()
{
    bool enabled, tcas_equipped, intent_not_known;
    bool need_upward_RA, need_downward_RA;
    int alt_sep;
    enabled = abs(High_Confidence) && (Own_Tracked_Alt_Rate <= OLEV) && (Cur_Vertical_Sep > MAXALTDIFF);
    tcas_equipped = Other_Capability == TCAS_TA;
    intent_not_known = Two_of_Three_Reports_Valid && Other_RAC == NO_INTENT;
    alt_sep = UNRESOLVED;
    if (enabled && ((tcas_equipped && intent_not_known) || !tcas_equipped))
    {
	need_upward_RA = Non_Crossing_Biased_Climb() && Own_Below_Threat();
	need_downward_RA = Non_Crossing_Biased_Descend() && Own_Above_Threat();
	if (need_upward_RA && need_downward_RA)
	    alt_sep = UNRESOLVED;
	else if (need_upward_RA)
	    alt_sep = UPWARD_RA;
	else if (need_downward_RA)
	    alt_sep = DOWNWARD_RA;
	else
	    alt_sep = UNRESOLVED;
    }
    return alt_sep;
}","<mb:mutant#a574da49b95e7df3e4596fd6da911f3eac0ac3bd> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -118 +118 @@
-    enabled = High_Confidence && (Own_Tracked_Alt_Rate <= OLEV) && (Cur_Vertical_Sep > MAXALTDIFF);
+    enabled = abs(High_Confidence) && (Own_Tracked_Alt_Rate <= OLEV) && (Cur_Vertical_Sep > MAXALTDIFF);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Tcas.c> ."
555,"int alt_sep_test()
{
    bool enabled, tcas_equipped, intent_not_known;
    bool need_upward_RA, need_downward_RA;
    int alt_sep;
    enabled = High_Confidence && (Own_Tracked_Alt_Rate < OLEV) && (++Cur_Vertical_Sep > MAXALTDIFF);
    tcas_equipped = Other_Capability == TCAS_TA;
    intent_not_known = Two_of_Three_Reports_Valid && Other_RAC == NO_INTENT;
    alt_sep = UNRESOLVED;
    if (enabled && ((tcas_equipped && intent_not_known) || !tcas_equipped))
    {
	need_upward_RA = Non_Crossing_Biased_Climb() && Own_Below_Threat();
	need_downward_RA = Non_Crossing_Biased_Descend() && Own_Above_Threat();
	if (need_upward_RA && need_downward_RA)
	    alt_sep = UNRESOLVED;
	else if (need_upward_RA)
	    alt_sep = UPWARD_RA;
	else if (need_downward_RA)
	    alt_sep = DOWNWARD_RA;
	else
	    alt_sep = UNRESOLVED;
    }
    return alt_sep;
}","<mb:mutant#12f7fe98fb5de9a5dde8f0d1b3886a3e30d441e0> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -118 +118 @@
-    enabled = High_Confidence && (Own_Tracked_Alt_Rate <= OLEV) && (Cur_Vertical_Sep > MAXALTDIFF);
+    enabled = High_Confidence && (Own_Tracked_Alt_Rate < OLEV) && (++Cur_Vertical_Sep > MAXALTDIFF);
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS>,
        <mb:operator#ROR> ;
    mb:program <mb:program#Tcas.c> ."
556,"bool Non_Crossing_Biased_Climb()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(Down_Separation >= ALIM())));
    }
    else
    {
	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation < ALIM());
    }
    return result;
}","<mb:mutant#fbc32d71a2dffeb1bc2f428b008fb0248a6a3d81> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -79 +79 @@
-	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation >= ALIM());
+	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation < ALIM());
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Tcas.c> ."
557,"bool Own_Below_Threat()
{
    return (Own_Tracked_Alt < Other_Tracked_Alt++);
}","<mb:mutant#b66502052f65f84e123fa4ed79ad66850d89b7b0> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -104 +104 @@
-    return (Own_Tracked_Alt < Other_Tracked_Alt);
+    return (Own_Tracked_Alt < Other_Tracked_Alt++);
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
558,"bool Non_Crossing_Biased_Descend()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Down_Separation >= ALIM());
    }
    else
    {
	result = !(Own_Above_Threat()) || ((Own_Above_Threat()) && (++Up_Separation >= ALIM()));
    }
    return result;
}","<mb:mutant#7880c78c09b107dc23222d9f8852bd9d881218cb> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -97 +97 @@
-	result = !(Own_Above_Threat()) || ((Own_Above_Threat()) && (Up_Separation >= ALIM()));
+	result = !(Own_Above_Threat()) || ((Own_Above_Threat()) && (++Up_Separation >= ALIM()));
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
559,"bool Non_Crossing_Biased_Climb()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(abs(Down_Separation) >= ALIM())));
    }
    else
    {
	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation >= ALIM());
    }
    return result;
}","<mb:mutant#4b0b0f49130437d7eaddeae7f4d97ed82da670d0> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -75 +75 @@
-	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(Down_Separation >= ALIM())));
+	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(abs(Down_Separation) >= ALIM())));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Tcas.c> ."
560,"bool Non_Crossing_Biased_Climb()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(Down_Separation == ALIM())));
    }
    else
    {
	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation >= ALIM());
    }
    return result;
}","<mb:mutant#45af243b0ac4116a0088306b06fd71142c73be46> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -75 +75 @@
-	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(Down_Separation >= ALIM())));
+	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(Down_Separation == ALIM())));
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Tcas.c> ."
561,"int Inhibit_Biased_Climb ()
{
    return (Climb_Inhibit ? Up_Separation - NOZCROSS : Up_Separation);
}","<mb:mutant#1592cf86b30f172ad9e88bc47bc0f3dd76409328> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -63 +63 @@
-    return (Climb_Inhibit ? Up_Separation + NOZCROSS : Up_Separation);
+    return (Climb_Inhibit ? Up_Separation - NOZCROSS : Up_Separation);
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Tcas.c> ."
562,"int alt_sep_test()
{
    bool enabled, tcas_equipped, intent_not_known;
    bool need_upward_RA, need_downward_RA;
    int alt_sep;
    enabled = High_Confidence && (Own_Tracked_Alt_Rate != OLEV) && (Cur_Vertical_Sep > MAXALTDIFF);
    tcas_equipped = Other_Capability == TCAS_TA;
    intent_not_known = Two_of_Three_Reports_Valid && Other_RAC == NO_INTENT;
    alt_sep = UNRESOLVED;
    if (enabled && ((tcas_equipped && intent_not_known) || !tcas_equipped))
    {
	need_upward_RA = Non_Crossing_Biased_Climb() && Own_Below_Threat();
	need_downward_RA = Non_Crossing_Biased_Descend() && Own_Above_Threat();
	if (need_upward_RA && need_downward_RA)
	    alt_sep = UNRESOLVED;
	else if (need_upward_RA)
	    alt_sep = UPWARD_RA;
	else if (need_downward_RA)
	    alt_sep = DOWNWARD_RA;
	else
	    alt_sep = UNRESOLVED;
    }
    return alt_sep;
}","<mb:mutant#5e012d0c3139775168a3bb05d5fe7ba1b082fa23> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -118 +118 @@
-    enabled = High_Confidence && (Own_Tracked_Alt_Rate <= OLEV) && (Cur_Vertical_Sep > MAXALTDIFF);
+    enabled = High_Confidence && (Own_Tracked_Alt_Rate != OLEV) && (Cur_Vertical_Sep > MAXALTDIFF);
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Tcas.c> ."
563,"bool Own_Above_Threat()
{
    return (Other_Tracked_Alt < Own_Tracked_Alt--);
}","<mb:mutant#7a1eaa2763bc59c5e6abc3a0257c9f8893a8dc05> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -109 +109 @@
-    return (Other_Tracked_Alt < Own_Tracked_Alt);
+    return (Other_Tracked_Alt < Own_Tracked_Alt--);
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
564,"bool Non_Crossing_Biased_Climb()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(Down_Separation >= ALIM())));
    }
    else
    {
	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (--Up_Separation >= ALIM());
    }
    return result;
}","<mb:mutant#43184fae4d4bad33fa6307994d1438bdbe0a7824> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -79 +79 @@
-	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation >= ALIM());
+	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (--Up_Separation >= ALIM());
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
565,"bool Non_Crossing_Biased_Descend()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > --Down_Separation;
    if (upward_preferred)
    {
	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Down_Separation >= ALIM());
    }
    else
    {
	result = !(Own_Above_Threat()) || ((Own_Above_Threat()) && (Up_Separation >= ALIM()));
    }
    return result;
}","<mb:mutant#8ab77f477cc34a3ecf91f8a13dad8b67dbbaa5a0> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -90 +90 @@
-    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
+    upward_preferred = Inhibit_Biased_Climb() > --Down_Separation;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
566,"bool Non_Crossing_Biased_Climb()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation--;
    if (upward_preferred)
    {
	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(Down_Separation >= ALIM())));
    }
    else
    {
	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation >= ALIM());
    }
    return result;
}","<mb:mutant#b3c0f11d7e47b30792d272c05467f33fd9c47599> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -72 +72 @@
-    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
+    upward_preferred = Inhibit_Biased_Climb() > Down_Separation--;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
567,"int alt_sep_test()
{
    bool enabled, tcas_equipped, intent_not_known;
    bool need_upward_RA, need_downward_RA;
    int alt_sep;
    enabled = High_Confidence && (Own_Tracked_Alt_Rate < OLEV) && (--Cur_Vertical_Sep > MAXALTDIFF);
    tcas_equipped = Other_Capability == TCAS_TA;
    intent_not_known = Two_of_Three_Reports_Valid && Other_RAC == NO_INTENT;
    alt_sep = UNRESOLVED;
    if (enabled && ((tcas_equipped && intent_not_known) || !tcas_equipped))
    {
	need_upward_RA = Non_Crossing_Biased_Climb() && Own_Below_Threat();
	need_downward_RA = Non_Crossing_Biased_Descend() && Own_Above_Threat();
	if (need_upward_RA && need_downward_RA)
	    alt_sep = UNRESOLVED;
	else if (need_upward_RA)
	    alt_sep = UPWARD_RA;
	else if (need_downward_RA)
	    alt_sep = DOWNWARD_RA;
	else
	    alt_sep = UNRESOLVED;
    }
    return alt_sep;
}","<mb:mutant#0af4cdf5393d720afa1be26c95da3342c541fb21> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -118 +118 @@
-    enabled = High_Confidence && (Own_Tracked_Alt_Rate <= OLEV) && (Cur_Vertical_Sep > MAXALTDIFF);
+    enabled = High_Confidence && (Own_Tracked_Alt_Rate < OLEV) && (--Cur_Vertical_Sep > MAXALTDIFF);
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS>,
        <mb:operator#ROR> ;
    mb:program <mb:program#Tcas.c> ."
568,"int Inhibit_Biased_Climb ()
{
    return (Climb_Inhibit ? Up_Separation + NOZCROSS : --Up_Separation);
}","<mb:mutant#8dfe8abe0f89c6b0403fa5b905f70b990ce6340c> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -63 +63 @@
-    return (Climb_Inhibit ? Up_Separation + NOZCROSS : Up_Separation);
+    return (Climb_Inhibit ? Up_Separation + NOZCROSS : --Up_Separation);
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
569,"bool Own_Above_Threat()
{
    return (abs(Other_Tracked_Alt) < Own_Tracked_Alt);
}","<mb:mutant#6f5977565c44301548d81cdb6994b2e8f194ed5c> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -109 +109 @@
-    return (Other_Tracked_Alt < Own_Tracked_Alt);
+    return (abs(Other_Tracked_Alt) < Own_Tracked_Alt);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Tcas.c> ."
570,"int ALIM ()
{
 return Positive_RA_Alt_Thresh[++Alt_Layer_Value];
}","<mb:mutant#2db72a3bd2d62d8d34b5dcf658b5ae20f867f5ef> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -58 +58 @@
- return Positive_RA_Alt_Thresh[Alt_Layer_Value];
+ return Positive_RA_Alt_Thresh[++Alt_Layer_Value];
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
571,"bool Non_Crossing_Biased_Descend()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Down_Separation >= ALIM());
    }
    else
    {
	result = !(Own_Above_Threat()) || ((Own_Above_Threat()) && (--Up_Separation >= ALIM()));
    }
    return result;
}","<mb:mutant#d79bbf47244f8d3dba100ff08a0888d581d421bc> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -97 +97 @@
-	result = !(Own_Above_Threat()) || ((Own_Above_Threat()) && (Up_Separation >= ALIM()));
+	result = !(Own_Above_Threat()) || ((Own_Above_Threat()) && (--Up_Separation >= ALIM()));
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
572,"int alt_sep_test()
{
    bool enabled, tcas_equipped, intent_not_known;
    bool need_upward_RA, need_downward_RA;
    int alt_sep;
    enabled = High_Confidence && (Own_Tracked_Alt_Rate <= OLEV) && (Cur_Vertical_Sep > MAXALTDIFF);
    tcas_equipped = Other_Capability == TCAS_TA;
    intent_not_known = Two_of_Three_Reports_Valid && Other_RAC == NO_INTENT;
    alt_sep = UNRESOLVED;
    if (enabled || ((tcas_equipped && intent_not_known) || !tcas_equipped))
    {
	need_upward_RA = Non_Crossing_Biased_Climb() && Own_Below_Threat();
	need_downward_RA = Non_Crossing_Biased_Descend() && Own_Above_Threat();
	if (need_upward_RA && need_downward_RA)
	    alt_sep = UNRESOLVED;
	else if (need_upward_RA)
	    alt_sep = UPWARD_RA;
	else if (need_downward_RA)
	    alt_sep = DOWNWARD_RA;
	else
	    alt_sep = UNRESOLVED;
    }
    return alt_sep;
}","<mb:mutant#6cd8802065cecced9cc3f9ca4cfd66ff30aaf430> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -124 +124 @@
-    if (enabled && ((tcas_equipped && intent_not_known) || !tcas_equipped))
+    if (enabled || ((tcas_equipped && intent_not_known) || !tcas_equipped))
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#SEOR> ;
    mb:program <mb:program#Tcas.c> ."
573,"bool Non_Crossing_Biased_Descend()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = Own_Below_Threat() && (Cur_Vertical_Sep == MINSEP) && (Down_Separation >= ALIM());
    }
    else
    {
	result = !(Own_Above_Threat()) || ((Own_Above_Threat()) && (Up_Separation >= ALIM()));
    }
    return result;
}","<mb:mutant#da0c5c6c51897e000f81d33263b94799f675b049> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -93 +93 @@
-	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Down_Separation >= ALIM());
+	result = Own_Below_Threat() && (Cur_Vertical_Sep == MINSEP) && (Down_Separation >= ALIM());
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Tcas.c> ."
574,"bool Own_Above_Threat()
{
    return (Other_Tracked_Alt-- < Own_Tracked_Alt);
}","<mb:mutant#74ff28f4373c7e20273d201584128ec57561be59> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -109 +109 @@
-    return (Other_Tracked_Alt < Own_Tracked_Alt);
+    return (Other_Tracked_Alt-- < Own_Tracked_Alt);
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
575,"int alt_sep_test()
{
    bool enabled, tcas_equipped, intent_not_known;
    bool need_upward_RA, need_downward_RA;
    int alt_sep;
    enabled = High_Confidence && (Own_Tracked_Alt_Rate <= OLEV) && (Cur_Vertical_Sep > MAXALTDIFF);
    tcas_equipped = abs(Other_Capability) == TCAS_TA;
    intent_not_known = Two_of_Three_Reports_Valid && Other_RAC == NO_INTENT;
    alt_sep = UNRESOLVED;
    if (enabled && ((tcas_equipped && intent_not_known) || !tcas_equipped))
    {
	need_upward_RA = Non_Crossing_Biased_Climb() && Own_Below_Threat();
	need_downward_RA = Non_Crossing_Biased_Descend() && Own_Above_Threat();
	if (need_upward_RA && need_downward_RA)
	    alt_sep = UNRESOLVED;
	else if (need_upward_RA)
	    alt_sep = UPWARD_RA;
	else if (need_downward_RA)
	    alt_sep = DOWNWARD_RA;
	else
	    alt_sep = UNRESOLVED;
    }
    return alt_sep;
}","<mb:mutant#6d61159f4f4ae11beb3cfdb3334c58334fcd391f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -119 +119 @@
-    tcas_equipped = Other_Capability == TCAS_TA;
+    tcas_equipped = abs(Other_Capability) == TCAS_TA;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Tcas.c> ."
576,"bool Non_Crossing_Biased_Descend()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (abs(Down_Separation) >= ALIM());
    }
    else
    {
	result = !(Own_Above_Threat()) || ((Own_Above_Threat()) && (Up_Separation >= ALIM()));
    }
    return result;
}","<mb:mutant#f12551188de640564a40d9fa7244e9edc92c3719> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -93 +93 @@
-	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Down_Separation >= ALIM());
+	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (abs(Down_Separation) >= ALIM());
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Tcas.c> ."
577,"bool Non_Crossing_Biased_Climb()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(--Down_Separation >= ALIM())));
    }
    else
    {
	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation >= ALIM());
    }
    return result;
}","<mb:mutant#895a93ed23c770e89c8b36b51ae783433e0700f5> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -75 +75 @@
-	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(Down_Separation >= ALIM())));
+	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(--Down_Separation >= ALIM())));
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
578,"bool Non_Crossing_Biased_Descend()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Down_Separation != ALIM());
    }
    else
    {
	result = !(Own_Above_Threat()) || ((Own_Above_Threat()) && (Up_Separation >= ALIM()));
    }
    return result;
}","<mb:mutant#d1e95ab20bfa56c6dce29ee0514c3b98036298d8> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -93 +93 @@
-	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Down_Separation >= ALIM());
+	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Down_Separation != ALIM());
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Tcas.c> ."
579,"int alt_sep_test()
{
    bool enabled, tcas_equipped, intent_not_known;
    bool need_upward_RA, need_downward_RA;
    int alt_sep;
    enabled = High_Confidence || (Own_Tracked_Alt_Rate < OLEV) && (Cur_Vertical_Sep > MAXALTDIFF);
    tcas_equipped = Other_Capability == TCAS_TA;
    intent_not_known = Two_of_Three_Reports_Valid && Other_RAC == NO_INTENT;
    alt_sep = UNRESOLVED;
    if (enabled && ((tcas_equipped && intent_not_known) || !tcas_equipped))
    {
	need_upward_RA = Non_Crossing_Biased_Climb() && Own_Below_Threat();
	need_downward_RA = Non_Crossing_Biased_Descend() && Own_Above_Threat();
	if (need_upward_RA && need_downward_RA)
	    alt_sep = UNRESOLVED;
	else if (need_upward_RA)
	    alt_sep = UPWARD_RA;
	else if (need_downward_RA)
	    alt_sep = DOWNWARD_RA;
	else
	    alt_sep = UNRESOLVED;
    }
    return alt_sep;
}","<mb:mutant#abbe10274813aeaddbad43d37276df1f51ed85b1> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -118 +118 @@
-    enabled = High_Confidence && (Own_Tracked_Alt_Rate <= OLEV) && (Cur_Vertical_Sep > MAXALTDIFF);
+    enabled = High_Confidence || (Own_Tracked_Alt_Rate < OLEV) && (Cur_Vertical_Sep > MAXALTDIFF);
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#ROR>,
        <mb:operator#SEOD> ;
    mb:program <mb:program#Tcas.c> ."
580,"int alt_sep_test()
{
    bool enabled, tcas_equipped, intent_not_known;
    bool need_upward_RA, need_downward_RA;
    int alt_sep;
    enabled = High_Confidence && (Own_Tracked_Alt_Rate < OLEV) && (Cur_Vertical_Sep >= MAXALTDIFF);
    tcas_equipped = Other_Capability == TCAS_TA;
    intent_not_known = Two_of_Three_Reports_Valid && Other_RAC == NO_INTENT;
    alt_sep = UNRESOLVED;
    if (enabled && ((tcas_equipped && intent_not_known) || !tcas_equipped))
    {
	need_upward_RA = Non_Crossing_Biased_Climb() && Own_Below_Threat();
	need_downward_RA = Non_Crossing_Biased_Descend() && Own_Above_Threat();
	if (need_upward_RA && need_downward_RA)
	    alt_sep = UNRESOLVED;
	else if (need_upward_RA)
	    alt_sep = UPWARD_RA;
	else if (need_downward_RA)
	    alt_sep = DOWNWARD_RA;
	else
	    alt_sep = UNRESOLVED;
    }
    return alt_sep;
}","<mb:mutant#6953885c7e5e5b36bdd6db7a0a07eb2463caf647> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -118 +118 @@
-    enabled = High_Confidence && (Own_Tracked_Alt_Rate <= OLEV) && (Cur_Vertical_Sep > MAXALTDIFF);
+    enabled = High_Confidence && (Own_Tracked_Alt_Rate < OLEV) && (Cur_Vertical_Sep >= MAXALTDIFF);
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Tcas.c> ."
581,"bool Own_Above_Threat()
{
    return (Other_Tracked_Alt++ < Own_Tracked_Alt);
}","<mb:mutant#2e7d35bcd31b48eb5acc87b6a6979c7fb61c2774> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -109 +109 @@
-    return (Other_Tracked_Alt < Own_Tracked_Alt);
+    return (Other_Tracked_Alt++ < Own_Tracked_Alt);
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
582,"bool Non_Crossing_Biased_Climb()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(Down_Separation >= ALIM())));
    }
    else
    {
	result = Own_Above_Threat() || (Cur_Vertical_Sep >= MINSEP) && (Up_Separation >= ALIM());
    }
    return result;
}","<mb:mutant#76088fd04c228dd8b8641850632c2e44cca0615a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -79 +79 @@
-	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation >= ALIM());
+	result = Own_Above_Threat() || (Cur_Vertical_Sep >= MINSEP) && (Up_Separation >= ALIM());
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#SEOD> ;
    mb:program <mb:program#Tcas.c> ."
583,"int alt_sep_test()
{
    bool enabled, tcas_equipped, intent_not_known;
    bool need_upward_RA, need_downward_RA;
    int alt_sep;
    enabled = High_Confidence && (Own_Tracked_Alt_Rate < OLEV) && (Cur_Vertical_Sep++ > MAXALTDIFF);
    tcas_equipped = Other_Capability == TCAS_TA;
    intent_not_known = Two_of_Three_Reports_Valid && Other_RAC == NO_INTENT;
    alt_sep = UNRESOLVED;
    if (enabled && ((tcas_equipped && intent_not_known) || !tcas_equipped))
    {
	need_upward_RA = Non_Crossing_Biased_Climb() && Own_Below_Threat();
	need_downward_RA = Non_Crossing_Biased_Descend() && Own_Above_Threat();
	if (need_upward_RA && need_downward_RA)
	    alt_sep = UNRESOLVED;
	else if (need_upward_RA)
	    alt_sep = UPWARD_RA;
	else if (need_downward_RA)
	    alt_sep = DOWNWARD_RA;
	else
	    alt_sep = UNRESOLVED;
    }
    return alt_sep;
}","<mb:mutant#d08905d65b6e26f96427fb4f9e71c099c0c62baa> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -118 +118 @@
-    enabled = High_Confidence && (Own_Tracked_Alt_Rate <= OLEV) && (Cur_Vertical_Sep > MAXALTDIFF);
+    enabled = High_Confidence && (Own_Tracked_Alt_Rate < OLEV) && (Cur_Vertical_Sep++ > MAXALTDIFF);
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS>,
        <mb:operator#ROR> ;
    mb:program <mb:program#Tcas.c> ."
584,"bool Own_Below_Threat()
{
    return (Own_Tracked_Alt-- < Other_Tracked_Alt);
}","<mb:mutant#22c48f2ac618671fa7c7449e36d547d58259d665> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -104 +104 @@
-    return (Own_Tracked_Alt < Other_Tracked_Alt);
+    return (Own_Tracked_Alt-- < Other_Tracked_Alt);
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
585,"bool Non_Crossing_Biased_Descend()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (--Down_Separation >= ALIM());
    }
    else
    {
	result = !(Own_Above_Threat()) || ((Own_Above_Threat()) && (Up_Separation >= ALIM()));
    }
    return result;
}","<mb:mutant#51554327fc49df719d464e54e44a31bfec691133> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -93 +93 @@
-	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Down_Separation >= ALIM());
+	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (--Down_Separation >= ALIM());
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
586,"bool Own_Below_Threat()
{
    return (Own_Tracked_Alt < ++Other_Tracked_Alt);
}","<mb:mutant#ee95ed3fa6bdbc755eee8db44491d225a7a43d90> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -104 +104 @@
-    return (Own_Tracked_Alt < Other_Tracked_Alt);
+    return (Own_Tracked_Alt < ++Other_Tracked_Alt);
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
587,"int alt_sep_test()
{
    bool enabled, tcas_equipped, intent_not_known;
    bool need_upward_RA, need_downward_RA;
    int alt_sep;
    enabled = High_Confidence && (Own_Tracked_Alt_Rate <= OLEV) && (Cur_Vertical_Sep > abs(MAXALTDIFF));
    tcas_equipped = Other_Capability == TCAS_TA;
    intent_not_known = Two_of_Three_Reports_Valid && Other_RAC == NO_INTENT;
    alt_sep = UNRESOLVED;
    if (enabled && ((tcas_equipped && intent_not_known) || !tcas_equipped))
    {
	need_upward_RA = Non_Crossing_Biased_Climb() && Own_Below_Threat();
	need_downward_RA = Non_Crossing_Biased_Descend() && Own_Above_Threat();
	if (need_upward_RA && need_downward_RA)
	    alt_sep = UNRESOLVED;
	else if (need_upward_RA)
	    alt_sep = UPWARD_RA;
	else if (need_downward_RA)
	    alt_sep = DOWNWARD_RA;
	else
	    alt_sep = UNRESOLVED;
    }
    return alt_sep;
}","<mb:mutant#1cb444bd46546895ba3852cbfdf1933c1927d43f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -118 +118 @@
-    enabled = High_Confidence && (Own_Tracked_Alt_Rate <= OLEV) && (Cur_Vertical_Sep > MAXALTDIFF);
+    enabled = High_Confidence && (Own_Tracked_Alt_Rate <= OLEV) && (Cur_Vertical_Sep > abs(MAXALTDIFF));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Tcas.c> ."
588,"bool Non_Crossing_Biased_Climb()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(Down_Separation >= ALIM())));
    }
    else
    {
	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation > ALIM());
    }
    return result;
}","<mb:mutant#f0978da13fa3a1b8a211064462039b5a043cac37> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -79 +79 @@
-	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation >= ALIM());
+	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation > ALIM());
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Tcas.c> ."
589,"bool Own_Below_Threat()
{
    return (++Own_Tracked_Alt < Other_Tracked_Alt);
}","<mb:mutant#7a26f145cad5dc45bfc189cb5ca22b09d031cd57> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -104 +104 @@
-    return (Own_Tracked_Alt < Other_Tracked_Alt);
+    return (++Own_Tracked_Alt < Other_Tracked_Alt);
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
590,"bool Own_Above_Threat()
{
    return (Other_Tracked_Alt < ++Own_Tracked_Alt);
}","<mb:mutant#f33b8f650ceb43e7925c832a2c52753f31f9efa8> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -109 +109 @@
-    return (Other_Tracked_Alt < Own_Tracked_Alt);
+    return (Other_Tracked_Alt < ++Own_Tracked_Alt);
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
591,"int alt_sep_test()
{
    bool enabled, tcas_equipped, intent_not_known;
    bool need_upward_RA, need_downward_RA;
    int alt_sep;
    enabled = High_Confidence && (Own_Tracked_Alt_Rate <= OLEV) && (Cur_Vertical_Sep > MAXALTDIFF);
    tcas_equipped = Other_Capability == TCAS_TA;
    intent_not_known = Two_of_Three_Reports_Valid && Other_RAC == NO_INTENT;
    alt_sep = UNRESOLVED;
    if (enabled && ((tcas_equipped || intent_not_known) || !tcas_equipped))
    {
	need_upward_RA = Non_Crossing_Biased_Climb() && Own_Below_Threat();
	need_downward_RA = Non_Crossing_Biased_Descend() && Own_Above_Threat();
	if (need_upward_RA && need_downward_RA)
	    alt_sep = UNRESOLVED;
	else if (need_upward_RA)
	    alt_sep = UPWARD_RA;
	else if (need_downward_RA)
	    alt_sep = DOWNWARD_RA;
	else
	    alt_sep = UNRESOLVED;
    }
    return alt_sep;
}","<mb:mutant#bb7b3b5fc7da7835a40e23475166124999337e1a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -124 +124 @@
-    if (enabled && ((tcas_equipped && intent_not_known) || !tcas_equipped))
+    if (enabled && ((tcas_equipped || intent_not_known) || !tcas_equipped))
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#SEOR> ;
    mb:program <mb:program#Tcas.c> ."
592,"int ALIM ()
{
 return Positive_RA_Alt_Thresh[abs(Alt_Layer_Value)];
}","<mb:mutant#85800147cd80ff293d032a8e52d6684f3a334c8d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -58 +58 @@
- return Positive_RA_Alt_Thresh[Alt_Layer_Value];
+ return Positive_RA_Alt_Thresh[abs(Alt_Layer_Value)];
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Tcas.c> ."
593,"bool Non_Crossing_Biased_Climb()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(Down_Separation >= ALIM())));
    }
    else
    {
	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (abs(Up_Separation) >= ALIM());
    }
    return result;
}","<mb:mutant#40c4b1ed7febb551df0a02a5638c1c817dec6bbb> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -79 +79 @@
-	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation >= ALIM());
+	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (abs(Up_Separation) >= ALIM());
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Tcas.c> ."
594,"int alt_sep_test()
{
    bool enabled, tcas_equipped, intent_not_known;
    bool need_upward_RA, need_downward_RA;
    int alt_sep;
    enabled = High_Confidence && (Own_Tracked_Alt_Rate < OLEV) && (Cur_Vertical_Sep > MAXALTDIFF);
    tcas_equipped = Other_Capability == TCAS_TA;
    intent_not_known = Two_of_Three_Reports_Valid && Other_RAC == NO_INTENT;
    alt_sep = UNRESOLVED;
    if (enabled && ((tcas_equipped && intent_not_known) || !tcas_equipped))
    {
	need_upward_RA = Non_Crossing_Biased_Climb() && Own_Below_Threat();
	need_downward_RA = Non_Crossing_Biased_Descend() && Own_Above_Threat();
	if (need_upward_RA && need_downward_RA)
	    alt_sep = UNRESOLVED;
	else if (need_upward_RA)
	    alt_sep = UPWARD_RA;
	else if (need_downward_RA)
	    alt_sep = DOWNWARD_RA;
	else
	    alt_sep = UNRESOLVED;
    }
    return alt_sep;
}","<mb:mutant#af0cadfd039213248fc9b40bdbd0045b0affb214> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -118 +118 @@
-    enabled = High_Confidence && (Own_Tracked_Alt_Rate <= OLEV) && (Cur_Vertical_Sep > MAXALTDIFF);
+    enabled = High_Confidence && (Own_Tracked_Alt_Rate < OLEV) && (Cur_Vertical_Sep > MAXALTDIFF);
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Tcas.c> ."
595,"int alt_sep_test()
{
    bool enabled, tcas_equipped, intent_not_known;
    bool need_upward_RA, need_downward_RA;
    int alt_sep;
    enabled = High_Confidence && (Own_Tracked_Alt_Rate <= OLEV) && (Cur_Vertical_Sep > MAXALTDIFF);
    tcas_equipped = Other_Capability == TCAS_TA;
    intent_not_known = Two_of_Three_Reports_Valid && ++Other_RAC == NO_INTENT;
    alt_sep = UNRESOLVED;
    if (enabled && ((tcas_equipped && intent_not_known) || !tcas_equipped))
    {
	need_upward_RA = Non_Crossing_Biased_Climb() && Own_Below_Threat();
	need_downward_RA = Non_Crossing_Biased_Descend() && Own_Above_Threat();
	if (need_upward_RA && need_downward_RA)
	    alt_sep = UNRESOLVED;
	else if (need_upward_RA)
	    alt_sep = UPWARD_RA;
	else if (need_downward_RA)
	    alt_sep = DOWNWARD_RA;
	else
	    alt_sep = UNRESOLVED;
    }
    return alt_sep;
}","<mb:mutant#45fabcb9cb53d2ffcea023811336ba162eac479d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -120 +120 @@
-    intent_not_known = Two_of_Three_Reports_Valid && Other_RAC == NO_INTENT;
+    intent_not_known = Two_of_Three_Reports_Valid && ++Other_RAC == NO_INTENT;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
596,"bool Non_Crossing_Biased_Descend()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation++;
    if (upward_preferred)
    {
	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Down_Separation >= ALIM());
    }
    else
    {
	result = !(Own_Above_Threat()) || ((Own_Above_Threat()) && (Up_Separation >= ALIM()));
    }
    return result;
}","<mb:mutant#ee560733c7f88ac39c93f459923e6c8c20c5b324> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -90 +90 @@
-    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
+    upward_preferred = Inhibit_Biased_Climb() > Down_Separation++;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
597,"int alt_sep_test()
{
    bool enabled, tcas_equipped, intent_not_known;
    bool need_upward_RA, need_downward_RA;
    int alt_sep;
    enabled = High_Confidence && (Own_Tracked_Alt_Rate <= OLEV) && (Cur_Vertical_Sep > MAXALTDIFF);
    tcas_equipped = Other_Capability == TCAS_TA;
    intent_not_known = Two_of_Three_Reports_Valid && Other_RAC < NO_INTENT;
    alt_sep = UNRESOLVED;
    if (enabled && ((tcas_equipped && intent_not_known) || !tcas_equipped))
    {
	need_upward_RA = Non_Crossing_Biased_Climb() && Own_Below_Threat();
	need_downward_RA = Non_Crossing_Biased_Descend() && Own_Above_Threat();
	if (need_upward_RA && need_downward_RA)
	    alt_sep = UNRESOLVED;
	else if (need_upward_RA)
	    alt_sep = UPWARD_RA;
	else if (need_downward_RA)
	    alt_sep = DOWNWARD_RA;
	else
	    alt_sep = UNRESOLVED;
    }
    return alt_sep;
}","<mb:mutant#6b373d4e5a73a4700cfe9abe3518b0a42b8d4ff6> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -120 +120 @@
-    intent_not_known = Two_of_Three_Reports_Valid && Other_RAC == NO_INTENT;
+    intent_not_known = Two_of_Three_Reports_Valid && Other_RAC < NO_INTENT;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Tcas.c> ."
598,"bool Non_Crossing_Biased_Descend()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (++Down_Separation >= ALIM());
    }
    else
    {
	result = !(Own_Above_Threat()) || ((Own_Above_Threat()) && (Up_Separation >= ALIM()));
    }
    return result;
}","<mb:mutant#3964456274f29cfcdc8ef4799ec678d3bd24a0ea> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -93 +93 @@
-	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Down_Separation >= ALIM());
+	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (++Down_Separation >= ALIM());
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
599,"bool Non_Crossing_Biased_Climb()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(Down_Separation >= ALIM())));
    }
    else
    {
	result = Own_Above_Threat() && (Cur_Vertical_Sep == MINSEP) && (Up_Separation >= ALIM());
    }
    return result;
}","<mb:mutant#fc8acbebc1d629c8f57bbdc2a622c65c5ca181b9> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -79 +79 @@
-	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation >= ALIM());
+	result = Own_Above_Threat() && (Cur_Vertical_Sep == MINSEP) && (Up_Separation >= ALIM());
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Tcas.c> ."
600,"bool Non_Crossing_Biased_Descend()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = Own_Below_Threat() && (Cur_Vertical_Sep > MINSEP) && (Down_Separation >= ALIM());
    }
    else
    {
	result = !(Own_Above_Threat()) || ((Own_Above_Threat()) && (Up_Separation >= ALIM()));
    }
    return result;
}","<mb:mutant#cc65607a63ce55e1ac74f2494003d589ff7d08db> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -93 +93 @@
-	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Down_Separation >= ALIM());
+	result = Own_Below_Threat() && (Cur_Vertical_Sep > MINSEP) && (Down_Separation >= ALIM());
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Tcas.c> ."
601,"int Inhibit_Biased_Climb ()
{
    return (Climb_Inhibit ? Up_Separation++ + NOZCROSS : Up_Separation);
}","<mb:mutant#c1a37e6eadbdb483af33c0b2a523399142d4dd5e> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -63 +63 @@
-    return (Climb_Inhibit ? Up_Separation + NOZCROSS : Up_Separation);
+    return (Climb_Inhibit ? Up_Separation++ + NOZCROSS : Up_Separation);
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
602,"bool Own_Below_Threat()
{
    return (Own_Tracked_Alt < Other_Tracked_Alt--);
}","<mb:mutant#a64e447a4ef23a749511f96510517867a8937574> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -104 +104 @@
-    return (Own_Tracked_Alt < Other_Tracked_Alt);
+    return (Own_Tracked_Alt < Other_Tracked_Alt--);
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
603,"int Inhibit_Biased_Climb ()
{
    return (Climb_Inhibit ? Up_Separation + NOZCROSS : Up_Separation--);
}","<mb:mutant#5303f767503c14ae0ac8542851985be1289603f8> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -63 +63 @@
-    return (Climb_Inhibit ? Up_Separation + NOZCROSS : Up_Separation);
+    return (Climb_Inhibit ? Up_Separation + NOZCROSS : Up_Separation--);
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
604,"bool Non_Crossing_Biased_Descend()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = Own_Below_Threat() && (Cur_Vertical_Sep <= MINSEP) && (Down_Separation >= ALIM());
    }
    else
    {
	result = !(Own_Above_Threat()) || ((Own_Above_Threat()) && (Up_Separation >= ALIM()));
    }
    return result;
}","<mb:mutant#d00352b1df1af322f336e37067e610b9fce73c9b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -93 +93 @@
-	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Down_Separation >= ALIM());
+	result = Own_Below_Threat() && (Cur_Vertical_Sep <= MINSEP) && (Down_Separation >= ALIM());
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Tcas.c> ."
605,"int alt_sep_test()
{
    bool enabled, tcas_equipped, intent_not_known;
    bool need_upward_RA, need_downward_RA;
    int alt_sep;
    enabled = High_Confidence && (Own_Tracked_Alt_Rate < OLEV) && (Cur_Vertical_Sep != MAXALTDIFF);
    tcas_equipped = Other_Capability == TCAS_TA;
    intent_not_known = Two_of_Three_Reports_Valid && Other_RAC == NO_INTENT;
    alt_sep = UNRESOLVED;
    if (enabled && ((tcas_equipped && intent_not_known) || !tcas_equipped))
    {
	need_upward_RA = Non_Crossing_Biased_Climb() && Own_Below_Threat();
	need_downward_RA = Non_Crossing_Biased_Descend() && Own_Above_Threat();
	if (need_upward_RA && need_downward_RA)
	    alt_sep = UNRESOLVED;
	else if (need_upward_RA)
	    alt_sep = UPWARD_RA;
	else if (need_downward_RA)
	    alt_sep = DOWNWARD_RA;
	else
	    alt_sep = UNRESOLVED;
    }
    return alt_sep;
}","<mb:mutant#86a32513eeab9040d87a3a10612c2a1dd5ae3e51> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -118 +118 @@
-    enabled = High_Confidence && (Own_Tracked_Alt_Rate <= OLEV) && (Cur_Vertical_Sep > MAXALTDIFF);
+    enabled = High_Confidence && (Own_Tracked_Alt_Rate < OLEV) && (Cur_Vertical_Sep != MAXALTDIFF);
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Tcas.c> ."
606,"bool Non_Crossing_Biased_Climb()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(Down_Separation >= ALIM())));
    }
    else
    {
	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) || (Up_Separation >= ALIM());
    }
    return result;
}","<mb:mutant#3fa3c2b273f623ac554782351d7f2e2d7b8a07a1> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -79 +79 @@
-	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation >= ALIM());
+	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) || (Up_Separation >= ALIM());
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#SEOR> ;
    mb:program <mb:program#Tcas.c> ."
607,"bool Own_Above_Threat()
{
    return (Other_Tracked_Alt <= Own_Tracked_Alt);
}","<mb:mutant#42347ef5c63b8c41867d3b54e2de885a3ed7ff4c> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -109 +109 @@
-    return (Other_Tracked_Alt < Own_Tracked_Alt);
+    return (Other_Tracked_Alt <= Own_Tracked_Alt);
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Tcas.c> ."
608,"bool Non_Crossing_Biased_Descend()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = Own_Below_Threat() && (Cur_Vertical_Sep != MINSEP) && (Down_Separation >= ALIM());
    }
    else
    {
	result = !(Own_Above_Threat()) || ((Own_Above_Threat()) && (Up_Separation >= ALIM()));
    }
    return result;
}","<mb:mutant#d4e722299c7d4049ac291b281f8737705092f7dc> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -93 +93 @@
-	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Down_Separation >= ALIM());
+	result = Own_Below_Threat() && (Cur_Vertical_Sep != MINSEP) && (Down_Separation >= ALIM());
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Tcas.c> ."
609,"bool Own_Below_Threat()
{
    return (Own_Tracked_Alt <= Other_Tracked_Alt);
}","<mb:mutant#836ca752ebeaefd9a57172c9543a6145e7518b95> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -104 +104 @@
-    return (Own_Tracked_Alt < Other_Tracked_Alt);
+    return (Own_Tracked_Alt <= Other_Tracked_Alt);
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Tcas.c> ."
610,"bool Own_Below_Threat()
{
    return (abs(Own_Tracked_Alt) < Other_Tracked_Alt);
}","<mb:mutant#733dfa7472d02aa77f755b647d9b4be69a0a50e6> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -104 +104 @@
-    return (Own_Tracked_Alt < Other_Tracked_Alt);
+    return (abs(Own_Tracked_Alt) < Other_Tracked_Alt);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Tcas.c> ."
611,"bool Non_Crossing_Biased_Descend()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = Own_Below_Threat() && (abs(Cur_Vertical_Sep) >= MINSEP) && (Down_Separation >= ALIM());
    }
    else
    {
	result = !(Own_Above_Threat()) || ((Own_Above_Threat()) && (Up_Separation >= ALIM()));
    }
    return result;
}","<mb:mutant#895963f19ef3163816b5f833b5d157057706dbc9> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -93 +93 @@
-	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Down_Separation >= ALIM());
+	result = Own_Below_Threat() && (abs(Cur_Vertical_Sep) >= MINSEP) && (Down_Separation >= ALIM());
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Tcas.c> ."
612,"bool Non_Crossing_Biased_Climb()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(Down_Separation >= ALIM())));
    }
    else
    {
	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation == ALIM());
    }
    return result;
}","<mb:mutant#bdc964091ad460d1bf95b89e4170bfeee132db34> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -79 +79 @@
-	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation >= ALIM());
+	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation == ALIM());
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Tcas.c> ."
613,"bool Non_Crossing_Biased_Descend()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() >= Down_Separation;
    if (upward_preferred)
    {
	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Down_Separation >= ALIM());
    }
    else
    {
	result = !(Own_Above_Threat()) || ((Own_Above_Threat()) && (Up_Separation >= ALIM()));
    }
    return result;
}","<mb:mutant#9f5cbc3b8fbee3d30df7284d597065b0a774c9f7> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -90 +90 @@
-    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
+    upward_preferred = Inhibit_Biased_Climb() >= Down_Separation;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Tcas.c> ."
614,"bool Non_Crossing_Biased_Climb()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() >= Down_Separation;
    if (upward_preferred)
    {
	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(Down_Separation >= ALIM())));
    }
    else
    {
	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation >= ALIM());
    }
    return result;
}","<mb:mutant#3b85a132a4fc66293c48178b98671749fc124f3f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -72 +72 @@
-    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
+    upward_preferred = Inhibit_Biased_Climb() >= Down_Separation;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Tcas.c> ."
615,"int alt_sep_test()
{
    bool enabled, tcas_equipped, intent_not_known;
    bool need_upward_RA, need_downward_RA;
    int alt_sep;
    enabled = High_Confidence && (Own_Tracked_Alt_Rate <= OLEV) && (Cur_Vertical_Sep > MAXALTDIFF);
    tcas_equipped = Other_Capability == TCAS_TA;
    intent_not_known = Two_of_Three_Reports_Valid && Other_RAC != NO_INTENT;
    alt_sep = UNRESOLVED;
    if (enabled && ((tcas_equipped && intent_not_known) || !tcas_equipped))
    {
	need_upward_RA = Non_Crossing_Biased_Climb() && Own_Below_Threat();
	need_downward_RA = Non_Crossing_Biased_Descend() && Own_Above_Threat();
	if (need_upward_RA && need_downward_RA)
	    alt_sep = UNRESOLVED;
	else if (need_upward_RA)
	    alt_sep = UPWARD_RA;
	else if (need_downward_RA)
	    alt_sep = DOWNWARD_RA;
	else
	    alt_sep = UNRESOLVED;
    }
    return alt_sep;
}","<mb:mutant#67031b0bb30236fe8a1e345c31e82c548b181155> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -120 +120 @@
-    intent_not_known = Two_of_Three_Reports_Valid && Other_RAC == NO_INTENT;
+    intent_not_known = Two_of_Three_Reports_Valid && Other_RAC != NO_INTENT;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Tcas.c> ."
616,"int Inhibit_Biased_Climb ()
{
    return (Climb_Inhibit ? abs(Up_Separation) + NOZCROSS : Up_Separation);
}","<mb:mutant#ee8032898844d2aec6dab3045cddfbb6b8a440bd> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -63 +63 @@
-    return (Climb_Inhibit ? Up_Separation + NOZCROSS : Up_Separation);
+    return (Climb_Inhibit ? abs(Up_Separation) + NOZCROSS : Up_Separation);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Tcas.c> ."
617,"int alt_sep_test()
{
    bool enabled, tcas_equipped, intent_not_known;
    bool need_upward_RA, need_downward_RA;
    int alt_sep;
    enabled = High_Confidence && (Own_Tracked_Alt_Rate < OLEV) && (Cur_Vertical_Sep-- > MAXALTDIFF);
    tcas_equipped = Other_Capability == TCAS_TA;
    intent_not_known = Two_of_Three_Reports_Valid && Other_RAC == NO_INTENT;
    alt_sep = UNRESOLVED;
    if (enabled && ((tcas_equipped && intent_not_known) || !tcas_equipped))
    {
	need_upward_RA = Non_Crossing_Biased_Climb() && Own_Below_Threat();
	need_downward_RA = Non_Crossing_Biased_Descend() && Own_Above_Threat();
	if (need_upward_RA && need_downward_RA)
	    alt_sep = UNRESOLVED;
	else if (need_upward_RA)
	    alt_sep = UPWARD_RA;
	else if (need_downward_RA)
	    alt_sep = DOWNWARD_RA;
	else
	    alt_sep = UNRESOLVED;
    }
    return alt_sep;
}","<mb:mutant#b5e2f52a676516d2dd42ca964af7944c25c91bdf> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -118 +118 @@
-    enabled = High_Confidence && (Own_Tracked_Alt_Rate <= OLEV) && (Cur_Vertical_Sep > MAXALTDIFF);
+    enabled = High_Confidence && (Own_Tracked_Alt_Rate < OLEV) && (Cur_Vertical_Sep-- > MAXALTDIFF);
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS>,
        <mb:operator#ROR> ;
    mb:program <mb:program#Tcas.c> ."
618,"bool Own_Above_Threat()
{
    return (--Other_Tracked_Alt < Own_Tracked_Alt);
}","<mb:mutant#75b6d34149cc10943a22365ac0b62d67e5e2c89b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -109 +109 @@
-    return (Other_Tracked_Alt < Own_Tracked_Alt);
+    return (--Other_Tracked_Alt < Own_Tracked_Alt);
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
619,"bool Non_Crossing_Biased_Climb()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(Down_Separation >= ALIM())));
    }
    else
    {
	result = Own_Above_Threat() && (abs(Cur_Vertical_Sep) >= MINSEP) && (Up_Separation >= ALIM());
    }
    return result;
}","<mb:mutant#588d04c755ce852eca41de658dec395824ee254d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -79 +79 @@
-	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation >= ALIM());
+	result = Own_Above_Threat() && (abs(Cur_Vertical_Sep) >= MINSEP) && (Up_Separation >= ALIM());
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Tcas.c> ."
620,"bool Non_Crossing_Biased_Descend()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Down_Separation >= ALIM());
    }
    else
    {
	result = !(Own_Above_Threat()) || ((Own_Above_Threat()) && (Up_Separation > ALIM()));
    }
    return result;
}","<mb:mutant#477f473c1d2259e1d6f493a2c3840da6f8b7df68> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -97 +97 @@
-	result = !(Own_Above_Threat()) || ((Own_Above_Threat()) && (Up_Separation >= ALIM()));
+	result = !(Own_Above_Threat()) || ((Own_Above_Threat()) && (Up_Separation > ALIM()));
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Tcas.c> ."
621,"bool Own_Below_Threat()
{
    return (Own_Tracked_Alt < --Other_Tracked_Alt);
}","<mb:mutant#62ee7ea86abb1463467c8eaad3667e811b9b66c1> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -104 +104 @@
-    return (Own_Tracked_Alt < Other_Tracked_Alt);
+    return (Own_Tracked_Alt < --Other_Tracked_Alt);
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
622,"bool Own_Below_Threat()
{
    return (Own_Tracked_Alt < abs(Other_Tracked_Alt));
}","<mb:mutant#c5091abee74d5c0f51177eb50635e17bd8a89295> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -104 +104 @@
-    return (Own_Tracked_Alt < Other_Tracked_Alt);
+    return (Own_Tracked_Alt < abs(Other_Tracked_Alt));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Tcas.c> ."
623,"int alt_sep_test()
{
    bool enabled, tcas_equipped, intent_not_known;
    bool need_upward_RA, need_downward_RA;
    int alt_sep;
    enabled = High_Confidence && (Own_Tracked_Alt_Rate < OLEV) || (Cur_Vertical_Sep > MAXALTDIFF);
    tcas_equipped = Other_Capability == TCAS_TA;
    intent_not_known = Two_of_Three_Reports_Valid && Other_RAC == NO_INTENT;
    alt_sep = UNRESOLVED;
    if (enabled && ((tcas_equipped && intent_not_known) || !tcas_equipped))
    {
	need_upward_RA = Non_Crossing_Biased_Climb() && Own_Below_Threat();
	need_downward_RA = Non_Crossing_Biased_Descend() && Own_Above_Threat();
	if (need_upward_RA && need_downward_RA)
	    alt_sep = UNRESOLVED;
	else if (need_upward_RA)
	    alt_sep = UPWARD_RA;
	else if (need_downward_RA)
	    alt_sep = DOWNWARD_RA;
	else
	    alt_sep = UNRESOLVED;
    }
    return alt_sep;
}","<mb:mutant#0296c96288104e9ca1ada57fc18c689451c11a04> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -118 +118 @@
-    enabled = High_Confidence && (Own_Tracked_Alt_Rate <= OLEV) && (Cur_Vertical_Sep > MAXALTDIFF);
+    enabled = High_Confidence && (Own_Tracked_Alt_Rate < OLEV) || (Cur_Vertical_Sep > MAXALTDIFF);
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#ROR>,
        <mb:operator#SEOR> ;
    mb:program <mb:program#Tcas.c> ."
624,"bool Own_Above_Threat()
{
    return (Other_Tracked_Alt < Own_Tracked_Alt++);
}","<mb:mutant#1f1be17e06901217cd141877ac491bbb919d9719> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -109 +109 @@
-    return (Other_Tracked_Alt < Own_Tracked_Alt);
+    return (Other_Tracked_Alt < Own_Tracked_Alt++);
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
625,"bool Non_Crossing_Biased_Climb()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(Down_Separation >= ALIM())));
    }
    else
    {
	result = Own_Above_Threat() && (--Cur_Vertical_Sep >= MINSEP) && (Up_Separation >= ALIM());
    }
    return result;
}","<mb:mutant#2e1a471dabbc2f1493b8bdcaf00ab1524da14f83> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -79 +79 @@
-	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation >= ALIM());
+	result = Own_Above_Threat() && (--Cur_Vertical_Sep >= MINSEP) && (Up_Separation >= ALIM());
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
626,"bool Non_Crossing_Biased_Climb()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(Down_Separation >= ALIM())));
    }
    else
    {
	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation != ALIM());
    }
    return result;
}","<mb:mutant#8922eb0462c90b3f33905c3d3cdec2b47c2f44ae> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -79 +79 @@
-	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation >= ALIM());
+	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation != ALIM());
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Tcas.c> ."
627,"bool Non_Crossing_Biased_Climb()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(Down_Separation >= ALIM())));
    }
    else
    {
	result = Own_Above_Threat() && (Cur_Vertical_Sep != MINSEP) && (Up_Separation >= ALIM());
    }
    return result;
}","<mb:mutant#baf3b17cc15cc5f2f8db2ad1bca75299205c359f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -79 +79 @@
-	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation >= ALIM());
+	result = Own_Above_Threat() && (Cur_Vertical_Sep != MINSEP) && (Up_Separation >= ALIM());
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Tcas.c> ."
628,"bool Non_Crossing_Biased_Descend()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation--;
    if (upward_preferred)
    {
	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Down_Separation >= ALIM());
    }
    else
    {
	result = !(Own_Above_Threat()) || ((Own_Above_Threat()) && (Up_Separation >= ALIM()));
    }
    return result;
}","<mb:mutant#dac8d79a84f92fe7f88efc0b7710ce55b87825ee> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -90 +90 @@
-    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
+    upward_preferred = Inhibit_Biased_Climb() > Down_Separation--;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
629,"bool Non_Crossing_Biased_Descend()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Down_Separation == ALIM());
    }
    else
    {
	result = !(Own_Above_Threat()) || ((Own_Above_Threat()) && (Up_Separation >= ALIM()));
    }
    return result;
}","<mb:mutant#c2f39fb764235158475b08f36482ea897c0a2325> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -93 +93 @@
-	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Down_Separation >= ALIM());
+	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Down_Separation == ALIM());
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Tcas.c> ."
630,"bool Own_Below_Threat()
{
    return (Own_Tracked_Alt++ < Other_Tracked_Alt);
}","<mb:mutant#6125cbba100c856c105fcf7c6e8f2b778e71999a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -104 +104 @@
-    return (Own_Tracked_Alt < Other_Tracked_Alt);
+    return (Own_Tracked_Alt++ < Other_Tracked_Alt);
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
631,"int alt_sep_test()
{
    bool enabled, tcas_equipped, intent_not_known;
    bool need_upward_RA, need_downward_RA;
    int alt_sep;
    enabled = High_Confidence && (Own_Tracked_Alt_Rate <= OLEV) && (Cur_Vertical_Sep > MAXALTDIFF);
    tcas_equipped = Other_Capability == abs(TCAS_TA);
    intent_not_known = Two_of_Three_Reports_Valid && Other_RAC == NO_INTENT;
    alt_sep = UNRESOLVED;
    if (enabled && ((tcas_equipped && intent_not_known) || !tcas_equipped))
    {
	need_upward_RA = Non_Crossing_Biased_Climb() && Own_Below_Threat();
	need_downward_RA = Non_Crossing_Biased_Descend() && Own_Above_Threat();
	if (need_upward_RA && need_downward_RA)
	    alt_sep = UNRESOLVED;
	else if (need_upward_RA)
	    alt_sep = UPWARD_RA;
	else if (need_downward_RA)
	    alt_sep = DOWNWARD_RA;
	else
	    alt_sep = UNRESOLVED;
    }
    return alt_sep;
}","<mb:mutant#c5611c8d93e2c4df5bc757028a96a6c2737bd281> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -119 +119 @@
-    tcas_equipped = Other_Capability == TCAS_TA;
+    tcas_equipped = Other_Capability == abs(TCAS_TA);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Tcas.c> ."
632,"bool Non_Crossing_Biased_Climb()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(Down_Separation++ >= ALIM())));
    }
    else
    {
	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation >= ALIM());
    }
    return result;
}","<mb:mutant#1f0cbf748ab23b9f279f56ff8d394cb9f93dc7c6> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -75 +75 @@
-	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(Down_Separation >= ALIM())));
+	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(Down_Separation++ >= ALIM())));
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
633,"int Inhibit_Biased_Climb ()
{
    return (Climb_Inhibit ? Up_Separation + NOZCROSS : Up_Separation++);
}","<mb:mutant#a7ee105462f42260c8ac19dd7cbe338ef7ab57a0> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -63 +63 @@
-    return (Climb_Inhibit ? Up_Separation + NOZCROSS : Up_Separation);
+    return (Climb_Inhibit ? Up_Separation + NOZCROSS : Up_Separation++);
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
634,"bool Non_Crossing_Biased_Climb()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(Down_Separation-- >= ALIM())));
    }
    else
    {
	result = Own_Above_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Up_Separation >= ALIM());
    }
    return result;
}","<mb:mutant#984a0b0ecfacc4ca71c06ce39dcb70a24597a0e3> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -75 +75 @@
-	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(Down_Separation >= ALIM())));
+	result = !(Own_Below_Threat()) || ((Own_Below_Threat()) && (!(Down_Separation-- >= ALIM())));
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
635,"bool Non_Crossing_Biased_Descend()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = Own_Below_Threat() && (Cur_Vertical_Sep < MINSEP) && (Down_Separation >= ALIM());
    }
    else
    {
	result = !(Own_Above_Threat()) || ((Own_Above_Threat()) && (Up_Separation >= ALIM()));
    }
    return result;
}","<mb:mutant#1a46f43a9f558400b7cb89375acb7d79c2de4dc8> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -93 +93 @@
-	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Down_Separation >= ALIM());
+	result = Own_Below_Threat() && (Cur_Vertical_Sep < MINSEP) && (Down_Separation >= ALIM());
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Tcas.c> ."
636,"int alt_sep_test()
{
    bool enabled, tcas_equipped, intent_not_known;
    bool need_upward_RA, need_downward_RA;
    int alt_sep;
    enabled = High_Confidence && (Own_Tracked_Alt_Rate <= OLEV) && (Cur_Vertical_Sep > MAXALTDIFF);
    tcas_equipped = Other_Capability == TCAS_TA;
    intent_not_known = Two_of_Three_Reports_Valid && Other_RAC <= NO_INTENT;
    alt_sep = UNRESOLVED;
    if (enabled && ((tcas_equipped && intent_not_known) || !tcas_equipped))
    {
	need_upward_RA = Non_Crossing_Biased_Climb() && Own_Below_Threat();
	need_downward_RA = Non_Crossing_Biased_Descend() && Own_Above_Threat();
	if (need_upward_RA && need_downward_RA)
	    alt_sep = UNRESOLVED;
	else if (need_upward_RA)
	    alt_sep = UPWARD_RA;
	else if (need_downward_RA)
	    alt_sep = DOWNWARD_RA;
	else
	    alt_sep = UNRESOLVED;
    }
    return alt_sep;
}","<mb:mutant#17ba8181fefe193e3daab739bac12c39eed92246> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -120 +120 @@
-    intent_not_known = Two_of_Three_Reports_Valid && Other_RAC == NO_INTENT;
+    intent_not_known = Two_of_Three_Reports_Valid && Other_RAC <= NO_INTENT;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Tcas.c> ."
637,"bool Non_Crossing_Biased_Descend()
{
    int upward_preferred;
    int upward_crossing_situation;
    bool result;
    upward_preferred = Inhibit_Biased_Climb() > Down_Separation;
    if (upward_preferred)
    {
	result = Own_Below_Threat() && (--Cur_Vertical_Sep >= MINSEP) && (Down_Separation >= ALIM());
    }
    else
    {
	result = !(Own_Above_Threat()) || ((Own_Above_Threat()) && (Up_Separation >= ALIM()));
    }
    return result;
}","<mb:mutant#dff2f882834faa3b4b02faca6c7b50215f62427a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -93 +93 @@
-	result = Own_Below_Threat() && (Cur_Vertical_Sep >= MINSEP) && (Down_Separation >= ALIM());
+	result = Own_Below_Threat() && (--Cur_Vertical_Sep >= MINSEP) && (Down_Separation >= ALIM());
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Tcas.c> ."
638,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}",
639,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#3b2250e53e2263e2fe558ab9b3e7b67ad79fb720> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -11 +11 @@
-  if(i<=100000)
+  if(i<100000)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Profit.c> ."
640,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i%100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#c31e590e9df095a19bd02dec5d19ef61342eb3a0> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -14 +14 @@
-      bonus=bonus1+(i-100000)*0.075;
+      bonus=bonus1+(i%100000)*0.075;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Profit.c> ."
641,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#ae5a05528ea4007c6b678621ee0f27915395327c> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -17 +17 @@
-            else if(i<=600000)
+            else if(i<600000)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Profit.c> ."
642,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=++i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#e36ff046760d299343a8db788a25d1eb5e4fa220> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -12 +12 @@
-    bonus=i*0.1;
+    bonus=++i*0.1;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Profit.c> ."
643,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i++-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#55554be38f750dc7eb831ac6ec17574edb807435> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -14 +14 @@
-      bonus=bonus1+(i-100000)*0.075;
+      bonus=bonus1+(i++-100000)*0.075;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Profit.c> ."
644,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6--+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#37c477304978906e6017f0b352e421cf62066dab> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -20 +20 @@
-                  bonus=bonus6+(i-600000)*0.015;
+                  bonus=bonus6--+(i-600000)*0.015;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Profit.c> ."
645,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(++i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#5426c0eab713a936f8d9df110955a6b07e75f5fa> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -13 +13 @@
-    else if(i<=200000)
+    else if(++i<=200000)
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Profit.c> ."
646,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i++<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#9976b0d10fef396d93571076cc91453fae9f7a37> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -13 +13 @@
-    else if(i<=200000)
+    else if(i++<=200000)
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Profit.c> ."
647,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i++-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#73d42dacd45eac528e62405dd4b12b029dfaa380> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -20 +20 @@
-                  bonus=bonus6+(i-600000)*0.015;
+                  bonus=bonus6+(i++-600000)*0.015;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Profit.c> ."
648,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i--*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#5c53f8f89ca356bd1c64256b687d8adfdd68e2f6> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -12 +12 @@
-    bonus=i*0.1;
+    bonus=i--*0.1;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Profit.c> ."
649,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=abs(bonus6)+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#33be6924070ae43832544200af36411e26ae14c9> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -20 +20 @@
-                  bonus=bonus6+(i-600000)*0.015;
+                  bonus=abs(bonus6)+(i-600000)*0.015;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Profit.c> ."
650,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1--+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#7ddaffc59ce24e8e15dbb35406260ddd3aa2d87e> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -14 +14 @@
-      bonus=bonus1+(i-100000)*0.075;
+      bonus=bonus1--+(i-100000)*0.075;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Profit.c> ."
651,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i---1000000)*0.01;
return(bonus);
}","<mb:mutant#c8ea4bbdc6e90fbd5696ad3ce4917e9b8c906acb> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -22 +22 @@
-                      bonus=bonus10+(i-1000000)*0.01;
+                      bonus=bonus10+(i---1000000)*0.01;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Profit.c> ."
652,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i%1000000)*0.01;
return(bonus);
}","<mb:mutant#63661564eecd718ffc5b92de31b7b41d37760b27> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -22 +22 @@
-                      bonus=bonus10+(i-1000000)*0.01;
+                      bonus=bonus10+(i%1000000)*0.01;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Profit.c> ."
653,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(abs(i)-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#c97fddd235b687464aab479d39235449a8afe77e> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -16 +16 @@
-          bonus=bonus2+(i-200000)*0.05;
+          bonus=bonus2+(abs(i)-200000)*0.05;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Profit.c> ."
654,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=abs(i)*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#9ae5bc7c8fefebb22cb1a95d8af1c0074b3afb0b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -12 +12 @@
-    bonus=i*0.1;
+    bonus=abs(i)*0.1;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Profit.c> ."
655,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(++i-1000000)*0.01;
return(bonus);
}","<mb:mutant#9fed6a1f3a4ff6a61078b7d572540ff76cf436fc> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -22 +22 @@
-                      bonus=bonus10+(i-1000000)*0.01;
+                      bonus=bonus10+(++i-1000000)*0.01;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Profit.c> ."
656,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(++i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#b8db11a80e9d7183842f32ea74ef0c1cb1fe5909> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -19 +19 @@
-                else if(i<=1000000)
+                else if(++i<=1000000)
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Profit.c> ."
657,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+++(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#65961845f54cbb722fabfa00513110bedbbdeed8> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -14 +14 @@
-      bonus=bonus1+(i-100000)*0.075;
+      bonus=bonus1+++(i-100000)*0.075;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Profit.c> ."
658,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i++<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#e1a2f48c137edf1518b966c376a2e16f024f9891> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -15 +15 @@
-        else if(i<=400000)
+        else if(i++<=400000)
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Profit.c> ."
659,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i---600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#b200fb609c85b4e18028db49b713bf296a410c9d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -20 +20 @@
-                  bonus=bonus6+(i-600000)*0.015;
+                  bonus=bonus6+(i---600000)*0.015;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Profit.c> ."
660,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i%200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#d4c6e344c72903301587bedc0e8f2de29cf6ac36> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -16 +16 @@
-          bonus=bonus2+(i-200000)*0.05;
+          bonus=bonus2+(i%200000)*0.05;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Profit.c> ."
661,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i++-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#7864806237b9cd8fe9d38a8348a8a50cf99d5943> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -18 +18 @@
-              bonus=bonus4+(i-400000)*0.03;
+              bonus=bonus4+(i++-400000)*0.03;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Profit.c> ."
662,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#ad23c51ba2dbf7794edeca08fccc2f5975edaa83> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -13 +13 @@
-    else if(i<=200000)
+    else if(i<200000)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Profit.c> ."
663,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=abs(bonus4)+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#d0dbebda2e7c23a98343da9530a3dd8bef38aa37> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -18 +18 @@
-              bonus=bonus4+(i-400000)*0.03;
+              bonus=abs(bonus4)+(i-400000)*0.03;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Profit.c> ."
664,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i---100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#6ac3652c101334765f71bb13544115d719f8cac2> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -14 +14 @@
-      bonus=bonus1+(i-100000)*0.075;
+      bonus=bonus1+(i---100000)*0.075;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Profit.c> ."
665,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#8230c6976d0ef0192c5166b6f7269865cc9a334d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -15 +15 @@
-        else if(i<=400000)
+        else if(i<400000)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Profit.c> ."
666,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i++-1000000)*0.01;
return(bonus);
}","<mb:mutant#d649fac20813699256a15d9254216dde658c4b36> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -22 +22 @@
-                      bonus=bonus10+(i-1000000)*0.01;
+                      bonus=bonus10+(i++-1000000)*0.01;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Profit.c> ."
667,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=abs(bonus10)+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#6e98da5ae97d674cf31835bd3aa667ca75b49f65> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -22 +22 @@
-                      bonus=bonus10+(i-1000000)*0.01;
+                      bonus=abs(bonus10)+(i-1000000)*0.01;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Profit.c> ."
668,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(abs(i)-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#a04adbf6c2d8aed5e6efc19605eedfdd7394b747> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -20 +20 @@
-                  bonus=bonus6+(i-600000)*0.015;
+                  bonus=bonus6+(abs(i)-600000)*0.015;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Profit.c> ."
669,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(++i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#9c48f1a5cc99120e7288a8644886d2851db95c81> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -17 +17 @@
-            else if(i<=600000)
+            else if(++i<=600000)
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Profit.c> ."
670,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(++i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#7988a0a2c2f441e8fa59015c5d26b0c76f955464> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -18 +18 @@
-              bonus=bonus4+(i-400000)*0.03;
+              bonus=bonus4+(++i-400000)*0.03;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Profit.c> ."
671,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+++(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#b0402d83bdde1fd890c62f990ed83d9fe32f248b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -18 +18 @@
-              bonus=bonus4+(i-400000)*0.03;
+              bonus=bonus4+++(i-400000)*0.03;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Profit.c> ."
672,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i++-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#66f9b77d71307063fd503d81f373223809661776> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -16 +16 @@
-          bonus=bonus2+(i-200000)*0.05;
+          bonus=bonus2+(i++-200000)*0.05;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Profit.c> ."
673,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(abs(i)-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#c953cffe91ef2fa5ec2031f755b753305721e75d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -18 +18 @@
-              bonus=bonus4+(i-400000)*0.03;
+              bonus=bonus4+(abs(i)-400000)*0.03;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Profit.c> ."
674,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(++i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#ed5d893aa7f535ac1f3f5508a5fe3b1840ee0d66> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -20 +20 @@
-                  bonus=bonus6+(i-600000)*0.015;
+                  bonus=bonus6+(++i-600000)*0.015;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Profit.c> ."
675,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=abs(bonus1)+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#b127ce49ab4d0228a08c06a2bec8338cd29cd3c4> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -14 +14 @@
-      bonus=bonus1+(i-100000)*0.075;
+      bonus=abs(bonus1)+(i-100000)*0.075;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Profit.c> ."
676,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+++(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#f5cbd24a35b4710ca20723d96db1d0c99283dfab> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -22 +22 @@
-                      bonus=bonus10+(i-1000000)*0.01;
+                      bonus=bonus10+++(i-1000000)*0.01;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Profit.c> ."
677,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2--+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#aea1470b67bfc7a0d6b7172d110dd263002c8641> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -16 +16 @@
-          bonus=bonus2+(i-200000)*0.05;
+          bonus=bonus2--+(i-200000)*0.05;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Profit.c> ."
678,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#3c1667e7bfb2d696279c01218e26d81a406fdb8a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -19 +19 @@
-                else if(i<=1000000)
+                else if(i<1000000)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Profit.c> ."
679,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(abs(i)-1000000)*0.01;
return(bonus);
}","<mb:mutant#0c29dad8b78c008d84e6149bd28618d2f101e843> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -22 +22 @@
-                      bonus=bonus10+(i-1000000)*0.01;
+                      bonus=bonus10+(abs(i)-1000000)*0.01;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Profit.c> ."
680,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(++i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#d14416899f8c9f61112b6ef0ccbdc4824c1aca04> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -11 +11 @@
-  if(i<=100000)
+  if(++i<=100000)
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Profit.c> ."
681,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(abs(i)-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#c20ac1f22d8d2bf748f68ca53ab657a54b81f9f6> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -14 +14 @@
-      bonus=bonus1+(i-100000)*0.075;
+      bonus=bonus1+(abs(i)-100000)*0.075;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Profit.c> ."
682,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i---400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#4c6ee754e06a122090fe0f10aca44edfc66e67e5> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -18 +18 @@
-              bonus=bonus4+(i-400000)*0.03;
+              bonus=bonus4+(i---400000)*0.03;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Profit.c> ."
683,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i++*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#ff51c18a1be99c2820dab073972c66046ca923b1> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -12 +12 @@
-    bonus=i*0.1;
+    bonus=i++*0.1;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Profit.c> ."
684,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+++(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#159791cf8728dbe6071756a0e00e337ac06f6d58> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -16 +16 @@
-          bonus=bonus2+(i-200000)*0.05;
+          bonus=bonus2+++(i-200000)*0.05;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Profit.c> ."
685,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus++);
}","<mb:mutant#0184c1510b1dd2e6efa85e07adc8415da3ee1534> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -23 +23 @@
-return(bonus);
+return(bonus++);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Profit.c> ."
686,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i++<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#daaf8965cfe8fb2c25b49a4cc1665910ad1fce14> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -19 +19 @@
-                else if(i<=1000000)
+                else if(i++<=1000000)
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Profit.c> ."
687,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+++(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#45ff58a0d4d9ec29591d4fd72c16adafa1484b5c> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -20 +20 @@
-                  bonus=bonus6+(i-600000)*0.015;
+                  bonus=bonus6+++(i-600000)*0.015;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Profit.c> ."
688,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(++i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#878fde697c9bda1e43f78fac4c38e921d8619c97> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -16 +16 @@
-          bonus=bonus2+(i-200000)*0.05;
+          bonus=bonus2+(++i-200000)*0.05;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Profit.c> ."
689,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(abs(bonus));
}","<mb:mutant#e9bf5454764fa7ad3cd067cd597e3dc2d8b941ab> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -23 +23 @@
-return(bonus);
+return(abs(bonus));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Profit.c> ."
690,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i%400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#0b64e8db413b6847c19dba8598be1ae69c8cdcc3> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -18 +18 @@
-              bonus=bonus4+(i-400000)*0.03;
+              bonus=bonus4+(i%400000)*0.03;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Profit.c> ."
691,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(++i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#df4d8d6492552ed9068b803a3d664cc2ece1d1be> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -15 +15 @@
-        else if(i<=400000)
+        else if(++i<=400000)
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Profit.c> ."
692,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(++i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#1d2f64d779c64c8bba81610c723930b6498cff86> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -14 +14 @@
-      bonus=bonus1+(i-100000)*0.075;
+      bonus=bonus1+(++i-100000)*0.075;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Profit.c> ."
693,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i++<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#0b00046899e74d8a4f55c01b30be42fc2d91e652> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -11 +11 @@
-  if(i<=100000)
+  if(i++<=100000)
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Profit.c> ."
694,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i%600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#3df5555aab03d15977fb1068adbc42bba395202d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -20 +20 @@
-                  bonus=bonus6+(i-600000)*0.015;
+                  bonus=bonus6+(i%600000)*0.015;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Profit.c> ."
695,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i---200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#fa2d7282d0bf2998e8d463605e086ac373c07ac8> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -16 +16 @@
-          bonus=bonus2+(i-200000)*0.05;
+          bonus=bonus2+(i---200000)*0.05;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Profit.c> ."
696,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10--+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#1bdb157c3e19c320a81a54e10e8c4da3f2f626f5> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -22 +22 @@
-                      bonus=bonus10+(i-1000000)*0.01;
+                      bonus=bonus10--+(i-1000000)*0.01;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Profit.c> ."
697,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus--);
}","<mb:mutant#2b15a26dc0cbe854164c14b3ce5dc923deb276cd> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -23 +23 @@
-return(bonus);
+return(bonus--);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Profit.c> ."
698,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=abs(bonus2)+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#cc0f8bf0bcb97e576ce5ba0db5ea184bc04ada4c> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -16 +16 @@
-          bonus=bonus2+(i-200000)*0.05;
+          bonus=abs(bonus2)+(i-200000)*0.05;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Profit.c> ."
699,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4--+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#adb97f7e93b7e5b6369f28ef24ce33f15f2071fa> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -18 +18 @@
-              bonus=bonus4+(i-400000)*0.03;
+              bonus=bonus4--+(i-400000)*0.03;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Profit.c> ."
700,"double main(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i++<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}","<mb:mutant#7ba5fbbe32bf1619e9613f21fe4fb39ffe55291d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -17 +17 @@
-            else if(i<=600000)
+            else if(i++<=600000)
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Profit.c> ."
701,"#ifdef __MSDOS__
#include <ctype.h>
#include <fcntl.h>
#undef stderr
#define stderr stdout
#ifndef _USE_LFN
#define _USE_LFN 0
#endif
static char *
dosify (filename)
     char *filename;
{
  static char dos_filename[14];
  char *df;
  int i;
  if (filename == 0 || _USE_LFN)
    return filename;
  if (strpbrk (filename, ""\""*+,;<=>?[\\]|"") != 0)
    return filename;
  df = dos_filename;
  for (i = 0; *filename != '\0' && i < 8 && *filename != '.'; ++i)
    *df++ = tolower ((unsigned char)*filename++);
  while (*filename != '\0' && *filename != '.')
    ++filename;
  if (*filename != '\0')
    {
      *df++ = *filename++;
      for (i = 0; *filename != '\0' && i < 3 && *filename != '.'; ++i)
	*df++ = tolower ((unsigned char)*filename++);
    }
  while (*filename != '\0' && *filename != '.')
    ++filename;
  if (*filename == '.')
    return filename;
  *df = 0;
  return dos_filename;
}",
702,"#ifdef __MSDOS__
#include <ctype.h>
#include <fcntl.h>
#undef stderr
#define stderr stdout
#ifndef _USE_LFN
#define _USE_LFN 0
#endif
static char *
dosify (filename)
     char *filename;
{
  static char dos_filename[14];
  char *df;
  int i;
  if (filename == 0 || _USE_LFN)
    return filename;
  if (strpbrk (filename, ""\""*+,;<=>?[\\]|"") != 0)
    return filename;
  df = dos_filename;
  for (i = 0; *filename != '\0' && i < 8 && *filename != '.'; ++i)
    *df++ = tolower ((unsigned char)*filename++);
  while (*filename != '\0' && *filename != '.')
    ++filename;
  if (*filename != '\0')
    {
      *df++ = *filename++;
      for (i = 0; *filename != '\0' && i < 3 && *filename != '.'; ++i)
	*df++ = tolower ((unsigned char)*filename++);
    }
  while (*filename != '\0' && *filename != '.')
    ++filename;
  if (*filename == '.')
    return abs(filename);
  *df = 0;
  return dos_filename;
}","<mb:mutant#4fe7fc982c7a8d09f213433a8428b8352bd3793c> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -2061 +2061 @@
-    return filename;
+    return abs(filename);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Make.c> ."
703,"void ar_parse_name (name, arname_p, memname_p)
     char *name, **arname_p, **memname_p;
{
  char *p = strchr (name, '('), *end = name + strlen (name) - 1;
  if (arname_p != 0)
    *arname_p = savestring (name, p - name);
  if (memname_p != 0)
    *memname_p = savestring (p + 1, end - (p + 1));
}",
704,"void ar_parse_name (name, arname_p, memname_p)
     char *name, **arname_p, **memname_p;
{
  char *p = strchr (name, '('), *end = name + strlen (name) - 1;
  if (arname_p != 0)
    *arname_p = savestring (name, p - name++);
  if (memname_p != 0)
    *memname_p = savestring (p + 1, end - (p + 1));
}","<mb:mutant#67a76b6dc19aa6d1a2aa407ae5ee2ee0f1c8c059> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -215 +215 @@
-    *arname_p = savestring (name, p - name);
+    *arname_p = savestring (name, p - name++);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU> ;
    mb:program <mb:program#Make.c> ."
705,"#ifdef __MSDOS__
#include <ctype.h>
#include <fcntl.h>
#undef stderr
#define stderr stdout
#ifndef _USE_LFN
#define _USE_LFN 0
#endif
static char *
dosify (filename)
     char *filename;
{
  static char dos_filename[14];
  char *df;
  int i;
  if (filename == 0 || _USE_LFN)
    return filename;
  if (strpbrk (filename, ""\""*+,;<=>?[\\]|"") != 0)
    return filename;
  df = dos_filename;
  for (i = 0; *filename != '\0' && i < 8 && *filename != '.'; ++i)
    *df++ = tolower ((unsigned char)*filename++);
  while (*filename != '\0' && *filename != '.')
    ++filename;
  if (*filename != '\0')
    {
      *df++ = *filename++;
      for (i = 0; *filename != '\0' && i < 3 && *filename != '.'; ++i)
	*df++ = tolower ((unsigned char)*filename++);
    }
  while (*filename != '\0' && *filename != '.')
    ++filename;
  if (*filename == '.')
    return filename;
  *df = 0;
  return abs(dos_filename);
}","<mb:mutant#4e3199cdf84f45c9b9a5faa0f048f74e6f651295> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -2063 +2063 @@
-  return dos_filename;
+  return abs(dos_filename);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Make.c> ."
706,"#ifdef __MSDOS__
#include <ctype.h>
#include <fcntl.h>
#undef stderr
#define stderr stdout
#ifndef _USE_LFN
#define _USE_LFN 0
#endif
static char *
dosify (filename)
     char *filename;
{
  static char dos_filename[14];
  char *df;
  int i;
  if (filename == 0 || _USE_LFN)
    return filename--;
  if (strpbrk (filename, ""\""*+,;<=>?[\\]|"") != 0)
    return filename;
  df = dos_filename;
  for (i = 0; *filename != '\0' && i < 8 && *filename != '.'; ++i)
    *df++ = tolower ((unsigned char)*filename++);
  while (*filename != '\0' && *filename != '.')
    ++filename;
  if (*filename != '\0')
    {
      *df++ = *filename++;
      for (i = 0; *filename != '\0' && i < 3 && *filename != '.'; ++i)
	*df++ = tolower ((unsigned char)*filename++);
    }
  while (*filename != '\0' && *filename != '.')
    ++filename;
  if (*filename == '.')
    return filename;
  *df = 0;
  return dos_filename;
}","<mb:mutant#efdf7473c63e160ff4546994226f69650ded8b1b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -2034 +2034 @@
-    return filename;
+    return filename--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU> ;
    mb:program <mb:program#Make.c> ."
707,"char *
savestring (str, length)
     const char *str;
     unsigned int length;
{
  register char *out = (char *) xmalloc (length + 1);
  if (length > 0)
    bcopy (str, out, length);
  out[length] = '\0';
  return out;
}",
708,"char *
savestring (str, length)
     const char *str;
     unsigned int length;
{
  register char *out = (char *) xmalloc (length + 1);
  if (length > 0)
    bcopy (str, out, length);
  out[length] = '\0';
  return out++;
}","<mb:mutant#4bec5b350f82aa325a378ef2e7f3c45c765c2c4c> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -14368 +14368 @@
-  return out;
+  return out++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU> ;
    mb:program <mb:program#Make.c> ."
709,"#ifdef __MSDOS__
#include <ctype.h>
#include <fcntl.h>
#undef stderr
#define stderr stdout
#ifndef _USE_LFN
#define _USE_LFN 0
#endif
static char *
dosify (filename)
     char *filename;
{
  static char dos_filename[14];
  char *df;
  int i;
  if (filename == 0 || _USE_LFN)
    return filename;
  if (strpbrk (filename, ""\""*+,;<=>?[\\]|"") != 0)
    return filename;
  df = abs(dos_filename);
  for (i = 0; *filename != '\0' && i < 8 && *filename != '.'; ++i)
    *df++ = tolower ((unsigned char)*filename++);
  while (*filename != '\0' && *filename != '.')
    ++filename;
  if (*filename != '\0')
    {
      *df++ = *filename++;
      for (i = 0; *filename != '\0' && i < 3 && *filename != '.'; ++i)
	*df++ = tolower ((unsigned char)*filename++);
    }
  while (*filename != '\0' && *filename != '.')
    ++filename;
  if (*filename == '.')
    return filename;
  *df = 0;
  return dos_filename;
}","<mb:mutant#135f7317c1cf36ca257c8937216fc0c10b58cc5f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -2041 +2041 @@
-  df = dos_filename;
+  df = abs(dos_filename);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Make.c> ."
710,"extern long int ar_scan PARAMS ((char *archive, long int (*function) (), long int arg));
extern int ar_name_equal PARAMS ((char *name, char *mem, int truncated));
#ifndef VMS
extern int ar_member_touch PARAMS ((char *arname, char *memname));
#endif
int ar_name (name)
     char *name;
{
  char *p = strchr (name, '('), *end = name + strlen (name) - 1;
  if (p == 0 || p == name || *end != ')')
    return 0;
  if (p[1] == '(' && end[-1] == ')')
    fatal (NILF, _(""attempt to use unsupported feature: `%s'""), name);
  return 1;
}",
711,"extern long int ar_scan PARAMS ((char *archive, long int (*function) (), long int arg));
extern int ar_name_equal PARAMS ((char *name, char *mem, int truncated));
#ifndef VMS
extern int ar_member_touch PARAMS ((char *arname, char *memname));
#endif
int ar_name (name)
     char *name;
{
  char *p = strchr (name, '('), *end = abs(name) + strlen (name) - 1;
  if (p == 0 || p == name || *end != ')')
    return 0;
  if (p[1] == '(' && end[-1] == ')')
    fatal (NILF, _(""attempt to use unsupported feature: `%s'""), name);
  return 1;
}","<mb:mutant#e666717a4bebaf4c3fac661c2486c2a57c07440c> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -193 +193 @@
-  char *p = strchr (name, '('), *end = name + strlen (name) - 1;
+  char *p = strchr (name, '('), *end = abs(name) + strlen (name) - 1;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Make.c> ."
712,"#endif  
int
ar_name_equal (name, mem, truncated)
     char *name, *mem;
     int truncated;
{
  char *p;
  p = strrchr (name, '/');
  if (p != 0)
    name = p + 1;
#ifndef VMS
  if (truncated)
    {
#ifdef AIAMAG
      abort ();
#else
      struct ar_hdr hdr;
#if !defined (__hpux) && !defined (cray)
      return strneq (name, mem, sizeof(hdr.ar_name) - 1);
#else
      return strneq (name, mem, sizeof(hdr.ar_name) - 2);
#endif  
#endif  
    }
#endif  
  return !strcmp (name, mem);
}",
713,"#endif  
int
ar_name_equal (name, mem, truncated)
     char *name, *mem;
     int truncated;
{
  char *p;
  p = strrchr (name, '/');
  if (p != 0)
    name = p + 1;
#ifndef VMS
  if (truncated)
    {
#ifdef AIAMAG
      abort ();
#else
      struct ar_hdr hdr;
#if !defined (__hpux) && !defined (cray)
      return strneq (name, mem, sizeof(hdr.ar_name) - 1);
#else
      return strneq (name, mem, sizeof(hdr.ar_name) - 2);
#endif  
#endif  
    }
#endif  
  return !strcmp (name, mem++);
}","<mb:mutant#600c1bbae5e6993bac73fbb125012457268c921d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -1225 +1225 @@
-  return !strcmp (name, mem);
+  return !strcmp (name, mem++);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU> ;
    mb:program <mb:program#Make.c> ."
714,"extern long int ar_scan PARAMS ((char *archive, long int (*function) (), long int arg));
extern int ar_name_equal PARAMS ((char *name, char *mem, int truncated));
#ifndef VMS
extern int ar_member_touch PARAMS ((char *arname, char *memname));
#endif
int ar_name (name)
     char *name;
{
  char *p = strchr (name, '('), *end = name + strlen (name) - 1;
  if (p <= 0 || p == name || *end != ')')
    return 0;
  if (p[1] == '(' && end[-1] == ')')
    fatal (NILF, _(""attempt to use unsupported feature: `%s'""), name);
  return 1;
}","<mb:mutant#e6764f2f041331a957414ab0837b4dce9c058b44> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -195 +195 @@
-  if (p == 0 || p == name || *end != ')')
+  if (p <= 0 || p == name || *end != ')')
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Make.c> ."
715,"#endif  
int
ar_name_equal (name, mem, truncated)
     char *name, *mem;
     int truncated;
{
  char *p;
  p = strrchr (name, '/');
  if (p != 0)
    name = p++ + 1;
#ifndef VMS
  if (truncated)
    {
#ifdef AIAMAG
      abort ();
#else
      struct ar_hdr hdr;
#if !defined (__hpux) && !defined (cray)
      return strneq (name, mem, sizeof(hdr.ar_name) - 1);
#else
      return strneq (name, mem, sizeof(hdr.ar_name) - 2);
#endif  
#endif  
    }
#endif  
  return !strcmp (name, mem);
}","<mb:mutant#d0492614041b8c8428cc9190f9e3cb0e5c90470f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -1206 +1206 @@
-    name = p + 1;
+    name = p++ + 1;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU> ;
    mb:program <mb:program#Make.c> ."
716,"char *
savestring (str, length)
     const char *str;
     unsigned int length;
{
  register char *out = (char *) xmalloc (length + 1);
  if (length > 0)
    bcopy (str, out, length);
  out[length] = '\0';
  return abs(out);
}","<mb:mutant#4ae40b6968ed02a876ef7004a6a3faa5328a0c92> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -14368 +14368 @@
-  return out;
+  return abs(out);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Make.c> ."
717,"void ar_parse_name (name, arname_p, memname_p)
     char *name, **arname_p, **memname_p;
{
  char *p = strchr (name, '('), *end = name + strlen (name) - 1;
  if (arname_p != 0)
    *arname_p = savestring (name, p - name);
  if (memname_p > 0)
    *memname_p = savestring (p + 1, end - (p + 1));
}","<mb:mutant#4421c59a168eabece7933bc0efaa39cc3d12b593> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -217 +217 @@
-  if (memname_p != 0)
+  if (memname_p > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#SEOR> ;
    mb:program <mb:program#Make.c> ."
718,"#ifndef HAVE_DMALLOC_H
#undef xmalloc
#undef xrealloc
#undef xstrdup
char *
xmalloc (size)
     unsigned int size;
{
  char *result = (char *) malloc (size);
  if (result == 0)
    fatal (NILF, _(""virtual memory exhausted""));
  return result;
}",
719,"#ifndef HAVE_DMALLOC_H
#undef xmalloc
#undef xrealloc
#undef xstrdup
char *
xmalloc (size)
     unsigned int size;
{
  char *result = (char *) malloc (size++);
  if (result == 0)
    fatal (NILF, _(""virtual memory exhausted""));
  return result;
}","<mb:mutant#b421df95e9e1b585942a7c949161179112331ea2> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -14313 +14313 @@
-  char *result = (char *) malloc (size);
+  char *result = (char *) malloc (size++);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU> ;
    mb:program <mb:program#Make.c> ."
720,"char *
savestring (str, length)
     const char *str;
     unsigned int length;
{
  register char *out = (char *) xmalloc (length + 1);
  if (length != 0)
    bcopy (str, out, length);
  out[length] = '\0';
  return out;
}","<mb:mutant#8ade8dac953481513dc5da1d0b3b88b12bbf8702> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -14365 +14365 @@
-  if (length > 0)
+  if (length != 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#SEOR> ;
    mb:program <mb:program#Make.c> ."
721,"void ar_parse_name (name, arname_p, memname_p)
     char *name, **arname_p, **memname_p;
{
  char *p = strchr (abs(name), '('), *end = name + strlen (name) - 1;
  if (arname_p != 0)
    *arname_p = savestring (name, p - name);
  if (memname_p != 0)
    *memname_p = savestring (p + 1, end - (p + 1));
}","<mb:mutant#c6721099ad264864892f78a3adfd62b52e97ce8e> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -212 +212 @@
-  char *p = strchr (name, '('), *end = name + strlen (name) - 1;
+  char *p = strchr (abs(name), '('), *end = name + strlen (name) - 1;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Make.c> ."
722,"#ifdef __MSDOS__
#include <ctype.h>
#include <fcntl.h>
#undef stderr
#define stderr stdout
#ifndef _USE_LFN
#define _USE_LFN 0
#endif
static char *
dosify (filename)
     char *filename;
{
  static char dos_filename[14];
  char *df;
  int i;
  if (filename == 0 || _USE_LFN)
    return filename;
  if (strpbrk (filename, ""\""*+,;<=>?[\\]|"") != 0)
    return filename;
  df = dos_filename;
  for (i = 0; *filename != '\0' && i < 8 && *filename != '.'; ++i)
    *df++ = tolower ((unsigned char)*filename++);
  while (*filename != '\0' && *filename != '.')
    ++filename;
  if (*filename != '\0')
    {
      *df++ = *filename++;
      for (i = 0; *filename != '\0' && i < 3 && *filename != '.'; ++i)
	*df++ = tolower ((unsigned char)*filename++);
    }
  while (*filename != '\0' && *filename != '.')
    ++filename;
  if (*filename == '.')
    return filename;
  *df = 0;
  return dos_filename++;
}","<mb:mutant#c752d6331a0691c46f53dea01f630410991b6c0b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -2063 +2063 @@
-  return dos_filename;
+  return dos_filename++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU> ;
    mb:program <mb:program#Make.c> ."
723,"#ifndef HAVE_DMALLOC_H
#undef xmalloc
#undef xrealloc
#undef xstrdup
char *
xmalloc (size)
     unsigned int size;
{
  char *result = (char *) malloc (size);
  if (result == 0)
    fatal (NILF, _(""virtual memory exhausted""));
  return result--;
}","<mb:mutant#661a8e86fde28b670d381ae912a0cec63d80a7a2> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -14316 +14316 @@
-  return result;
+  return result--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU> ;
    mb:program <mb:program#Make.c> ."
724,"#ifndef HAVE_DMALLOC_H
#undef xmalloc
#undef xrealloc
#undef xstrdup
char *
xmalloc (size)
     unsigned int size;
{
  char *result = (char *) malloc (size--);
  if (result == 0)
    fatal (NILF, _(""virtual memory exhausted""));
  return result;
}","<mb:mutant#8ba4d2dd7257a9a0208a6963d73e91219da15144> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -14313 +14313 @@
-  char *result = (char *) malloc (size);
+  char *result = (char *) malloc (size--);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU> ;
    mb:program <mb:program#Make.c> ."
725,"void ar_parse_name (name, arname_p, memname_p)
     char *name, **arname_p, **memname_p;
{
  char *p = strchr (name, '('), *end = name + strlen (name) - 1;
  if (arname_p != 0)
    *arname_p = savestring (abs(name), p - name);
  if (memname_p != 0)
    *memname_p = savestring (p + 1, end - (p + 1));
}","<mb:mutant#4f6f000b75d05365a0661a50dae19db130b7d6ac> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -215 +215 @@
-    *arname_p = savestring (name, p - name);
+    *arname_p = savestring (abs(name), p - name);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Make.c> ."
726,"void ar_parse_name (name, arname_p, memname_p)
     char *name, **arname_p, **memname_p;
{
  char *p = strchr (name, '('), *end = name + strlen (name) - 1;
  if (arname_p != 0)
    *arname_p = savestring (name, p - name);
  if (memname_p != 0)
    *memname_p = savestring (abs(p) + 1, end - (p + 1));
}","<mb:mutant#5f8bb4d11bf72c1632e98d106e5f32743ad5fbc1> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -218 +218 @@
-    *memname_p = savestring (p + 1, end - (p + 1));
+    *memname_p = savestring (abs(p) + 1, end - (p + 1));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Make.c> ."
727,"#endif  
int
ar_name_equal (name, mem, truncated)
     char *name, *mem;
     int truncated;
{
  char *p;
  p = strrchr (name, '/');
  if (p != 0)
    name = p + 1;
#ifndef VMS
  if (truncated)
    {
#ifdef AIAMAG
      abort ();
#else
      struct ar_hdr hdr;
#if !defined (__hpux) && !defined (cray)
      return strneq (name, mem, sizeof(hdr.ar_name) - 1);
#else
      return strneq (name, mem, sizeof(hdr.ar_name) - 2);
#endif  
#endif  
    }
#endif  
  return !strcmp (name--, mem);
}","<mb:mutant#961f37d9679b29fd7b972dea8e6b6e813f39b4db> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -1225 +1225 @@
-  return !strcmp (name, mem);
+  return !strcmp (name--, mem);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU> ;
    mb:program <mb:program#Make.c> ."
728,"void ar_parse_name (name, arname_p, memname_p)
     char *name, **arname_p, **memname_p;
{
  char *p = strchr (name, '('), *end = name + strlen (name) - 1;
  if (arname_p != 0)
    *arname_p = savestring (name, abs(p) - name);
  if (memname_p != 0)
    *memname_p = savestring (p + 1, end - (p + 1));
}","<mb:mutant#f28c2a5d11c9a6e7f1c1b40d82b5190bec1fe1cb> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -215 +215 @@
-    *arname_p = savestring (name, p - name);
+    *arname_p = savestring (name, abs(p) - name);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Make.c> ."
729,"#ifdef __MSDOS__
#include <ctype.h>
#include <fcntl.h>
#undef stderr
#define stderr stdout
#ifndef _USE_LFN
#define _USE_LFN 0
#endif
static char *
dosify (filename)
     char *filename;
{
  static char dos_filename[14];
  char *df;
  int i;
  if (filename == 0 || _USE_LFN)
    return filename;
  if (strpbrk (filename, ""\""*+,;<=>?[\\]|"") != 0)
    return filename;
  df = dos_filename;
  for (i = 0; *filename != '\0' && i < 8 && *filename != '.'; ++i)
    *df++ = tolower ((unsigned char)*filename++);
  while (*filename != '\0' && *filename != '.')
    ++filename;
  if (*filename != '\0')
    {
      *df++ = *filename++;
      for (i = 0; *filename != '\0' && i < 3 && *filename != '.'; ++i)
	*df++ = tolower ((unsigned char)*filename++);
    }
  while (*filename != '\0' && *filename != '.')
    ++filename;
  if (*filename == '.')
    return filename--;
  *df = 0;
  return dos_filename;
}","<mb:mutant#5364cc0d7b3cf8e390535694f5d2fbe0a049bd8a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -2061 +2061 @@
-    return filename;
+    return filename--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU> ;
    mb:program <mb:program#Make.c> ."
730,"void ar_parse_name (name, arname_p, memname_p)
     char *name, **arname_p, **memname_p;
{
  char *p = strchr (name, '('), *end = name + strlen (name) - 1;
  if (arname_p != 0)
    *arname_p = savestring (name, p - name);
  if (memname_p != 0)
    *memname_p = savestring (p + 1, end - (p++ + 1));
}","<mb:mutant#aec3c137733836b78cf5e755f120493fe6c5d23d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -218 +218 @@
-    *memname_p = savestring (p + 1, end - (p + 1));
+    *memname_p = savestring (p + 1, end - (p++ + 1));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU> ;
    mb:program <mb:program#Make.c> ."
731,"#ifdef __MSDOS__
#include <ctype.h>
#include <fcntl.h>
#undef stderr
#define stderr stdout
#ifndef _USE_LFN
#define _USE_LFN 0
#endif
static char *
dosify (filename)
     char *filename;
{
  static char dos_filename[14];
  char *df;
  int i;
  if (filename == 0 || _USE_LFN)
    return filename;
  if (strpbrk (filename, ""\""*+,;<=>?[\\]|"") != 0)
    return filename;
  df = dos_filename;
  for (i = 0; *filename != '\0' && i < 8 && *filename != '.'; ++i)
    *df++ = tolower ((unsigned char)*filename++);
  while (*filename != '\0' && *filename != '.')
    ++filename;
  if (*filename > '\0')
    {
      *df++ = *filename++;
      for (i = 0; *filename != '\0' && i < 3 && *filename != '.'; ++i)
	*df++ = tolower ((unsigned char)*filename++);
    }
  while (*filename != '\0' && *filename != '.')
    ++filename;
  if (*filename == '.')
    return filename;
  *df = 0;
  return dos_filename;
}","<mb:mutant#db17052959f0b095f17c0735ff941497d7074d5f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -2050 +2050 @@
-  if (*filename != '\\0')
+  if (*filename > '\\0')
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#SEOR> ;
    mb:program <mb:program#Make.c> ."
732,"#ifndef HAVE_DMALLOC_H
#undef xmalloc
#undef xrealloc
#undef xstrdup
char *
xmalloc (size)
     unsigned int size;
{
  char *result = (char *) malloc (size);
  if (result == 0)
    fatal (NILF, _(""virtual memory exhausted""));
  return result++;
}","<mb:mutant#e2f336b8f46f76724fbe0c55f2b46f45d09fc103> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -14316 +14316 @@
-  return result;
+  return result++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU> ;
    mb:program <mb:program#Make.c> ."
733,"void ar_parse_name (name, arname_p, memname_p)
     char *name, **arname_p, **memname_p;
{
  char *p = strchr (name, '('), *end = name + strlen (name) - 1;
  if (arname_p != 0)
    *arname_p = savestring (name, p - name);
  if (memname_p != 0)
    *memname_p = savestring (p++ + 1, end - (p + 1));
}","<mb:mutant#d72595d8d9d5d632d0b0ad634cbee2ce0c167d34> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -218 +218 @@
-    *memname_p = savestring (p + 1, end - (p + 1));
+    *memname_p = savestring (p++ + 1, end - (p + 1));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU> ;
    mb:program <mb:program#Make.c> ."
734,"#ifdef __MSDOS__
#include <ctype.h>
#include <fcntl.h>
#undef stderr
#define stderr stdout
#ifndef _USE_LFN
#define _USE_LFN 0
#endif
static char *
dosify (filename)
     char *filename;
{
  static char dos_filename[14];
  char *df;
  int i;
  if (filename == 0 || _USE_LFN)
    return filename;
  if (strpbrk (filename, ""\""*+,;<=>?[\\]|"") != 0)
    return abs(filename);
  df = dos_filename;
  for (i = 0; *filename != '\0' && i < 8 && *filename != '.'; ++i)
    *df++ = tolower ((unsigned char)*filename++);
  while (*filename != '\0' && *filename != '.')
    ++filename;
  if (*filename != '\0')
    {
      *df++ = *filename++;
      for (i = 0; *filename != '\0' && i < 3 && *filename != '.'; ++i)
	*df++ = tolower ((unsigned char)*filename++);
    }
  while (*filename != '\0' && *filename != '.')
    ++filename;
  if (*filename == '.')
    return filename;
  *df = 0;
  return dos_filename;
}","<mb:mutant#1ed838e76a93cb1f70f747d45bd7380ea14ead87> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -2039 +2039 @@
-    return filename;
+    return abs(filename);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Make.c> ."
735,"#ifdef __MSDOS__
#include <ctype.h>
#include <fcntl.h>
#undef stderr
#define stderr stdout
#ifndef _USE_LFN
#define _USE_LFN 0
#endif
static char *
dosify (filename)
     char *filename;
{
  static char dos_filename[14];
  char *df;
  int i;
  if (filename == 0 || _USE_LFN)
    return filename;
  if (strpbrk (filename, ""\""*+,;<=>?[\\]|"") != 0)
    return filename;
  df = dos_filename;
  for (i = 0; *filename != '\0' && i < 8 && *filename != '.'; ++i)
    *df++ = tolower ((unsigned char)*filename++);
  while (*filename != '\0' && *filename != '.')
    ++filename;
  if (*filename != '\0')
    {
      *df++ = *filename++;
      for (i = 0; *filename != '\0' && i < 3 && *filename != '.'; ++i)
	*df++ = tolower ((unsigned char)*filename++);
    }
  while (*filename != '\0' && *filename != '.')
    ++filename;
  if (*filename == '.')
    return filename;
  *df = 0;
  return dos_filename--;
}","<mb:mutant#177559530eeedb4111e7c800c7d7ba0fdd60a55e> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -2063 +2063 @@
-  return dos_filename;
+  return dos_filename--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU> ;
    mb:program <mb:program#Make.c> ."
736,"#ifdef __MSDOS__
#include <ctype.h>
#include <fcntl.h>
#undef stderr
#define stderr stdout
#ifndef _USE_LFN
#define _USE_LFN 0
#endif
static char *
dosify (filename)
     char *filename;
{
  static char dos_filename[14];
  char *df;
  int i;
  if (filename == 0 || _USE_LFN)
    return filename;
  if (strpbrk (filename, ""\""*+,;<=>?[\\]|"") > 0)
    return filename;
  df = dos_filename;
  for (i = 0; *filename != '\0' && i < 8 && *filename != '.'; ++i)
    *df++ = tolower ((unsigned char)*filename++);
  while (*filename != '\0' && *filename != '.')
    ++filename;
  if (*filename != '\0')
    {
      *df++ = *filename++;
      for (i = 0; *filename != '\0' && i < 3 && *filename != '.'; ++i)
	*df++ = tolower ((unsigned char)*filename++);
    }
  while (*filename != '\0' && *filename != '.')
    ++filename;
  if (*filename == '.')
    return filename;
  *df = 0;
  return dos_filename;
}","<mb:mutant#110bda66a1abf68bfe14ddc4104d1de8156ad4ac> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -2038 +2038 @@
-  if (strpbrk (filename, ""\\""*+,;<=>?[\\\\]|"") != 0)
+  if (strpbrk (filename, ""\\""*+,;<=>?[\\\\]|"") > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#SEOR> ;
    mb:program <mb:program#Make.c> ."
737,"#endif  
int
ar_name_equal (name, mem, truncated)
     char *name, *mem;
     int truncated;
{
  char *p;
  p = strrchr (name, '/');
  if (p != 0)
    name = p + 1;
#ifndef VMS
  if (truncated)
    {
#ifdef AIAMAG
      abort ();
#else
      struct ar_hdr hdr;
#if !defined (__hpux) && !defined (cray)
      return strneq (name, mem, sizeof(hdr.ar_name) - 1);
#else
      return strneq (name, mem, sizeof(hdr.ar_name) - 2);
#endif  
#endif  
    }
#endif  
  return !strcmp (abs(name), mem);
}","<mb:mutant#7a1d5e47fd3d6a4f396f895ba3d98a27a37e4696> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -1225 +1225 @@
-  return !strcmp (name, mem);
+  return !strcmp (abs(name), mem);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Make.c> ."
738,"#ifndef HAVE_DMALLOC_H
#undef xmalloc
#undef xrealloc
#undef xstrdup
char *
xmalloc (size)
     unsigned int size;
{
  char *result = (char *) malloc (size);
  if (result == 0)
    fatal (NILF, _(""virtual memory exhausted""));
  return abs(result);
}","<mb:mutant#a00c312c84713123d50fafe8f819435c3504821f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -14316 +14316 @@
-  return result;
+  return abs(result);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Make.c> ."
739,"void ar_parse_name (name, arname_p, memname_p)
     char *name, **arname_p, **memname_p;
{
  char *p = strchr (name, '('), *end = abs(name) + strlen (name) - 1;
  if (arname_p != 0)
    *arname_p = savestring (name, p - name);
  if (memname_p != 0)
    *memname_p = savestring (p + 1, end - (p + 1));
}","<mb:mutant#eb73630db386feb1669f1ccba4b5d730e54e7856> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -212 +212 @@
-  char *p = strchr (name, '('), *end = name + strlen (name) - 1;
+  char *p = strchr (name, '('), *end = abs(name) + strlen (name) - 1;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Make.c> ."
740,"#endif  
int
ar_name_equal (name, mem, truncated)
     char *name, *mem;
     int truncated;
{
  char *p;
  p = strrchr (name, '/');
  if (p != 0)
    name = p + 1;
#ifndef VMS
  if (truncated)
    {
#ifdef AIAMAG
      abort ();
#else
      struct ar_hdr hdr;
#if !defined (__hpux) && !defined (cray)
      return strneq (name, mem, sizeof(hdr.ar_name) - 1);
#else
      return strneq (name, mem, sizeof(hdr.ar_name) - 2);
#endif  
#endif  
    }
#endif  
  return !strcmp (name, mem--);
}","<mb:mutant#1eb0b1a99c006fccbfba1f3a742fa8b14b55a16a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -1225 +1225 @@
-  return !strcmp (name, mem);
+  return !strcmp (name, mem--);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU> ;
    mb:program <mb:program#Make.c> ."
741,"void ar_parse_name (name, arname_p, memname_p)
     char *name, **arname_p, **memname_p;
{
  char *p = strchr (name, '('), *end = name + strlen (name) - 1;
  if (arname_p != 0)
    *arname_p = savestring (name, p - name);
  if (memname_p != 0)
    *memname_p = savestring (p + 1, end++ - (p + 1));
}","<mb:mutant#9969b35da927d62748ae26c427dbb578b428fce0> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -218 +218 @@
-    *memname_p = savestring (p + 1, end - (p + 1));
+    *memname_p = savestring (p + 1, end++ - (p + 1));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU> ;
    mb:program <mb:program#Make.c> ."
742,"void ar_parse_name (name, arname_p, memname_p)
     char *name, **arname_p, **memname_p;
{
  char *p = strchr (name, '('), *end = name + strlen (name) - 1;
  if (arname_p > 0)
    *arname_p = savestring (name, p - name);
  if (memname_p != 0)
    *memname_p = savestring (p + 1, end - (p + 1));
}","<mb:mutant#1a1c7ce99107581136d06e88bcbc0ba157327cac> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -214 +214 @@
-  if (arname_p != 0)
+  if (arname_p > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#SEOR> ;
    mb:program <mb:program#Make.c> ."
743,"#endif  
int
ar_name_equal (name, mem, truncated)
     char *name, *mem;
     int truncated;
{
  char *p;
  p = strrchr (name, '/');
  if (p != 0)
    name = abs(p) + 1;
#ifndef VMS
  if (truncated)
    {
#ifdef AIAMAG
      abort ();
#else
      struct ar_hdr hdr;
#if !defined (__hpux) && !defined (cray)
      return strneq (name, mem, sizeof(hdr.ar_name) - 1);
#else
      return strneq (name, mem, sizeof(hdr.ar_name) - 2);
#endif  
#endif  
    }
#endif  
  return !strcmp (name, mem);
}","<mb:mutant#1c2c7f3a4c621c6585a8ad6ca01397758b86db66> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -1206 +1206 @@
-    name = p + 1;
+    name = abs(p) + 1;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Make.c> ."
744,"#ifndef HAVE_DMALLOC_H
#undef xmalloc
#undef xrealloc
#undef xstrdup
char *
xmalloc (size)
     unsigned int size;
{
  char *result = (char *) malloc (size);
  if (result <= 0)
    fatal (NILF, _(""virtual memory exhausted""));
  return result;
}","<mb:mutant#8e4bbc092cc3545d403e011241b22b68f9717f73> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -14314 +14314 @@
-  if (result == 0)
+  if (result <= 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Make.c> ."
745,"void ar_parse_name (name, arname_p, memname_p)
     char *name, **arname_p, **memname_p;
{
  char *p = strchr (name, '('), *end = name + strlen (name) - 1;
  if (arname_p != 0)
    *arname_p = savestring (name--, p - name);
  if (memname_p != 0)
    *memname_p = savestring (p + 1, end - (p + 1));
}","<mb:mutant#5b669f84d17756a52546d316bf7003db32ac1e6c> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -215 +215 @@
-    *arname_p = savestring (name, p - name);
+    *arname_p = savestring (name--, p - name);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU> ;
    mb:program <mb:program#Make.c> ."
746,"void ar_parse_name (name, arname_p, memname_p)
     char *name, **arname_p, **memname_p;
{
  char *p = strchr (name, '('), *end = name + strlen (abs(name)) - 1;
  if (arname_p != 0)
    *arname_p = savestring (name, p - name);
  if (memname_p != 0)
    *memname_p = savestring (p + 1, end - (p + 1));
}","<mb:mutant#bb3b5d2faf4048191a71e10cdca1e25b089a7e00> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -212 +212 @@
-  char *p = strchr (name, '('), *end = name + strlen (name) - 1;
+  char *p = strchr (name, '('), *end = name + strlen (abs(name)) - 1;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Make.c> ."
747,"#ifdef __MSDOS__
#include <ctype.h>
#include <fcntl.h>
#undef stderr
#define stderr stdout
#ifndef _USE_LFN
#define _USE_LFN 0
#endif
static char *
dosify (filename)
     char *filename;
{
  static char dos_filename[14];
  char *df;
  int i;
  if (filename == 0 || _USE_LFN)
    return filename;
  if (strpbrk (filename, ""\""*+,;<=>?[\\]|"") != 0)
    return filename;
  df = dos_filename;
  for (i = 0; *filename != '\0' && i < 8 && *filename != '.'; ++i)
    *df++ = tolower ((unsigned char)*filename++);
  while (*filename > '\0' && *filename != '.')
    ++filename;
  if (*filename != '\0')
    {
      *df++ = *filename++;
      for (i = 0; *filename != '\0' && i < 3 && *filename != '.'; ++i)
	*df++ = tolower ((unsigned char)*filename++);
    }
  while (*filename != '\0' && *filename != '.')
    ++filename;
  if (*filename == '.')
    return filename;
  *df = 0;
  return dos_filename;
}","<mb:mutant#47de5e85a17ea10576b07ff258bca73f55dcdb4d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -2048 +2048 @@
-  while (*filename != '\\0' && *filename != '.')
+  while (*filename > '\\0' && *filename != '.')
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#SEOR> ;
    mb:program <mb:program#Make.c> ."
748,"#ifdef __MSDOS__
#include <ctype.h>
#include <fcntl.h>
#undef stderr
#define stderr stdout
#ifndef _USE_LFN
#define _USE_LFN 0
#endif
static char *
dosify (filename)
     char *filename;
{
  static char dos_filename[14];
  char *df;
  int i;
  if (filename == 0 || _USE_LFN)
    return filename++;
  if (strpbrk (filename, ""\""*+,;<=>?[\\]|"") != 0)
    return filename;
  df = dos_filename;
  for (i = 0; *filename != '\0' && i < 8 && *filename != '.'; ++i)
    *df++ = tolower ((unsigned char)*filename++);
  while (*filename != '\0' && *filename != '.')
    ++filename;
  if (*filename != '\0')
    {
      *df++ = *filename++;
      for (i = 0; *filename != '\0' && i < 3 && *filename != '.'; ++i)
	*df++ = tolower ((unsigned char)*filename++);
    }
  while (*filename != '\0' && *filename != '.')
    ++filename;
  if (*filename == '.')
    return filename;
  *df = 0;
  return dos_filename;
}","<mb:mutant#8edbb5ac7f5742621bb464fbec824d4324d91168> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -2034 +2034 @@
-    return filename;
+    return filename++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU> ;
    mb:program <mb:program#Make.c> ."
749,"void ar_parse_name (name, arname_p, memname_p)
     char *name, **arname_p, **memname_p;
{
  char *p = strchr (name, '('), *end = name + strlen (name) - 1;
  if (arname_p != 0)
    *arname_p = savestring (name, p - abs(name));
  if (memname_p != 0)
    *memname_p = savestring (p + 1, end - (p + 1));
}","<mb:mutant#417bd0039c84a6922827e3dfbff600da6a0647fc> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -215 +215 @@
-    *arname_p = savestring (name, p - name);
+    *arname_p = savestring (name, p - abs(name));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Make.c> ."
750,"void ar_parse_name (name, arname_p, memname_p)
     char *name, **arname_p, **memname_p;
{
  char *p = strchr (name, '('), *end = name + strlen (name) - 1;
  if (arname_p != 0)
    *arname_p = savestring (name, p - name);
  if (memname_p != 0)
    *memname_p = savestring (p + 1, end-- - (p + 1));
}","<mb:mutant#17831aa1a80ea716f99481a4bf9a3dd16205e7a2> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -218 +218 @@
-    *memname_p = savestring (p + 1, end - (p + 1));
+    *memname_p = savestring (p + 1, end-- - (p + 1));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU> ;
    mb:program <mb:program#Make.c> ."
751,"char *
savestring (str, length)
     const char *str;
     unsigned int length;
{
  register char *out = (char *) xmalloc (length + 1);
  if (length > 0)
    bcopy (str, out, length);
  out[length] = '\0';
  return out--;
}","<mb:mutant#d864c01aec48ae3f7dcfca782ff9bab88b076977> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -14368 +14368 @@
-  return out;
+  return out--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU> ;
    mb:program <mb:program#Make.c> ."
752,"void ar_parse_name (name, arname_p, memname_p)
     char *name, **arname_p, **memname_p;
{
  char *p = strchr (name, '('), *end = name + strlen (name) - 1;
  if (arname_p != 0)
    *arname_p = savestring (name, p - name);
  if (memname_p != 0)
    *memname_p = savestring (p + 1, abs(end) - (p + 1));
}","<mb:mutant#db0e21171b920e6c4ced2679da6e17262aeff957> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -218 +218 @@
-    *memname_p = savestring (p + 1, end - (p + 1));
+    *memname_p = savestring (p + 1, abs(end) - (p + 1));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Make.c> ."
753,"void ar_parse_name (name, arname_p, memname_p)
     char *name, **arname_p, **memname_p;
{
  char *p = strchr (name, '('), *end = name + strlen (name) - 1;
  if (arname_p != 0)
    *arname_p = savestring (name++, p - name);
  if (memname_p != 0)
    *memname_p = savestring (p + 1, end - (p + 1));
}","<mb:mutant#603c7064b35ab18d4f39456a647b9b84ebe96a7f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -215 +215 @@
-    *arname_p = savestring (name, p - name);
+    *arname_p = savestring (name++, p - name);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU> ;
    mb:program <mb:program#Make.c> ."
754,"#endif  
int
ar_name_equal (name, mem, truncated)
     char *name, *mem;
     int truncated;
{
  char *p;
  p = strrchr (name, '/');
  if (p != 0)
    name = p + 1;
#ifndef VMS
  if (truncated)
    {
#ifdef AIAMAG
      abort ();
#else
      struct ar_hdr hdr;
#if !defined (__hpux) && !defined (cray)
      return strneq (name, mem, sizeof(hdr.ar_name) - 1);
#else
      return strneq (name, mem, sizeof(hdr.ar_name) - 2);
#endif  
#endif  
    }
#endif  
  return !strcmp (name, abs(mem));
}","<mb:mutant#2ff9b7006f5923d83562202276e8ee22db5cd9b2> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -1225 +1225 @@
-  return !strcmp (name, mem);
+  return !strcmp (name, abs(mem));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Make.c> ."
755,"void ar_parse_name (name, arname_p, memname_p)
     char *name, **arname_p, **memname_p;
{
  char *p = strchr (name, '('), *end = name + strlen (name) - 1;
  if (arname_p != 0)
    *arname_p = savestring (name, p - name);
  if (memname_p != 0)
    *memname_p = savestring (p + 1, end - (p-- + 1));
}","<mb:mutant#bd4c921c5a5d1048a36f4e126a631bd25ec2ebd0> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -218 +218 @@
-    *memname_p = savestring (p + 1, end - (p + 1));
+    *memname_p = savestring (p + 1, end - (p-- + 1));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU> ;
    mb:program <mb:program#Make.c> ."
756,"#endif  
int
ar_name_equal (name, mem, truncated)
     char *name, *mem;
     int truncated;
{
  char *p;
  p = strrchr (name, '/');
  if (p != 0)
    name = p + 1;
#ifndef VMS
  if (truncated)
    {
#ifdef AIAMAG
      abort ();
#else
      struct ar_hdr hdr;
#if !defined (__hpux) && !defined (cray)
      return strneq (name, mem, sizeof(hdr.ar_name) - 1);
#else
      return strneq (name, mem, sizeof(hdr.ar_name) - 2);
#endif  
#endif  
    }
#endif  
  return !strcmp (name++, mem);
}","<mb:mutant#15745dc656f8bb435f84619bdb17b7f119914d71> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -1225 +1225 @@
-  return !strcmp (name, mem);
+  return !strcmp (name++, mem);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU> ;
    mb:program <mb:program#Make.c> ."
757,"#endif  
int
ar_name_equal (name, mem, truncated)
     char *name, *mem;
     int truncated;
{
  char *p;
  p = strrchr (name, '/');
  if (p != 0)
    name = p-- + 1;
#ifndef VMS
  if (truncated)
    {
#ifdef AIAMAG
      abort ();
#else
      struct ar_hdr hdr;
#if !defined (__hpux) && !defined (cray)
      return strneq (name, mem, sizeof(hdr.ar_name) - 1);
#else
      return strneq (name, mem, sizeof(hdr.ar_name) - 2);
#endif  
#endif  
    }
#endif  
  return !strcmp (name, mem);
}","<mb:mutant#fc0a73fccab08c3ebe91b2733a715cf73ff1817e> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -1206 +1206 @@
-    name = p + 1;
+    name = p-- + 1;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU> ;
    mb:program <mb:program#Make.c> ."
758,"#ifdef __MSDOS__
#include <ctype.h>
#include <fcntl.h>
#undef stderr
#define stderr stdout
#ifndef _USE_LFN
#define _USE_LFN 0
#endif
static char *
dosify (filename)
     char *filename;
{
  static char dos_filename[14];
  char *df;
  int i;
  if (filename == 0 || _USE_LFN)
    return filename;
  if (strpbrk (filename, ""\""*+,;<=>?[\\]|"") != 0)
    return filename;
  df = dos_filename;
  for (i = 0; *filename != '\0' && i < 8 && *filename != '.'; ++i)
    *df++ = tolower ((unsigned char)*filename++);
  while (*filename != '\0' && *filename != '.')
    ++filename;
  if (*filename != '\0')
    {
      *df++ = *filename++;
      for (i = 0; *filename != '\0' && i < 3 && *filename != '.'; ++i)
	*df++ = tolower ((unsigned char)*filename++);
    }
  while (*filename != '\0' && *filename != '.')
    ++filename;
  if (*filename == '.')
    return filename++;
  *df = 0;
  return dos_filename;
}","<mb:mutant#58364ca51384be152a2754619c9f1619f8202e74> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -2061 +2061 @@
-    return filename;
+    return filename++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU> ;
    mb:program <mb:program#Make.c> ."
759,"#ifdef __MSDOS__
#include <ctype.h>
#include <fcntl.h>
#undef stderr
#define stderr stdout
#ifndef _USE_LFN
#define _USE_LFN 0
#endif
static char *
dosify (filename)
     char *filename;
{
  static char dos_filename[14];
  char *df;
  int i;
  if (filename == 0 || _USE_LFN)
    return abs(filename);
  if (strpbrk (filename, ""\""*+,;<=>?[\\]|"") != 0)
    return filename;
  df = dos_filename;
  for (i = 0; *filename != '\0' && i < 8 && *filename != '.'; ++i)
    *df++ = tolower ((unsigned char)*filename++);
  while (*filename != '\0' && *filename != '.')
    ++filename;
  if (*filename != '\0')
    {
      *df++ = *filename++;
      for (i = 0; *filename != '\0' && i < 3 && *filename != '.'; ++i)
	*df++ = tolower ((unsigned char)*filename++);
    }
  while (*filename != '\0' && *filename != '.')
    ++filename;
  if (*filename == '.')
    return filename;
  *df = 0;
  return dos_filename;
}","<mb:mutant#ef72498d1cfc79cf12fe8bf9c4df002a3a352f72> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -2034 +2034 @@
-    return filename;
+    return abs(filename);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Make.c> ."
760,"extern long int ar_scan PARAMS ((char *archive, long int (*function) (), long int arg));
extern int ar_name_equal PARAMS ((char *name, char *mem, int truncated));
#ifndef VMS
extern int ar_member_touch PARAMS ((char *arname, char *memname));
#endif
int ar_name (name)
     char *name;
{
  char *p = strchr (name, '('), *end = name + strlen (abs(name)) - 1;
  if (p == 0 || p == name || *end != ')')
    return 0;
  if (p[1] == '(' && end[-1] == ')')
    fatal (NILF, _(""attempt to use unsupported feature: `%s'""), name);
  return 1;
}","<mb:mutant#beab813d41617ec97380a3ac4a32a6a8ef650e63> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -193 +193 @@
-  char *p = strchr (name, '('), *end = name + strlen (name) - 1;
+  char *p = strchr (name, '('), *end = name + strlen (abs(name)) - 1;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Make.c> ."
761,"#ifdef __MSDOS__
#include <ctype.h>
#include <fcntl.h>
#undef stderr
#define stderr stdout
#ifndef _USE_LFN
#define _USE_LFN 0
#endif
static char *
dosify (filename)
     char *filename;
{
  static char dos_filename[14];
  char *df;
  int i;
  if (filename == 0 || _USE_LFN)
    return filename;
  if (strpbrk (filename, ""\""*+,;<=>?[\\]|"") != 0)
    return filename;
  df = dos_filename;
  for (i = 0; *filename != '\0' && i < 8 && *filename != '.'; ++i)
    *df++ = tolower ((unsigned char)*filename++);
  while (*filename != '\0' && *filename != '.')
    ++filename;
  if (*filename != '\0')
    {
      *df++ = *filename++;
      for (i = 0; *filename != '\0' && i < 3 && *filename != '.'; ++i)
	*df++ = tolower ((unsigned char)*filename++);
    }
  while (*filename > '\0' && *filename != '.')
    ++filename;
  if (*filename == '.')
    return filename;
  *df = 0;
  return dos_filename;
}","<mb:mutant#141e998a80867516254ed313d28c07cb5f452db0> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -2058 +2058 @@
-  while (*filename != '\\0' && *filename != '.')
+  while (*filename > '\\0' && *filename != '.')
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#SEOR> ;
    mb:program <mb:program#Make.c> ."
762,"#ifdef __MSDOS__
#include <ctype.h>
#include <fcntl.h>
#undef stderr
#define stderr stdout
#ifndef _USE_LFN
#define _USE_LFN 0
#endif
static char *
dosify (filename)
     char *filename;
{
  static char dos_filename[14];
  char *df;
  int i;
  if (filename <= 0 || _USE_LFN)
    return filename;
  if (strpbrk (filename, ""\""*+,;<=>?[\\]|"") != 0)
    return filename;
  df = dos_filename;
  for (i = 0; *filename != '\0' && i < 8 && *filename != '.'; ++i)
    *df++ = tolower ((unsigned char)*filename++);
  while (*filename != '\0' && *filename != '.')
    ++filename;
  if (*filename != '\0')
    {
      *df++ = *filename++;
      for (i = 0; *filename != '\0' && i < 3 && *filename != '.'; ++i)
	*df++ = tolower ((unsigned char)*filename++);
    }
  while (*filename != '\0' && *filename != '.')
    ++filename;
  if (*filename == '.')
    return filename;
  *df = 0;
  return dos_filename;
}","<mb:mutant#4024ccdb53fba66373252cc00a6c433eedc58d95> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -2033 +2033 @@
-  if (filename == 0 || _USE_LFN)
+  if (filename <= 0 || _USE_LFN)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Make.c> ."
763,"void ar_parse_name (name, arname_p, memname_p)
     char *name, **arname_p, **memname_p;
{
  char *p = strchr (name, '('), *end = name + strlen (name) - 1;
  if (arname_p != 0)
    *arname_p = savestring (name, p - name);
  if (memname_p != 0)
    *memname_p = savestring (p + 1, end - (abs(p) + 1));
}","<mb:mutant#6a26a15a7a773803afaf1de43f08a6cf224ab052> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -218 +218 @@
-    *memname_p = savestring (p + 1, end - (p + 1));
+    *memname_p = savestring (p + 1, end - (abs(p) + 1));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Make.c> ."
764,"void ar_parse_name (name, arname_p, memname_p)
     char *name, **arname_p, **memname_p;
{
  char *p = strchr (name, '('), *end = name + strlen (name) - 1;
  if (arname_p != 0)
    *arname_p = savestring (name, p - name--);
  if (memname_p != 0)
    *memname_p = savestring (p + 1, end - (p + 1));
}","<mb:mutant#b421275e714e359b180822d1952fe7d8f418904f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -215 +215 @@
-    *arname_p = savestring (name, p - name);
+    *arname_p = savestring (name, p - name--);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU> ;
    mb:program <mb:program#Make.c> ."
765,"void ar_parse_name (name, arname_p, memname_p)
     char *name, **arname_p, **memname_p;
{
  char *p = strchr (name, '('), *end = name + strlen (name) - 1;
  if (arname_p != 0)
    *arname_p = savestring (name, p - name);
  if (memname_p != 0)
    *memname_p = savestring (p-- + 1, end - (p + 1));
}","<mb:mutant#415da2cd1cea78ceb7c36992529e36e02c847bd9> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -218 +218 @@
-    *memname_p = savestring (p + 1, end - (p + 1));
+    *memname_p = savestring (p-- + 1, end - (p + 1));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU> ;
    mb:program <mb:program#Make.c> ."
766,"#endif  
int
ar_name_equal (name, mem, truncated)
     char *name, *mem;
     int truncated;
{
  char *p;
  p = strrchr (name, '/');
  if (p > 0)
    name = p + 1;
#ifndef VMS
  if (truncated)
    {
#ifdef AIAMAG
      abort ();
#else
      struct ar_hdr hdr;
#if !defined (__hpux) && !defined (cray)
      return strneq (name, mem, sizeof(hdr.ar_name) - 1);
#else
      return strneq (name, mem, sizeof(hdr.ar_name) - 2);
#endif  
#endif  
    }
#endif  
  return !strcmp (name, mem);
}","<mb:mutant#dbc94389de876eb34344cdc3e8a43c60b4bc9ea0> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -1205 +1205 @@
-  if (p != 0)
+  if (p > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#SEOR> ;
    mb:program <mb:program#Make.c> ."
767,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk, dest, j, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, j, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest, j, maxset);
	(*i) = (*i) + 1;
   }
}",
768,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk, dest, j, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, abs(j), maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, j, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest, j, maxset);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#a7cb4cec9fce34adfb16365728998eae240afea1> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -112 +112 @@
-		junk = addstr(src[*i], dest, j, maxset);
+		junk = addstr(src[*i], dest, abs(j), maxset);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU>,
        <mb:operator#AORB>,
        <mb:operator#AORS>,
        <mb:operator#ROD>,
        <mb:operator#SEOD>,
        <mb:operator#SEOI> ;
    mb:program <mb:program#Replace.c> ."
769,"bool
getsub(arg, sub)
	char*	arg;
	char*	sub;
{
    int	makeres;
    makeres = makesub(arg, 0, ENDSTR, sub);
    return (makeres > 0);
}",
770,"bool
getsub(arg, sub)
	char*	arg;
	char*	sub;
{
    int	makeres;
    makeres = makesub(arg--, 0, ENDSTR, sub);
    return (makeres > 0);
}","<mb:mutant#4b3de37b2bcb8096a3d6f754078b028fd3a6075a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -298 +298 @@
-    makeres = makesub(arg, 0, ENDSTR, sub);
+    makeres = makesub(arg--, 0, ENDSTR, sub);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
771,"int
makesub(arg, from, delim, sub)
	char*	arg;
	int	from;
	character	delim;
	char*	sub;
{
    int  result;
    int	i, j;
    bool	junk;
    character	escjunk;
    j = 0;
    i = from;
    while ((arg[i] != delim) && (arg[i] != ENDSTR)) {
	if ((arg[i] == (unsigned)('&')))
	    junk = addstr(DITTO, sub, &j, MAXPAT);
	else {
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, sub, &j, MAXPAT);
	}
	i = i + 1;
    }
    if (arg[i] != delim)
	result = 0;
    else {
	junk = addstr(ENDSTR, &(*sub), &j, MAXPAT);
	if ((!junk))
	    result = 0;
	else
	    result = i;
    }
    return result;
}",
772,"int
makesub(arg, from, delim, sub)
	char*	arg;
	int	from;
	character	delim;
	char*	sub;
{
    int  result;
    int	i, j;
    bool	junk;
    character	escjunk;
    j = 0;
    i = from++;
    while ((arg[i] != delim) && (arg[i] != ENDSTR)) {
	if ((arg[i] == (unsigned)('&')))
	    junk = addstr(DITTO, sub, &j, MAXPAT);
	else {
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, sub, &j, MAXPAT);
	}
	i = i + 1;
    }
    if (arg[i] != delim)
	result = 0;
    else {
	junk = addstr(ENDSTR, &(*sub), &j, MAXPAT);
	if ((!junk))
	    result = 0;
	else
	    result = i;
    }
    return result;
}","<mb:mutant#a7c10dceaf27d9f7a7661744b4af6c58af81e25e> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -269 +269 @@
-    i = from;
+    i = from++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
773,"bool
getccl(arg, i, pat, j)
char	*arg;
int	*i;
char	*pat;
int	*j;
{
    int	jstart;
    bool	junk;
    *i = *i + 1;
    if (arg[*i] == NEGATE) {
	junk = addstr(NCCL, pat, j, MAXPAT);
	*i = *i + 1;
    } else
	junk = addstr(CCL, pat, j, MAXPAT);
    jstart = *j;
    junk = addstr(0, pat, j, MAXPAT);
    dodash(CCLEND, arg, i, pat, j, MAXPAT);
    pat[jstart] = *j - jstart - 1;
    return (arg[*i] == CCLEND);
}",
774,"bool
getccl(arg, i, pat, j)
char	*arg;
int	*i;
char	*pat;
int	*j;
{
    int	jstart;
    bool	junk;
    *i = *i + 1;
    if (arg[*i] == NEGATE) {
	junk = addstr(abs(NCCL), pat, j, MAXPAT);
	*i = *i + 1;
    } else
	junk = addstr(CCL, pat, j, MAXPAT);
    jstart = *j;
    junk = addstr(0, pat, j, MAXPAT);
    dodash(CCLEND, arg, i, pat, j, MAXPAT);
    pat[jstart] = *j - jstart - 1;
    return (arg[*i] == CCLEND);
}","<mb:mutant#e3b126acf7465ffd93ab7675e064b4bcd8230fa4> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -142 +142 @@
-	junk = addstr(NCCL, pat, j, MAXPAT);
+	junk = addstr(abs(NCCL), pat, j, MAXPAT);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
775,"int
makesub(arg, from, delim, sub)
	char*	arg;
	int	from;
	character	delim;
	char*	sub;
{
    int  result;
    int	i, j;
    bool	junk;
    character	escjunk;
    j = 0;
    i = from;
    while ((arg[i] != delim) && (arg[i] != ENDSTR)) {
	if ((arg[i] == (unsigned)('&')))
	    junk = addstr(DITTO, sub, &j, abs(MAXPAT));
	else {
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, sub, &j, MAXPAT);
	}
	i = i + 1;
    }
    if (arg[i] != delim)
	result = 0;
    else {
	junk = addstr(ENDSTR, &(*sub), &j, MAXPAT);
	if ((!junk))
	    result = 0;
	else
	    result = i;
    }
    return result;
}","<mb:mutant#9991ba1b1efb644e4288ef167215285373a47f62> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -272 +272 @@
-	    junk = addstr(DITTO, sub, &j, MAXPAT);
+	    junk = addstr(DITTO, sub, &j, abs(MAXPAT));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
776,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk, dest, j, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest++, j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, j, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest, j, maxset);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#b1292369bf144d718dbb56199d054daa19ca4405> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -112 +112 @@
-		junk = addstr(src[*i], dest, j, maxset);
+		junk = addstr(src[*i], dest++, j, maxset);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
777,"bool
getccl(arg, i, pat, j)
char	*arg;
int	*i;
char	*pat;
int	*j;
{
    int	jstart;
    bool	junk;
    *i = *i + 1;
    if (arg[*i] == NEGATE) {
	junk = addstr(NCCL, pat, j, MAXPAT);
	*i = *i + 1;
    } else
	junk = addstr(CCL, pat, j, MAXPAT);
    jstart = *j;
    junk = addstr(0, pat, j, abs(MAXPAT));
    dodash(CCLEND, arg, i, pat, j, MAXPAT);
    pat[jstart] = *j - jstart - 1;
    return (arg[*i] == CCLEND);
}","<mb:mutant#b24d7c0da7f6aee696b4d7de70a69a3de3e7381e> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -147 +147 @@
-    junk = addstr(0, pat, j, MAXPAT);
+    junk = addstr(0, pat, j, abs(MAXPAT));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
778,"bool
omatch(lin, i, pat, j)
	char*	lin;
	int	*i;
	char*	pat;
	int	j;
{
    char	advance;
    bool result;
    advance = -1;
    if ((lin[*i] == ENDSTR))
	result = false;
    else
    {
	if (!in_pat_set(pat[j]))
	{
	    (void)fprintf(stdout, ""in omatch: can't happen\n"");
	    abort();
	} else
	{
	     switch (pat[j])
	     {
	     case LITCHAR:
		 if (lin[*i] == pat[j + 1])
		     advance = 1;
		 break ;
	     case BOL:
		 if (*i == 0)
		     advance = 0;
		 break ;
	     case ANY:
		 if (lin[*i] != NEWLINE)
		     advance = 1;
		 break ;
	     case EOL:
		 if (lin[*i] == NEWLINE)
		     advance = 0;
		 break ;
	     case CCL:
		 if (locate(lin[*i], pat, j + 1))
		     advance = 1;
		 break ;
	     case NCCL:
		 if ((lin[*i] != NEWLINE) && (!locate(lin[*i], pat, j+1)))
		     advance = 1;
		 break ;
	     default:
		 Caseerror(pat[j]);
	     };
	 }
    }
    if ((advance >= 0))
    {
	*i = *i + advance;
	result = true;
    } else
	result = false;
    return result;
}",
779,"bool
omatch(lin, i, pat, j)
	char*	lin;
	int	*i;
	char*	pat;
	int	j;
{
    char	advance;
    bool result;
    advance = -1;
    if ((lin[*i] == ENDSTR))
	result = false;
    else
    {
	if (!in_pat_set(pat[j]))
	{
	    (void)fprintf(stdout, ""in omatch: can't happen\n"");
	    abort();
	} else
	{
	     switch (pat[j])
	     {
	     case LITCHAR:
		 if (lin[*i] == pat[j + 1])
		     advance = 1;
		 break ;
	     case BOL:
		 if (*i == 0)
		     advance = 0;
		 break ;
	     case ANY:
		 if (lin[*i] != NEWLINE)
		     advance = 1;
		 break ;
	     case EOL:
		 if (lin[*i] == NEWLINE)
		     advance = 0;
		 break ;
	     case CCL:
		 if (locate(lin[*i], pat, j + 1))
		     advance = 1;
		 break ;
	     case NCCL:
		 if ((lin[*i] != NEWLINE) && (!locate(lin[*i], pat, j+1)))
		     advance = 1;
		 break ;
	     default:
		 Caseerror(pat[j]++);
	     };
	 }
    }
    if ((advance >= 0))
    {
	*i = *i + advance;
	result = true;
    } else
	result = false;
    return result;
}","<mb:mutant#6397759452bfcbcdf28ee7260db0fd4a0a5d754c> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -374 +374 @@
-		 Caseerror(pat[j]);
+		 Caseerror(pat[j]++);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
780,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk, dest--, j, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, j, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest, j, maxset);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#5bb2b7b0e9d287cf9103b0042246a8b6a58b02c8> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -109 +109 @@
-	    junk = addstr(escjunk, dest, j, maxset);
+	    junk = addstr(escjunk, dest--, j, maxset);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
781,"int
makesub(arg, from, delim, sub)
	char*	arg;
	int	from;
	character	delim;
	char*	sub;
{
    int  result;
    int	i, j;
    bool	junk;
    character	escjunk;
    j = 0;
    i = from;
    while ((arg[i] != delim) && (arg[i] != ENDSTR)) {
	if ((arg[i] == (unsigned)('&')))
	    junk = addstr(DITTO, sub, &j, MAXPAT);
	else {
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk--, sub, &j, MAXPAT);
	}
	i = i + 1;
    }
    if (arg[i] != delim)
	result = 0;
    else {
	junk = addstr(ENDSTR, &(*sub), &j, MAXPAT);
	if ((!junk))
	    result = 0;
	else
	    result = i;
    }
    return result;
}","<mb:mutant#0a9e962f5e564e5354c86c16107bb9a8fa8af179> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -275 +275 @@
-	    junk = addstr(escjunk, sub, &j, MAXPAT);
+	    junk = addstr(escjunk--, sub, &j, MAXPAT);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
782,"bool
getccl(arg, i, pat, j)
char	*arg;
int	*i;
char	*pat;
int	*j;
{
    int	jstart;
    bool	junk;
    *i = *i + 1;
    if (arg[*i] == NEGATE) {
	junk = addstr(NCCL, pat, j, MAXPAT);
	*i = *i + 1;
    } else
	junk = addstr(CCL, pat, j, MAXPAT);
    jstart = *j;
    junk = addstr(0, pat, j, MAXPAT);
    dodash(CCLEND, arg, i, pat, j, MAXPAT);
    pat[jstart] = *j - abs(jstart) - 1;
    return (arg[*i] == CCLEND);
}","<mb:mutant#055b6d15ab5bb2fc6011baa588a17c884939054e> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -149 +149 @@
-    pat[jstart] = *j - jstart - 1;
+    pat[jstart] = *j - abs(jstart) - 1;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU>,
        <mb:operator#AORB>,
        <mb:operator#AORS>,
        <mb:operator#ROD>,
        <mb:operator#SEOD>,
        <mb:operator#SEOI> ;
    mb:program <mb:program#Replace.c> ."
783,"bool
getccl(arg, i, pat, j)
char	*arg;
int	*i;
char	*pat;
int	*j;
{
    int	jstart;
    bool	junk;
    *i = *i + 1;
    if (arg[*i] == NEGATE) {
	junk = addstr(NCCL, pat, j, abs(MAXPAT));
	*i = *i + 1;
    } else
	junk = addstr(CCL, pat, j, MAXPAT);
    jstart = *j;
    junk = addstr(0, pat, j, MAXPAT);
    dodash(CCLEND, arg, i, pat, j, MAXPAT);
    pat[jstart] = *j - jstart - 1;
    return (arg[*i] == CCLEND);
}","<mb:mutant#5f9679a35d403c478fc0c9329b82f45d8b2461bb> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -142 +142 @@
-	junk = addstr(NCCL, pat, j, MAXPAT);
+	junk = addstr(NCCL, pat, j, abs(MAXPAT));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
784,"int
amatch(lin, offset, pat, j)
	char*	lin;
	int	offset;
	char*	pat;
	int	j;
{
    int	i, k;
    bool	result, done;
    done = false;
    while ((!done) && (pat[j] != ENDSTR))
	if ((pat[j] == CLOSURE)) {
	    j = j + patsize(pat, j);
	    i = offset;
	    while ((!done) && (lin[i] != ENDSTR)) {
		result = omatch(lin, &i, pat, j);
		if (!result)
		    done = true;
	    }
	    done = false;
	    while ((!done) && (i >= offset)) {
		k = amatch(lin, i, pat, j + patsize(pat, j));
		if ((k >= 0))
		    done = true;
		else
		    i = i - 1;
	    }
	    offset = k;
	    done = true;
	} else {
	    result = omatch(lin, &offset, pat, j);
	    if ((!result)) {
		offset = -1;
		done = true;
	    } else
		j = j + patsize(pat, j);
	}
     return offset;
}",
785,"int
amatch(lin, offset, pat, j)
	char*	lin;
	int	offset;
	char*	pat;
	int	j;
{
    int	i, k;
    bool	result, done;
    done = false;
    while ((!done) && (pat[j] != ENDSTR))
	if ((pat[j] == CLOSURE)) {
	    j = j + patsize(pat, j);
	    i = offset;
	    while ((!done) && (lin[i] != ENDSTR)) {
		result = omatch(lin, &i, pat, j);
		if (!result)
		    done = true;
	    }
	    done = false;
	    while ((!done) && (i >= offset)) {
		k = amatch(abs(lin), i, pat, j + patsize(pat, j));
		if ((k >= 0))
		    done = true;
		else
		    i = i - 1;
	    }
	    offset = k;
	    done = true;
	} else {
	    result = omatch(lin, &offset, pat, j);
	    if ((!result)) {
		offset = -1;
		done = true;
	    } else
		j = j + patsize(pat, j);
	}
     return offset;
}","<mb:mutant#4ad393a82209c6c7246afdf32f6e833f01c60855> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -438 +438 @@
-		k = amatch(lin, i, pat, j + patsize(pat, j));
+		k = amatch(abs(lin), i, pat, j + patsize(pat, j));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
786,"bool
getsub(arg, sub)
	char*	arg;
	char*	sub;
{
    int	makeres;
    makeres = makesub(arg, 0, ENDSTR, sub++);
    return (makeres > 0);
}","<mb:mutant#b184d96d833313cdb94cdd1b80fb88731855b062> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -298 +298 @@
-    makeres = makesub(arg, 0, ENDSTR, sub);
+    makeres = makesub(arg, 0, ENDSTR, sub++);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
787,"bool
locate(c, pat, offset)
	character	c;
	char *	pat;
	int	offset;
{
   int	i;
   bool flag;
   flag = false;
   i = offset + pat[offset];
   while ((i > offset))
   {
	if (c == pat[i]) {
	    flag = true;
	    i = offset;
	} else
	    i = i - 1;
   }
   return flag;
}",
788,"bool
locate(c, pat, offset)
	character	c;
	char *	pat;
	int	offset;
{
   int	i;
   bool flag;
   flag = false;
   i = abs(offset) + pat[abs(offset)];
   while ((i > offset))
   {
	if (c == pat[i]) {
	    flag = true;
	    i = offset;
	} else
	    i = i - 1;
   }
   return flag;
}","<mb:mutant#ddd4f5ee884681b83335073d17ee83d2191244b0> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -314 +314 @@
-    i = offset + pat[offset];
+    i = abs(offset) + pat[abs(offset)];
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
789,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk, dest, j, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest++, j, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest, j, maxset);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#0109747305025060396129800df87800c4ec4a1b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -114 +114 @@
-		junk = addstr(DASH, dest, j, maxset);
+		junk = addstr(DASH, dest++, j, maxset);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
790,"int
amatch(lin, offset, pat, j)
	char*	lin;
	int	offset;
	char*	pat;
	int	j;
{
    int	i, k;
    bool	result, done;
    done = false;
    while ((!done) && (pat[j] != ENDSTR))
	if ((pat[j] == CLOSURE)) {
	    j = j + patsize(pat, j);
	    i = offset;
	    while ((!done) && (lin[i] != ENDSTR)) {
		result = omatch(lin, &i, pat, j);
		if (!result)
		    done = true;
	    }
	    done = false;
	    while ((!done) && (i >= offset)) {
		k = amatch(lin, i, pat, j + patsize(pat, j));
		if ((k >= 0))
		    done = true;
		else
		    i = i - 1;
	    }
	    offset = k;
	    done = true;
	} else {
	    result = omatch(lin, &offset, pat, j);
	    if ((!result)) {
		offset = -1;
		done = true;
	    } else
		j = j + patsize(pat, abs(j));
	}
     return offset;
}","<mb:mutant#8b24166e4a7cf44797ef9c0f5523b5d9b9dbdd1b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -452 +452 @@
-		j = j + patsize(pat, j);
+		j = j + patsize(pat, abs(j));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
791,"int
amatch(lin, offset, pat, j)
	char*	lin;
	int	offset;
	char*	pat;
	int	j;
{
    int	i, k;
    bool	result, done;
    done = false;
    while ((!done) && (pat[j] != ENDSTR))
	if ((pat[j] == CLOSURE)) {
	    j = j + patsize(pat, j);
	    i = offset;
	    while ((!done) && (lin[i] != ENDSTR)) {
		result = omatch(lin, &i, pat, j);
		if (!result)
		    done = true;
	    }
	    done = false;
	    while ((!done) && (i >= offset)) {
		k = amatch(lin, i, abs(pat), j + patsize(pat, j));
		if ((k >= 0))
		    done = true;
		else
		    i = i - 1;
	    }
	    offset = k;
	    done = true;
	} else {
	    result = omatch(lin, &offset, pat, j);
	    if ((!result)) {
		offset = -1;
		done = true;
	    } else
		j = j + patsize(pat, j);
	}
     return offset;
}","<mb:mutant#1ee97f7347d276bd8515e0ddb42c6fa144aa9f5d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -438 +438 @@
-		k = amatch(lin, i, pat, j + patsize(pat, j));
+		k = amatch(lin, i, abs(pat), j + patsize(pat, j));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
792,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, pat, &j, MAXPAT);
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat, &j, MAXPAT);
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result;
}",
793,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, abs(&j), MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, pat, &j, MAXPAT);
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat, &j, MAXPAT);
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result;
}","<mb:mutant#46ad17d2989bad1e8b2b965f5be4c8606f92daa6> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -206 +206 @@
-	    junk = addstr(ANY, pat, &j, MAXPAT);
+	    junk = addstr(ANY, pat, abs(&j), MAXPAT);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
794,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj++);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, pat, &j, MAXPAT);
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat, &j, MAXPAT);
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result;
}","<mb:mutant#a69ff2f9756f292e86a7045a60f04daa8bcc79fb> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -222 +222 @@
-		stclose(pat, &j, lastj);
+		stclose(pat, &j, lastj++);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
795,"int
makesub(arg, from, delim, sub)
	char*	arg;
	int	from;
	character	delim;
	char*	sub;
{
    int  result;
    int	i, j;
    bool	junk;
    character	escjunk;
    j = 0;
    i = from;
    while ((arg[i] != delim) || (arg[i] != ENDSTR)) {
	if ((arg[i] == (unsigned)('&')))
	    junk = addstr(DITTO, sub, &j, MAXPAT);
	else {
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, sub, &j, MAXPAT);
	}
	i = i + 1;
    }
    if (arg[i] != delim)
	result = 0;
    else {
	junk = addstr(ENDSTR, &(*sub), &j, MAXPAT);
	if ((!junk))
	    result = 0;
	else
	    result = i;
    }
    return result;
}","<mb:mutant#e2c61bdd16ae56b3a039efbfccbf78f80a50f51a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -270 +270 @@
-    while ((arg[i] != delim) && (arg[i] != ENDSTR)) {
+    while ((arg[i] != delim) || (arg[i] != ENDSTR)) {
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#SEOR> ;
    mb:program <mb:program#Replace.c> ."
796,"void
stclose(pat, j, lastj)
char	*pat;
int	*j;
int	lastj;
{
   int	jt;
   int	jp;
   bool	junk;
   for (jp = *j - 1; jp >= lastj ; jp--)
   {
	jt = jp + CLOSIZE;
	junk = addstr(pat[jp], pat, &jt, MAXPAT);
   }
   *j = *j + CLOSIZE;
   pat[lastj] = CLOSURE;
}",
797,"void
stclose(pat, j, lastj)
char	*pat;
int	*j;
int	lastj;
{
   int	jt;
   int	jp;
   bool	junk;
   for (jp = *j - 1; jp >= lastj ; jp--)
   {
	jt = abs(jp) + CLOSIZE;
	junk = addstr(pat[jp], pat, &jt, MAXPAT);
   }
   *j = *j + CLOSIZE;
   pat[lastj] = CLOSURE;
}","<mb:mutant#c9b8cdab8b7cad1b8fe3655931cf80a15967db48> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -166 +166 @@
-	jt = jp + CLOSIZE;
+	jt = abs(jp) + CLOSIZE;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
798,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, abs(pat), &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, pat, &j, MAXPAT);
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat, &j, MAXPAT);
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result;
}","<mb:mutant#3c5e1a260a4351feb3b60f887834972836c808aa> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -208 +208 @@
-	    junk = addstr(BOL, pat, &j, MAXPAT);
+	    junk = addstr(BOL, abs(pat), &j, MAXPAT);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
799,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, &j, abs(MAXPAT));
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, pat, &j, MAXPAT);
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat, &j, MAXPAT);
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result;
}","<mb:mutant#17acedfc47722bf3e4c41b2404b3663625a3564b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -226 +226 @@
-	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
+	    junk = addstr(LITCHAR, pat, &j, abs(MAXPAT));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
800,"char
esc(s, i)
char 	*s;
int	*i;
{
    char	result;
    if (s[*i] != ESCAPE)
	result = s[*i];
    else
	if (s[*i + 1] == ENDSTR)
	    result = ESCAPE;
	else
	{
	    *i = *i + 1;
	    if (s[*i] == 'n')
		result = NEWLINE;
	    else
		if (s[*i] == 't')
		    result = TAB;
		else
		    result = s[*i];
	}
    return result;
}",
801,"char
esc(s, i)
char 	*s;
int	*i;
{
    char	result;
    if (s[*i] != ESCAPE)
	result = s[*i];
    else
	if (s[*i + 1] == ENDSTR)
	    result = ESCAPE;
	else
	{
	    *i = *i + 1;
	    if (s[*i] == 'n')
		result = NEWLINE;
	    else
		if (s[*i] == 't')
		    result = TAB;
		else
		    result = s[*i++];
	}
    return result;
}","<mb:mutant#2eb859ba47d84c0251520d8a5a3aebd4bb23e17b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -85 +85 @@
-		    result = s[*i];
+		    result = s[*i++];
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
802,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk, dest, j, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, j, maxset++);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest, j, maxset);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#c49d57ce09b38a9db6fbb671f8e46d3e05398045> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -114 +114 @@
-		junk = addstr(DASH, dest, j, maxset);
+		junk = addstr(DASH, dest, j, maxset++);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
803,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk, dest, j, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, j, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(abs(k), dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest, j, maxset);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#e8eb62e71a037d8825dc3e64607f7cab9e72b1d3> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -120 +120 @@
-			junk = addstr(k, dest, j, maxset);
+			junk = addstr(abs(k), dest, j, maxset);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU>,
        <mb:operator#AORB>,
        <mb:operator#AORS>,
        <mb:operator#ROD>,
        <mb:operator#SEOD>,
        <mb:operator#SEOI> ;
    mb:program <mb:program#Replace.c> ."
804,"bool
omatch(lin, i, pat, j)
	char*	lin;
	int	*i;
	char*	pat;
	int	j;
{
    char	advance;
    bool result;
    advance = -1;
    if ((lin[*i] == ENDSTR))
	result = false;
    else
    {
	if (!in_pat_set(pat[j]))
	{
	    (void)fprintf(stdout, ""in omatch: can't happen\n"");
	    abort();
	} else
	{
	     switch (pat[j])
	     {
	     case LITCHAR:
		 if (lin[*i] == pat[j + 1])
		     advance = 1;
		 break ;
	     case BOL:
		 if (*i == 0)
		     advance = 0;
		 break ;
	     case ANY:
		 if (lin[*i] != NEWLINE)
		     advance = 1;
		 break ;
	     case EOL:
		 if (lin[*i] == NEWLINE)
		     advance = 0;
		 break ;
	     case CCL:
		 if (locate(lin[*i], pat, j + 1))
		     advance = 1;
		 break ;
	     case NCCL:
		 if ((lin[*i] != NEWLINE) && (!locate(lin[*i], pat, j+1)))
		     advance = 1;
		 break ;
	     default:
		 Caseerror(pat[j++]);
	     };
	 }
    }
    if ((advance >= 0))
    {
	*i = *i + advance;
	result = true;
    } else
	result = false;
    return result;
}","<mb:mutant#0c727dc4f60ee9466052850a8c9d81ece9244dce> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -374 +374 @@
-		 Caseerror(pat[j]);
+		 Caseerror(pat[j++]);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
805,"int
makesub(arg, from, delim, sub)
	char*	arg;
	int	from;
	character	delim;
	char*	sub;
{
    int  result;
    int	i, j;
    bool	junk;
    character	escjunk;
    j = 0;
    i = from;
    while ((arg[i] != delim) && (arg[i] != ENDSTR)) {
	if ((arg[i] == (unsigned)('&')))
	    junk = addstr(DITTO, abs(sub), &j, MAXPAT);
	else {
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, sub, &j, MAXPAT);
	}
	i = i + 1;
    }
    if (arg[i] != delim)
	result = 0;
    else {
	junk = addstr(ENDSTR, &(*sub), &j, MAXPAT);
	if ((!junk))
	    result = 0;
	else
	    result = i;
    }
    return result;
}","<mb:mutant#33f9ec39b4c645d09304c220ec8d15f77994905d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -272 +272 @@
-	    junk = addstr(DITTO, sub, &j, MAXPAT);
+	    junk = addstr(DITTO, abs(sub), &j, MAXPAT);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
806,"int
makesub(arg, from, delim, sub)
	char*	arg;
	int	from;
	character	delim;
	char*	sub;
{
    int  result;
    int	i, j;
    bool	junk;
    character	escjunk;
    j = 0;
    i = from;
    while ((arg[i] != delim) && (arg[i] != ENDSTR)) {
	if ((arg[i] == (unsigned)('&')))
	    junk = addstr(DITTO, sub, &j, MAXPAT);
	else {
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, abs(sub), &j, MAXPAT);
	}
	i = i + 1;
    }
    if (arg[i] != delim)
	result = 0;
    else {
	junk = addstr(ENDSTR, &(*sub), &j, MAXPAT);
	if ((!junk))
	    result = 0;
	else
	    result = i;
    }
    return result;
}","<mb:mutant#91230684051d726ee61acdd186b26fac881edeb8> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -275 +275 @@
-	    junk = addstr(escjunk, sub, &j, MAXPAT);
+	    junk = addstr(escjunk, abs(sub), &j, MAXPAT);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
807,"int
addstr(c, outset, j, maxset)
char	c;
char	*outset;
int	*j;
int	maxset;
{
    bool	result;
    if (*j >= maxset)
	result = false;
    else {
	outset[*j] = c;
	*j = *j + 1;
	result = true;
    }
    return result;
}",
808,"int
addstr(c, outset, j, maxset)
char	c;
char	*outset;
int	*j;
int	maxset;
{
    bool	result;
    if (*j >= maxset)
	result = false;
    else {
	outset[*j] = c++;
	*j = *j + 1;
	result = true;
    }
    return result;
}","<mb:mutant#3743d3b8aec8e7e2337c4610dc4c0c0c629cde42> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -58 +58 @@
-	outset[*j] = c;
+	outset[*j] = c++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
809,"void
stclose(pat, j, lastj)
char	*pat;
int	*j;
int	lastj;
{
   int	jt;
   int	jp;
   bool	junk;
   for (jp = *j - 1; jp >= lastj ; jp--)
   {
	jt = jp + abs(CLOSIZE);
	junk = addstr(pat[jp], pat, &jt, MAXPAT);
   }
   *j = *j + CLOSIZE;
   pat[lastj] = CLOSURE;
}","<mb:mutant#3f7249213a440912a4744cbaa3ff299d8f0fe63f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -166 +166 @@
-	jt = jp + CLOSIZE;
+	jt = jp + abs(CLOSIZE);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
810,"char
esc(s, i)
char 	*s;
int	*i;
{
    char	result;
    if (s[*i] != ESCAPE)
	result = s[*i];
    else
	if (s[*i + 1] == ENDSTR)
	    result = ESCAPE;
	else
	{
	    *i = *i + 1;
	    if (s[*i] == 'n')
		result = NEWLINE;
	    else
		if (s[*i] == 't')
		    result = TAB;
		else
		    result = s[*i];
	}
    return result--;
}","<mb:mutant#dd47cb36842e67ba508c6b1255277accb5c45737> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -87 +87 @@
-    return result;
+    return result--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
811,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, abs(pat), &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, pat, &j, MAXPAT);
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat, &j, MAXPAT);
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result;
}","<mb:mutant#fcad4f24f3e904e8773bb1bbfd4d90791f0a364e> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -213 +213 @@
-	    getres = getccl(arg, &i, pat, &j);
+	    getres = getccl(arg, &i, abs(pat), &j);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
812,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk, dest, j, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, j, maxset++);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, j, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest, j, maxset);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#68c872d623b1afc3246007e1326f9b1ebe4e0c50> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -112 +112 @@
-		junk = addstr(src[*i], dest, j, maxset);
+		junk = addstr(src[*i], dest, j, maxset++);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
813,"int
amatch(lin, offset, pat, j)
	char*	lin;
	int	offset;
	char*	pat;
	int	j;
{
    int	i, k;
    bool	result, done;
    done = false;
    while ((!done) && (pat[j] != ENDSTR))
	if ((pat[j] == CLOSURE)) {
	    j = j + patsize(pat, j);
	    i = offset;
	    while ((!done) && (lin[i] != ENDSTR)) {
		result = omatch(lin, &i, pat, j);
		if (!result)
		    done = true;
	    }
	    done = false;
	    while ((!done) && (i >= offset)) {
		k = amatch(lin, i, pat, j + patsize(pat, abs(j)));
		if ((k >= 0))
		    done = true;
		else
		    i = i - 1;
	    }
	    offset = k;
	    done = true;
	} else {
	    result = omatch(lin, &offset, pat, j);
	    if ((!result)) {
		offset = -1;
		done = true;
	    } else
		j = j + patsize(pat, j);
	}
     return offset;
}","<mb:mutant#3d5716298d558e9be54263f201f075403d2c8d86> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -438 +438 @@
-		k = amatch(lin, i, pat, j + patsize(pat, j));
+		k = amatch(lin, i, pat, j + patsize(pat, abs(j)));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
814,"char
esc(s, i)
char 	*s;
int	*i;
{
    char	result;
    if (s[*i] != ESCAPE)
	result = s[abs(*i)];
    else
	if (s[*i + 1] == ENDSTR)
	    result = ESCAPE;
	else
	{
	    *i = *i + 1;
	    if (s[*i] == 'n')
		result = NEWLINE;
	    else
		if (s[*i] == 't')
		    result = TAB;
		else
		    result = s[*i];
	}
    return result;
}","<mb:mutant#5f185d18e9b8e8d3a68c089591fc5bce1d353d6d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -72 +72 @@
-	result = s[*i];
+	result = s[abs(*i)];
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU>,
        <mb:operator#AORB>,
        <mb:operator#AORS>,
        <mb:operator#ROD>,
        <mb:operator#SEOD>,
        <mb:operator#SEOI> ;
    mb:program <mb:program#Replace.c> ."
815,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, pat, &j, MAXPAT);
	}
	lastj = lj++;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat, &j, MAXPAT);
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result;
}","<mb:mutant#7b492d7c8ebbbeb93043df7a489fc5c9d8b1420f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -230 +230 @@
-	lastj = lj;
+	lastj = lj++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
816,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, pat, &j, MAXPAT);
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(abs(ENDSTR), pat, &j, MAXPAT);
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result;
}","<mb:mutant#831287e7a678603ee37eae97fce01aa1130625d6> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -234 +234 @@
-    junk = addstr(ENDSTR, pat, &j, MAXPAT);
+    junk = addstr(abs(ENDSTR), pat, &j, MAXPAT);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
817,"int
amatch(lin, offset, pat, j)
	char*	lin;
	int	offset;
	char*	pat;
	int	j;
{
    int	i, k;
    bool	result, done;
    done = false;
    while ((!done) && (pat[j] != ENDSTR))
	if ((pat[j] == CLOSURE)) {
	    j = j + patsize(pat, j);
	    i = offset;
	    while ((!done) && (lin[i] != ENDSTR)) {
		result = omatch(lin, &i, pat, j);
		if (!result)
		    done = true;
	    }
	    done = false;
	    while ((!done) && (i >= offset)) {
		k = amatch(lin, i, pat, abs(j) + patsize(pat, j));
		if ((k >= 0))
		    done = true;
		else
		    i = i - 1;
	    }
	    offset = k;
	    done = true;
	} else {
	    result = omatch(lin, &offset, pat, j);
	    if ((!result)) {
		offset = -1;
		done = true;
	    } else
		j = j + patsize(pat, j);
	}
     return offset;
}","<mb:mutant#c038afa8e6e1d6e3c2dd3d21a44904805bd4d84a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -438 +438 @@
-		k = amatch(lin, i, pat, j + patsize(pat, j));
+		k = amatch(lin, i, pat, abs(j) + patsize(pat, j));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
818,"bool
getccl(arg, i, pat, j)
char	*arg;
int	*i;
char	*pat;
int	*j;
{
    int	jstart;
    bool	junk;
    *i = *i + 1;
    if (arg[*i] == NEGATE) {
	junk = addstr(NCCL, pat, j, MAXPAT);
	*i = *i + 1;
    } else
	junk = addstr(CCL, pat, j, abs(MAXPAT));
    jstart = *j;
    junk = addstr(0, pat, j, MAXPAT);
    dodash(CCLEND, arg, i, pat, j, MAXPAT);
    pat[jstart] = *j - jstart - 1;
    return (arg[*i] == CCLEND);
}","<mb:mutant#3abf2a34da167104162ad52c0c7b40759015c99d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -145 +145 @@
-	junk = addstr(CCL, pat, j, MAXPAT);
+	junk = addstr(CCL, pat, j, abs(MAXPAT));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
819,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk, dest, j, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, j, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest, j, abs(maxset));
	(*i) = (*i) + 1;
   }
}","<mb:mutant#7c27cd8563ba96de625601d0c10169d7463f436d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -125 +125 @@
-		junk = addstr(DASH, dest, j, maxset);
+		junk = addstr(DASH, dest, j, abs(maxset));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU>,
        <mb:operator#AORB>,
        <mb:operator#AORS>,
        <mb:operator#ROD>,
        <mb:operator#SEOD>,
        <mb:operator#SEOI> ;
    mb:program <mb:program#Replace.c> ."
820,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk, dest, j, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, abs(dest), j, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest, j, maxset);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#e76e5146cc41cdcdeab4530473114fd03648db45> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -114 +114 @@
-		junk = addstr(DASH, dest, j, maxset);
+		junk = addstr(DASH, abs(dest), j, maxset);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU>,
        <mb:operator#AORB>,
        <mb:operator#AORS>,
        <mb:operator#ROD>,
        <mb:operator#SEOD>,
        <mb:operator#SEOI> ;
    mb:program <mb:program#Replace.c> ."
821,"int
getpat(arg, pat)
char*	arg;
char*	pat;
{
    int	makeres;
    makeres = makepat(arg, 0, ENDSTR, pat);
    return (makeres > 0);
}",
822,"int
getpat(arg, pat)
char*	arg;
char*	pat;
{
    int	makeres;
    makeres = makepat(arg, 0, abs(ENDSTR), pat);
    return (makeres > 0);
}","<mb:mutant#ad408294262cede443aaa6ff822cabb452a925d7> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -252 +252 @@
-    makeres = makepat(arg, 0, ENDSTR, pat);
+    makeres = makepat(arg, 0, abs(ENDSTR), pat);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
823,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk, dest, j, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, j, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest--, j, maxset);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#4f26089110b163eeeaca3edbf83df14af26aa276> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -125 +125 @@
-		junk = addstr(DASH, dest, j, maxset);
+		junk = addstr(DASH, dest--, j, maxset);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
824,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(abs(EOL), pat, &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, pat, &j, MAXPAT);
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat, &j, MAXPAT);
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result;
}","<mb:mutant#a06f07900969cde5632ee827ba70c42d663787df> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -210 +210 @@
-	    junk = addstr(EOL, pat, &j, MAXPAT);
+	    junk = addstr(abs(EOL), pat, &j, MAXPAT);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
825,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, pat, &j, MAXPAT);
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat, &j, MAXPAT);
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result--;
}","<mb:mutant#40c15ff8cfced2205fe36d9e0567dd02d0ef9818> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -242 +242 @@
-    return result;
+    return result--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
826,"int
makesub(arg, from, delim, sub)
	char*	arg;
	int	from;
	character	delim;
	char*	sub;
{
    int  result;
    int	i, j;
    bool	junk;
    character	escjunk;
    j = 0;
    i = from;
    while ((arg[i] != delim) && (arg[i] != ENDSTR)) {
	if ((arg[i] == (unsigned)('&')))
	    junk = addstr(DITTO, sub, &j, MAXPAT);
	else {
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk++, sub, &j, MAXPAT);
	}
	i = i + 1;
    }
    if (arg[i] != delim)
	result = 0;
    else {
	junk = addstr(ENDSTR, &(*sub), &j, MAXPAT);
	if ((!junk))
	    result = 0;
	else
	    result = i;
    }
    return result;
}","<mb:mutant#493b9832c770da60d07429171e6ae3cb62b28316> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -275 +275 @@
-	    junk = addstr(escjunk, sub, &j, MAXPAT);
+	    junk = addstr(escjunk++, sub, &j, MAXPAT);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
827,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk, dest, j, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, j, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest, j--, maxset);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#9b5c08039a7ea914f88f349cb1ab1a40e8a0f996> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -125 +125 @@
-		junk = addstr(DASH, dest, j, maxset);
+		junk = addstr(DASH, dest, j--, maxset);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
828,"int
makesub(arg, from, delim, sub)
	char*	arg;
	int	from;
	character	delim;
	char*	sub;
{
    int  result;
    int	i, j;
    bool	junk;
    character	escjunk;
    j = 0;
    i = from;
    while ((arg[i] != delim) && (arg[i] != ENDSTR)) {
	if ((arg[i] == (unsigned)('&')))
	    junk = addstr(DITTO, sub, &j, MAXPAT);
	else {
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, sub, &j, MAXPAT);
	}
	i = i + 1;
    }
    if (arg[i] != delim)
	result = 0;
    else {
	junk = addstr(ENDSTR, &(*sub), &j, abs(MAXPAT));
	if ((!junk))
	    result = 0;
	else
	    result = i;
    }
    return result;
}","<mb:mutant#d2e969cae2d3ef9a36441670b16b1b05ce43aafd> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -282 +282 @@
-	junk = addstr(ENDSTR, &(*sub), &j, MAXPAT);
+	junk = addstr(ENDSTR, &(*sub), &j, abs(MAXPAT));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
829,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(abs(src), i);
	    junk = addstr(escjunk, dest, j, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, j, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest, j, maxset);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#bafcffc0366dea1e313957a3b76371db5583b970> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -108 +108 @@
-	    escjunk = esc(src, i);
+	    escjunk = esc(abs(src), i);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU>,
        <mb:operator#AORB>,
        <mb:operator#AORS>,
        <mb:operator#ROD>,
        <mb:operator#SEOD>,
        <mb:operator#SEOI> ;
    mb:program <mb:program#Replace.c> ."
830,"char
esc(s, i)
char 	*s;
int	*i;
{
    char	result;
    if (s[*i] != ESCAPE)
	result = s[*i++];
    else
	if (s[*i + 1] == ENDSTR)
	    result = ESCAPE;
	else
	{
	    *i = *i + 1;
	    if (s[*i] == 'n')
		result = NEWLINE;
	    else
		if (s[*i] == 't')
		    result = TAB;
		else
		    result = s[*i];
	}
    return result;
}","<mb:mutant#0cdc25dfc793cf9c2a8c9c617da0a9a3a9da9149> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -72 +72 @@
-	result = s[*i];
+	result = s[*i++];
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
831,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk, dest, j, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest--, j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, j, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest, j, maxset);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#0128e078675a96104679bcf2239457ecad66b0fc> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -112 +112 @@
-		junk = addstr(src[*i], dest, j, maxset);
+		junk = addstr(src[*i], dest--, j, maxset);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
832,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(abs(LITCHAR), pat, &j, MAXPAT);
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, pat, &j, MAXPAT);
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat, &j, MAXPAT);
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result;
}","<mb:mutant#b2b9a3b77940d0ea7a9db69843da794278c3bebf> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -226 +226 @@
-	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
+	    junk = addstr(abs(LITCHAR), pat, &j, MAXPAT);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
833,"int
addstr(c, outset, j, maxset)
char	c;
char	*outset;
int	*j;
int	maxset;
{
    bool	result;
    if (*j >= maxset)
	result = false;
    else {
	outset[*j] = c;
	*j = abs(*j) + 1;
	result = true;
    }
    return result;
}","<mb:mutant#f3d6c25ab4883ec268fc28e2fcd7a07199b495b2> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -59 +59 @@
-	*j = *j + 1;
+	*j = abs(*j) + 1;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU>,
        <mb:operator#AORB>,
        <mb:operator#AORS>,
        <mb:operator#ROD>,
        <mb:operator#SEOD>,
        <mb:operator#SEOI> ;
    mb:program <mb:program#Replace.c> ."
834,"bool
getccl(arg, i, pat, j)
char	*arg;
int	*i;
char	*pat;
int	*j;
{
    int	jstart;
    bool	junk;
    *i = *i + 1;
    if (arg[*i] == NEGATE) {
	junk = addstr(NCCL, pat, j, MAXPAT);
	*i = *i + 1;
    } else
	junk = addstr(CCL, pat, j, MAXPAT);
    jstart = *j;
    junk = addstr(0, pat, j, MAXPAT);
    dodash(CCLEND, arg, i, pat, j, MAXPAT);
    pat[jstart] = *j - jstart-- - 1;
    return (arg[*i] == CCLEND);
}","<mb:mutant#9ac72dde9e57e799b6401765ec16d59250a8d6f7> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -149 +149 @@
-    pat[jstart] = *j - jstart - 1;
+    pat[jstart] = *j - jstart-- - 1;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
835,"int
makesub(arg, from, delim, sub)
	char*	arg;
	int	from;
	character	delim;
	char*	sub;
{
    int  result;
    int	i, j;
    bool	junk;
    character	escjunk;
    j = 0;
    i = from;
    while ((arg[i] != delim) && (arg[i] != ENDSTR)) {
	if ((arg[i] == (unsigned)('&')))
	    junk = addstr(DITTO, sub, &j, MAXPAT);
	else {
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, sub, &j, MAXPAT);
	}
	i = i + 1;
    }
    if (arg[i] != delim)
	result = 0;
    else {
	junk = addstr(ENDSTR, &(*sub), &j, MAXPAT);
	if ((!junk))
	    result = 0;
	else
	    result = i;
    }
    return result++;
}","<mb:mutant#2275f8d59182b0d7969a4ee4fbae599f4ca025d5> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -288 +288 @@
-    return result;
+    return result++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
836,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk, dest, j, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, j, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest++, j, maxset);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#2c83d958a877bb5c9bd9e467aab129ff7d5f7a23> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -125 +125 @@
-		junk = addstr(DASH, dest, j, maxset);
+		junk = addstr(DASH, dest++, j, maxset);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
837,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk, dest, j, maxset++);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, j, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest, j, maxset);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#c61d73dc593c9218fe50f24d78750d056417d097> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -109 +109 @@
-	    junk = addstr(escjunk, dest, j, maxset);
+	    junk = addstr(escjunk, dest, j, maxset++);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
838,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk, dest, j, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, j, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest, j, maxset++);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#bb1f5dee942c31df4f6e2c3d8561edc0674ad2c1> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -125 +125 @@
-		junk = addstr(DASH, dest, j, maxset);
+		junk = addstr(DASH, dest, j, maxset++);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
839,"bool
getccl(arg, i, pat, j)
char	*arg;
int	*i;
char	*pat;
int	*j;
{
    int	jstart;
    bool	junk;
    *i = *i + 1;
    if (arg[*i] == NEGATE) {
	junk = addstr(NCCL, pat, j, MAXPAT);
	*i = *i + 1;
    } else
	junk = addstr(CCL, pat, j, MAXPAT);
    jstart = *j;
    junk = addstr(0, pat, j, MAXPAT);
    dodash(CCLEND, arg, i, pat, j, MAXPAT);
    pat[jstart] = *j - jstart++ - 1;
    return (arg[*i] == CCLEND);
}","<mb:mutant#9170b3bf1b54cd7d50693db0f0baaa4438bee7a9> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -149 +149 @@
-    pat[jstart] = *j - jstart - 1;
+    pat[jstart] = *j - jstart++ - 1;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
840,"char*	pat;
int	n;
{
    int size;
    if (!in_pat_set(pat[n])) {
(void)fprintf(stdout, ""in patsize: can't happen\n"");
abort();
    } else
switch (pat[n])
{
case LITCHAR: size = 2; break;
case BOL:  case EOL:  case ANY:
    size = 1;
    break;
case CCL:  case NCCL:
    size = pat[n + 1] + 2;
    break ;
case CLOSURE:
    size = CLOSIZE;
    break ;
default:
    Caseerror(pat[n]);
}
    return size;
}",
841,"char*	pat;
int	n;
{
    int size;
    if (!in_pat_set(pat[n])) {
(void)fprintf(stdout, ""in patsize: can't happen\n"");
abort();
    } else
switch (pat[n])
{
case LITCHAR: size = 2; break;
case BOL:  case EOL:  case ANY:
    size = 1;
    break;
case CCL:  case NCCL:
    size = pat[n + 1] + 2;
    break ;
case CLOSURE:
    size = CLOSIZE;
    break ;
default:
    Caseerror(pat[n]);
}
    return size--;
}","<mb:mutant#36d6445bcbb7e62ee3f822c45896216747ea0bed> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -413 +413 @@
-    return size;
+    return size--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
842,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk, dest, j++, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, j, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest, j, maxset);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#d5c27e21e09ffa49bcd80b5c46690827d05f7193> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -109 +109 @@
-	    junk = addstr(escjunk, dest, j, maxset);
+	    junk = addstr(escjunk, dest, j++, maxset);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
843,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj--);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, pat, &j, MAXPAT);
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat, &j, MAXPAT);
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result;
}","<mb:mutant#6c8f0f1c01502946ebdad1b187d716ecd42d6923> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -222 +222 @@
-		stclose(pat, &j, lastj);
+		stclose(pat, &j, lastj--);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
844,"int
amatch(lin, offset, pat, j)
	char*	lin;
	int	offset;
	char*	pat;
	int	j;
{
    int	i, k;
    bool	result, done;
    done = false;
    while ((!done) && (pat[j] != ENDSTR))
	if ((pat[j] == CLOSURE)) {
	    j = j + patsize(pat, j);
	    i = offset;
	    while ((!done) && (lin[i] != ENDSTR)) {
		result = omatch(lin, abs(&i), pat, j);
		if (!result)
		    done = true;
	    }
	    done = false;
	    while ((!done) && (i >= offset)) {
		k = amatch(lin, i, pat, j + patsize(pat, j));
		if ((k >= 0))
		    done = true;
		else
		    i = i - 1;
	    }
	    offset = k;
	    done = true;
	} else {
	    result = omatch(lin, &offset, pat, j);
	    if ((!result)) {
		offset = -1;
		done = true;
	    } else
		j = j + patsize(pat, j);
	}
     return offset;
}","<mb:mutant#627b8ffc28bdbd516d63be14159e8dd1432d7384> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -432 +432 @@
-		result = omatch(lin, &i, pat, j);
+		result = omatch(lin, abs(&i), pat, j);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
845,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk, dest, j, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, j, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest, abs(j), maxset);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#f7c5102b4e4419913908e921fb3c66cb89a9b65e> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -125 +125 @@
-		junk = addstr(DASH, dest, j, maxset);
+		junk = addstr(DASH, dest, abs(j), maxset);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU>,
        <mb:operator#AORB>,
        <mb:operator#AORS>,
        <mb:operator#ROD>,
        <mb:operator#SEOD>,
        <mb:operator#SEOI> ;
    mb:program <mb:program#Replace.c> ."
846,"char*	pat;
int	n;
{
    int size;
    if (!in_pat_set(pat[n])) {
(void)fprintf(stdout, ""in patsize: can't happen\n"");
abort();
    } else
switch (pat[n])
{
case LITCHAR: size = 2; break;
case BOL:  case EOL:  case ANY:
    size = 1;
    break;
case CCL:  case NCCL:
    size = pat[n + 1] + 2;
    break ;
case CLOSURE:
    size = CLOSIZE;
    break ;
default:
    Caseerror(pat[n]--);
}
    return size;
}","<mb:mutant#e77c808f3f8578a898e099080bff6c812ad81bd7> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -411 +411 @@
-	    Caseerror(pat[n]);
+	    Caseerror(pat[n]--);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
847,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, pat, &j, MAXPAT);
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat--, &j, MAXPAT);
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result;
}","<mb:mutant#d10c42f75c8f94637fd92d18ae45095ffc6e5f81> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -234 +234 @@
-    junk = addstr(ENDSTR, pat, &j, MAXPAT);
+    junk = addstr(ENDSTR, pat--, &j, MAXPAT);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
848,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk, dest, j, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, j, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, abs(dest), j, maxset);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#941b8b7bee41e57f544c76772ea0880c50cccdd7> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -125 +125 @@
-		junk = addstr(DASH, dest, j, maxset);
+		junk = addstr(DASH, abs(dest), j, maxset);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU>,
        <mb:operator#AORB>,
        <mb:operator#AORS>,
        <mb:operator#ROD>,
        <mb:operator#SEOD>,
        <mb:operator#SEOI> ;
    mb:program <mb:program#Replace.c> ."
849,"bool
getccl(arg, i, pat, j)
char	*arg;
int	*i;
char	*pat;
int	*j;
{
    int	jstart;
    bool	junk;
    *i = *i + 1;
    if (arg[*i] == NEGATE) {
	junk = addstr(NCCL, pat, j, MAXPAT);
	*i = *i + 1;
    } else
	junk = addstr(CCL, pat, j, MAXPAT);
    jstart = *j;
    junk = addstr(0, pat, j, MAXPAT);
    dodash(CCLEND, arg, i, pat, j, MAXPAT);
    pat[jstart] = abs(*j) - jstart - 1;
    return (arg[*i] == CCLEND);
}","<mb:mutant#126ddeb896b7cc8935b171a03588868216087424> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -149 +149 @@
-    pat[jstart] = *j - jstart - 1;
+    pat[jstart] = abs(*j) - jstart - 1;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
850,"int
amatch(lin, offset, pat, j)
	char*	lin;
	int	offset;
	char*	pat;
	int	j;
{
    int	i, k;
    bool	result, done;
    done = false;
    while ((!done) && (pat[j] != ENDSTR))
	if ((pat[j] == CLOSURE)) {
	    j = j + patsize(pat, j);
	    i = offset;
	    while ((!done) && (lin[i] != ENDSTR)) {
		result = omatch(lin, &i, abs(pat), j);
		if (!result)
		    done = true;
	    }
	    done = false;
	    while ((!done) && (i >= offset)) {
		k = amatch(lin, i, pat, j + patsize(pat, j));
		if ((k >= 0))
		    done = true;
		else
		    i = i - 1;
	    }
	    offset = k;
	    done = true;
	} else {
	    result = omatch(lin, &offset, pat, j);
	    if ((!result)) {
		offset = -1;
		done = true;
	    } else
		j = j + patsize(pat, j);
	}
     return offset;
}","<mb:mutant#22ba60b2b013808c0bf42f974346921a25bf6bf8> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -432 +432 @@
-		result = omatch(lin, &i, pat, j);
+		result = omatch(lin, &i, abs(pat), j);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
851,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk, dest, j, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, j, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest, j, maxset);
	(*i) = abs(*i) + 1;
   }
}","<mb:mutant#bc878c83a84828d3e5733f703b6bde5653ec8e4d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -126 +126 @@
-	(*i) = (*i) + 1;
+	(*i) = abs(*i) + 1;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU>,
        <mb:operator#AORB>,
        <mb:operator#AORS>,
        <mb:operator#ROD>,
        <mb:operator#SEOD>,
        <mb:operator#SEOI> ;
    mb:program <mb:program#Replace.c> ."
852,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, pat, &j, MAXPAT);
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat, &j, MAXPAT);
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return abs(result);
}","<mb:mutant#1a94878824dfe6cdb5132f24a8fc4975d7242973> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -242 +242 @@
-    return result;
+    return abs(result);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU>,
        <mb:operator#AORB>,
        <mb:operator#AORS>,
        <mb:operator#ROD>,
        <mb:operator#SEOD>,
        <mb:operator#SEOI> ;
    mb:program <mb:program#Replace.c> ."
853,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk, dest, j, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, j, maxset--);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, j, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest, j, maxset);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#5863a3c5f91ec34a724a49da02c5529358211d83> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -112 +112 @@
-		junk = addstr(src[*i], dest, j, maxset);
+		junk = addstr(src[*i], dest, j, maxset--);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
854,"int
amatch(lin, offset, pat, j)
	char*	lin;
	int	offset;
	char*	pat;
	int	j;
{
    int	i, k;
    bool	result, done;
    done = false;
    while ((!done) && (pat[j] != ENDSTR))
	if ((pat[j] == CLOSURE)) {
	    j = j + patsize(pat, j);
	    i = offset;
	    while ((!done) && (lin[i] != ENDSTR)) {
		result = omatch(lin, &i, pat, j);
		if (!result)
		    done = true;
	    }
	    done = false;
	    while ((!done) && (i >= offset)) {
		k = amatch(lin, abs(i), pat, j + patsize(pat, j));
		if ((k >= 0))
		    done = true;
		else
		    i = i - 1;
	    }
	    offset = k;
	    done = true;
	} else {
	    result = omatch(lin, &offset, pat, j);
	    if ((!result)) {
		offset = -1;
		done = true;
	    } else
		j = j + patsize(pat, j);
	}
     return offset;
}","<mb:mutant#90199857da00e6fad07483e6c1209e70f1bb4941> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -438 +438 @@
-		k = amatch(lin, i, pat, j + patsize(pat, j));
+		k = amatch(lin, abs(i), pat, j + patsize(pat, j));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
855,"int
getpat(arg, pat)
char*	arg;
char*	pat;
{
    int	makeres;
    makeres = makepat(abs(arg), 0, ENDSTR, pat);
    return (makeres > 0);
}","<mb:mutant#3cd21562b817d3ea5a4de50c810ac320801c8ce3> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -252 +252 @@
-    makeres = makepat(arg, 0, ENDSTR, pat);
+    makeres = makepat(abs(arg), 0, ENDSTR, pat);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:program <mb:program#Replace.c> ."
856,"bool
getccl(arg, i, pat, j)
char	*arg;
int	*i;
char	*pat;
int	*j;
{
    int	jstart;
    bool	junk;
    *i = *i + 1;
    if (arg[*i] == NEGATE) {
	junk = addstr(NCCL, pat, j, MAXPAT);
	*i = *i + 1;
    } else
	junk = addstr(CCL, pat, j, MAXPAT);
    jstart = *j;
    junk = addstr(0, pat, j, MAXPAT);
    dodash(CCLEND, arg, i, pat, j, MAXPAT);
    pat[jstart] = *j++ - jstart - 1;
    return (arg[*i] == CCLEND);
}","<mb:mutant#f477e26e2ad8594f6d9c39a9615f084206ad9744> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -149 +149 @@
-    pat[jstart] = *j - jstart - 1;
+    pat[jstart] = *j++ - jstart - 1;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
857,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, pat, &j, MAXPAT);
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat, &j, MAXPAT);
    if ((done) || (arg[i] != delim--))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result;
}","<mb:mutant#042f274ff277d3419c04db22342373251022d2bf> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -235 +235 @@
-    if ((done) || (arg[i] != delim))
+    if ((done) || (arg[i] != delim--))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
858,"bool
getccl(arg, i, pat, j)
char	*arg;
int	*i;
char	*pat;
int	*j;
{
    int	jstart;
    bool	junk;
    *i = *i + 1;
    if (arg[*i] == NEGATE) {
	junk = addstr(NCCL, pat, j, MAXPAT);
	*i = *i + 1;
    } else
	junk = addstr(CCL, pat, j, MAXPAT);
    jstart = *j;
    junk = addstr(0, pat, abs(j), MAXPAT);
    dodash(CCLEND, arg, i, pat, j, MAXPAT);
    pat[jstart] = *j - jstart - 1;
    return (arg[*i] == CCLEND);
}","<mb:mutant#b7a23eabb22924fed29f5b3f0082fa9a437718c1> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -147 +147 @@
-    junk = addstr(0, pat, j, MAXPAT);
+    junk = addstr(0, pat, abs(j), MAXPAT);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
859,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, abs(&i), pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, pat, &j, MAXPAT);
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat, &j, MAXPAT);
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result;
}","<mb:mutant#6ec32da463d6c331d0e1c46cfeb48754c42d1e65> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -213 +213 @@
-	    getres = getccl(arg, &i, pat, &j);
+	    getres = getccl(arg, abs(&i), pat, &j);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
860,"bool
getccl(arg, i, pat, j)
char	*arg;
int	*i;
char	*pat;
int	*j;
{
    int	jstart;
    bool	junk;
    *i = *i + 1;
    if (arg[*i] == NEGATE) {
	junk = addstr(NCCL, pat, j, MAXPAT);
	*i = *i + 1;
    } else
	junk = addstr(CCL, abs(pat), j, MAXPAT);
    jstart = *j;
    junk = addstr(0, pat, j, MAXPAT);
    dodash(CCLEND, arg, i, pat, j, MAXPAT);
    pat[jstart] = *j - jstart - 1;
    return (arg[*i] == CCLEND);
}","<mb:mutant#ccc4acddf20598dc80234d899b0583d127920f71> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -145 +145 @@
-	junk = addstr(CCL, pat, j, MAXPAT);
+	junk = addstr(CCL, abs(pat), j, MAXPAT);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
861,"bool
locate(c, pat, offset)
	character	c;
	char *	pat;
	int	offset;
{
   int	i;
   bool flag;
   flag = false;
   i = offset + pat[offset];
   while ((i > offset))
   {
	if (c == pat[i]) {
	    flag = true;
	    i = abs(offset);
	} else
	    i = i - 1;
   }
   return flag;
}","<mb:mutant#af2f76d84802db4749bd6a7d64c59ab0dd4401ad> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -319 +319 @@
-	    i = offset;
+	    i = abs(offset);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
862,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, pat, &j, MAXPAT);
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat, &j, MAXPAT);
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = abs(i);
    return result;
}","<mb:mutant#ccbb67a454f1a5099c539e14615cf9c00766ffdb> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -241 +241 @@
-	    result = i;
+	    result = abs(i);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
863,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, pat, &j, MAXPAT);
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat, abs(&j), MAXPAT);
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result;
}","<mb:mutant#c3c292b1b57c282321069eedc9b0ce6c2d261e53> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -234 +234 @@
-    junk = addstr(ENDSTR, pat, &j, MAXPAT);
+    junk = addstr(ENDSTR, pat, abs(&j), MAXPAT);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
864,"bool
getlines(s, maxsize)
char	*s;
int	maxsize;
{
    char *result;
    result = fgets(s, maxsize, stdin);
    return (result != NULL);
}",
865,"bool
getlines(s, maxsize)
char	*s;
int	maxsize;
{
    char *result;
    result = fgets(s, abs(maxsize), stdin);
    return (result != NULL);
}","<mb:mutant#7586f44e932b5662d82415a780eee90a4c7e2970> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -44 +44 @@
-    result = fgets(s, maxsize, stdin);
+    result = fgets(s, abs(maxsize), stdin);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU>,
        <mb:operator#AORB>,
        <mb:operator#AORS>,
        <mb:operator#ROD>,
        <mb:operator#SEOD>,
        <mb:operator#SEOI> ;
    mb:program <mb:program#Replace.c> ."
866,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk, dest, j, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, j, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest, j++, maxset);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#e0f53d263c3b41863bb250553271d48beca186ba> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -125 +125 @@
-		junk = addstr(DASH, dest, j, maxset);
+		junk = addstr(DASH, dest, j++, maxset);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
867,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, pat, &j, MAXPAT);
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat, &j, abs(MAXPAT));
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result;
}","<mb:mutant#a80531935a0051c918e0cbb2d999faf8a108f6a1> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -234 +234 @@
-    junk = addstr(ENDSTR, pat, &j, MAXPAT);
+    junk = addstr(ENDSTR, pat, &j, abs(MAXPAT));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
868,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(abs(BOL), pat, &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, pat, &j, MAXPAT);
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat, &j, MAXPAT);
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result;
}","<mb:mutant#0c2be59d578def01a3250bc7bea3e408a32d9efb> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -208 +208 @@
-	    junk = addstr(BOL, pat, &j, MAXPAT);
+	    junk = addstr(abs(BOL), pat, &j, MAXPAT);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
869,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk, dest, j, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, j, abs(maxset));
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, j, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest, j, maxset);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#a4cebf0ec4ebe5d7a21b83e3f972f4b9373261fc> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -112 +112 @@
-		junk = addstr(src[*i], dest, j, maxset);
+		junk = addstr(src[*i], dest, j, abs(maxset));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU>,
        <mb:operator#AORB>,
        <mb:operator#AORS>,
        <mb:operator#ROD>,
        <mb:operator#SEOD>,
        <mb:operator#SEOI> ;
    mb:program <mb:program#Replace.c> ."
870,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
	    escjunk = esc(abs(arg), &i);
	    junk = addstr(escjunk, pat, &j, MAXPAT);
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat, &j, MAXPAT);
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result;
}","<mb:mutant#f9bb9d6abb2c7639e9b1c9c303b10084f0ecb8ff> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -227 +227 @@
-	    escjunk = esc(arg, &i);
+	    escjunk = esc(abs(arg), &i);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:program <mb:program#Replace.c> ."
871,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk, dest, j, abs(maxset));
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, j, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest, j, maxset);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#f5ecc5cd41382c47d089adadeecb0de32e83eb52> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -109 +109 @@
-	    junk = addstr(escjunk, dest, j, maxset);
+	    junk = addstr(escjunk, dest, j, abs(maxset));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU>,
        <mb:operator#AORB>,
        <mb:operator#AORS>,
        <mb:operator#ROD>,
        <mb:operator#SEOD>,
        <mb:operator#SEOI> ;
    mb:program <mb:program#Replace.c> ."
872,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) || (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, pat, &j, MAXPAT);
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat, &j, MAXPAT);
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result;
}","<mb:mutant#22038f4dcdb6942340d9de8359bf03d75ea573ed> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -203 +203 @@
-    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
+    while ((!done) && (arg[i] != delim) || (arg[i] != ENDSTR)) {
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#SEOR> ;
    mb:program <mb:program#Replace.c> ."
873,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, &j, abs(MAXPAT));
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, pat, &j, MAXPAT);
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat, &j, MAXPAT);
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result;
}","<mb:mutant#eedf5514260e752a501922e813d917636aacaeca> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -208 +208 @@
-	    junk = addstr(BOL, pat, &j, MAXPAT);
+	    junk = addstr(BOL, pat, &j, abs(MAXPAT));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
874,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk, dest, j, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, j, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest, j, maxset--);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#418876a04782dcaa3fba76d179bada2278f36f90> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -125 +125 @@
-		junk = addstr(DASH, dest, j, maxset);
+		junk = addstr(DASH, dest, j, maxset--);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
875,"char
esc(s, i)
char 	*s;
int	*i;
{
    char	result;
    if (s[*i] != ESCAPE)
	result = s[*i];
    else
	if (s[*i + 1] == ENDSTR)
	    result = ESCAPE;
	else
	{
	    *i = *i + 1;
	    if (s[*i] == 'n')
		result = abs(NEWLINE);
	    else
		if (s[*i] == 't')
		    result = TAB;
		else
		    result = s[*i];
	}
    return result;
}","<mb:mutant#8851d9f1daca7b5d35aafe6482a958f1e109ce39> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -80 +80 @@
-		result = NEWLINE;
+		result = abs(NEWLINE);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU>,
        <mb:operator#AORB>,
        <mb:operator#AORS>,
        <mb:operator#ROD>,
        <mb:operator#SEOD>,
        <mb:operator#SEOI> ;
    mb:program <mb:program#Replace.c> ."
876,"char*	pat;
int	n;
{
    int size;
    if (!in_pat_set(pat[n])) {
(void)fprintf(stdout, ""in patsize: can't happen\n"");
abort();
    } else
switch (pat[n])
{
case LITCHAR: size = 2; break;
case BOL:  case EOL:  case ANY:
    size = 1;
    break;
case CCL:  case NCCL:
    size = pat[n + 1] + 2;
    break ;
case CLOSURE:
    size = CLOSIZE;
    break ;
default:
    Caseerror(pat[n]);
}
    return abs(size);
}","<mb:mutant#3a651f7c7bf89786dc3aaeb1ffa9e3c4958d7db8> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -413 +413 @@
-    return size;
+    return abs(size);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
877,"char
esc(s, i)
char 	*s;
int	*i;
{
    char	result;
    if (s[*i] != ESCAPE)
	result = s[*i];
    else
	if (s[*i + 1] == ENDSTR)
	    result = ESCAPE;
	else
	{
	    *i = *i + 1;
	    if (s[*i] == 'n')
		result = NEWLINE;
	    else
		if (s[*i] == 't')
		    result = TAB;
		else
		    result = s[abs(*i)];
	}
    return result;
}","<mb:mutant#a1ccfa7bd4c895b156e77eedb1a8e1eea38e2517> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -85 +85 @@
-		    result = s[*i];
+		    result = s[abs(*i)];
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU>,
        <mb:operator#AORB>,
        <mb:operator#AORS>,
        <mb:operator#ROD>,
        <mb:operator#SEOD>,
        <mb:operator#SEOI> ;
    mb:program <mb:program#Replace.c> ."
878,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, abs(&j), MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, pat, &j, MAXPAT);
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat, &j, MAXPAT);
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result;
}","<mb:mutant#13ea7228e260e9f8607f7101d404b6f6977cdd25> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -208 +208 @@
-	    junk = addstr(BOL, pat, &j, MAXPAT);
+	    junk = addstr(BOL, pat, abs(&j), MAXPAT);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
879,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, &j, abs(MAXPAT));
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, pat, &j, MAXPAT);
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat, &j, MAXPAT);
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result;
}","<mb:mutant#27478509c932d85373c7c491365aacf8c99d94ce> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -210 +210 @@
-	    junk = addstr(EOL, pat, &j, MAXPAT);
+	    junk = addstr(EOL, pat, &j, abs(MAXPAT));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
880,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(LITCHAR, abs(pat), &j, MAXPAT);
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, pat, &j, MAXPAT);
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat, &j, MAXPAT);
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result;
}","<mb:mutant#179ea636fe5252a780aa786b0e378f46cf6814b4> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -226 +226 @@
-	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
+	    junk = addstr(LITCHAR, abs(pat), &j, MAXPAT);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
881,"int
makesub(arg, from, delim, sub)
	char*	arg;
	int	from;
	character	delim;
	char*	sub;
{
    int  result;
    int	i, j;
    bool	junk;
    character	escjunk;
    j = 0;
    i = from;
    while ((arg[i] != delim) && (arg[i] != ENDSTR)) {
	if ((arg[i] == (unsigned)('&')))
	    junk = addstr(abs(DITTO), sub, &j, MAXPAT);
	else {
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, sub, &j, MAXPAT);
	}
	i = i + 1;
    }
    if (arg[i] != delim)
	result = 0;
    else {
	junk = addstr(ENDSTR, &(*sub), &j, MAXPAT);
	if ((!junk))
	    result = 0;
	else
	    result = i;
    }
    return result;
}","<mb:mutant#5784348232145aa8f462c52bdaaceb4323155945> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -272 +272 @@
-	    junk = addstr(DITTO, sub, &j, MAXPAT);
+	    junk = addstr(abs(DITTO), sub, &j, MAXPAT);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
882,"void
stclose(pat, j, lastj)
char	*pat;
int	*j;
int	lastj;
{
   int	jt;
   int	jp;
   bool	junk;
   for (jp = *j - 1; jp >= lastj ; jp--)
   {
	jt = jp + CLOSIZE;
	junk = addstr(pat[jp], pat, &jt, MAXPAT);
   }
   *j = *j + CLOSIZE;
   pat[lastj] = abs(CLOSURE);
}","<mb:mutant#9f76c33c5dfacd6dc3a4e115cdce3294cae1af7f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -170 +170 @@
-    pat[lastj] = CLOSURE;
+    pat[lastj] = abs(CLOSURE);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
883,"int
makesub(arg, from, delim, sub)
	char*	arg;
	int	from;
	character	delim;
	char*	sub;
{
    int  result;
    int	i, j;
    bool	junk;
    character	escjunk;
    j = 0;
    i = from;
    while ((arg[i] != delim) && (arg[i] != ENDSTR)) {
	if ((arg[i] == (unsigned)('&')))
	    junk = addstr(DITTO, sub, &j, MAXPAT);
	else {
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, sub, &j, MAXPAT);
	}
	i = i + 1;
    }
    if (arg[i] != delim)
	result = 0;
    else {
	junk = addstr(ENDSTR, &(*sub), &j, MAXPAT);
	if ((!junk))
	    result = 0;
	else
	    result = i;
    }
    return result--;
}","<mb:mutant#9c0ca3b24ba484333199b4135a811bd84e9e7627> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -288 +288 @@
-    return result;
+    return result--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
884,"int
getpat(arg, pat)
char*	arg;
char*	pat;
{
    int	makeres;
    makeres = makepat(arg, 0, ENDSTR, pat--);
    return (makeres > 0);
}","<mb:mutant#b548cdeb6accd4848e2f752f8d091b1b8236a6b6> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -252 +252 @@
-    makeres = makepat(arg, 0, ENDSTR, pat);
+    makeres = makepat(arg, 0, ENDSTR, pat--);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
885,"bool
getccl(arg, i, pat, j)
char	*arg;
int	*i;
char	*pat;
int	*j;
{
    int	jstart;
    bool	junk;
    *i = *i + 1;
    if (arg[*i] == NEGATE) {
	junk = addstr(NCCL, pat, j, MAXPAT);
	*i = *i + 1;
    } else
	junk = addstr(CCL, pat, j, MAXPAT);
    jstart = *j;
    junk = addstr(0, pat, j, MAXPAT);
    dodash(CCLEND, arg, i, pat, j, MAXPAT);
    pat[jstart] = *j-- - jstart - 1;
    return (arg[*i] == CCLEND);
}","<mb:mutant#919358db50bed497e3972d2d9274936997bba469> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -149 +149 @@
-    pat[jstart] = *j - jstart - 1;
+    pat[jstart] = *j-- - jstart - 1;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
886,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, pat, &j, MAXPAT);
	}
	lastj = lj--;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat, &j, MAXPAT);
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result;
}","<mb:mutant#a83e954ea11bed6128ecd29e071f85db283ddbd3> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -230 +230 @@
-	lastj = lj;
+	lastj = lj--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
887,"bool
getccl(arg, i, pat, j)
char	*arg;
int	*i;
char	*pat;
int	*j;
{
    int	jstart;
    bool	junk;
    *i = *i + 1;
    if (arg[*i] == NEGATE) {
	junk = addstr(NCCL, pat, j, MAXPAT);
	*i = *i + 1;
    } else
	junk = addstr(abs(CCL), pat, j, MAXPAT);
    jstart = *j;
    junk = addstr(0, pat, j, MAXPAT);
    dodash(CCLEND, arg, i, pat, j, MAXPAT);
    pat[jstart] = *j - jstart - 1;
    return (arg[*i] == CCLEND);
}","<mb:mutant#73a5a753f2b152a312c0b263f121fa8d83cbed8a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -145 +145 @@
-	junk = addstr(CCL, pat, j, MAXPAT);
+	junk = addstr(abs(CCL), pat, j, MAXPAT);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
888,"char*	pat;
int	n;
{
    int size;
    if (!in_pat_set(pat[n])) {
(void)fprintf(stdout, ""in patsize: can't happen\n"");
abort();
    } else
switch (pat[n])
{
case LITCHAR: size = 2; break;
case BOL:  case EOL:  case ANY:
    size = 1;
    break;
case CCL:  case NCCL:
    size = pat[n + 1] + 2;
    break ;
case CLOSURE:
    size = CLOSIZE;
    break ;
default:
    Caseerror(pat[n]);
}
    return size++;
}","<mb:mutant#a5c8941ddfa7e7b2ee26cff0f940ab736291a4f2> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -413 +413 @@
-    return size;
+    return size++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
889,"int
makesub(arg, from, delim, sub)
	char*	arg;
	int	from;
	character	delim;
	char*	sub;
{
    int  result;
    int	i, j;
    bool	junk;
    character	escjunk;
    j = 0;
    i = from;
    while ((arg[i] != delim) && (arg[i] != ENDSTR)) {
	if ((arg[i] == (unsigned)('&')))
	    junk = addstr(DITTO, sub, abs(&j), MAXPAT);
	else {
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, sub, &j, MAXPAT);
	}
	i = i + 1;
    }
    if (arg[i] != delim)
	result = 0;
    else {
	junk = addstr(ENDSTR, &(*sub), &j, MAXPAT);
	if ((!junk))
	    result = 0;
	else
	    result = i;
    }
    return result;
}","<mb:mutant#421ddf236729223cb2700d88c97843fe54b0ba74> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -272 +272 @@
-	    junk = addstr(DITTO, sub, &j, MAXPAT);
+	    junk = addstr(DITTO, sub, abs(&j), MAXPAT);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
890,"char*	pat;
int	n;
{
    int size;
    if (!in_pat_set(pat[n])) {
(void)fprintf(stdout, ""in patsize: can't happen\n"");
abort();
    } else
switch (pat[n])
{
case LITCHAR: size = 2; break;
case BOL:  case EOL:  case ANY:
    size = 1;
    break;
case CCL:  case NCCL:
    size = pat[n + 1] + 2;
    break ;
case CLOSURE:
    size = CLOSIZE;
    break ;
default:
    Caseerror(pat[n++]);
}
    return size;
}","<mb:mutant#2a39011a6ee45e001c480b54418e8d2acc563413> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -411 +411 @@
-	    Caseerror(pat[n]);
+	    Caseerror(pat[n++]);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
891,"int
getpat(arg, pat)
char*	arg;
char*	pat;
{
    int	makeres;
    makeres = makepat(arg, 0, ENDSTR, pat++);
    return (makeres > 0);
}","<mb:mutant#9a24d34369b61ab7f1c8170470e51d1332875d0d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -252 +252 @@
-    makeres = makepat(arg, 0, ENDSTR, pat);
+    makeres = makepat(arg, 0, ENDSTR, pat++);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
892,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, &j, abs(MAXPAT));
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, pat, &j, MAXPAT);
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat, &j, MAXPAT);
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result;
}","<mb:mutant#db833f93b5ddfd7397bba95cf7f0706aac32112d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -206 +206 @@
-	    junk = addstr(ANY, pat, &j, MAXPAT);
+	    junk = addstr(ANY, pat, &j, abs(MAXPAT));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
893,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, pat, &j, MAXPAT);
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat, &j, MAXPAT);
    if ((done) || (arg[i] != delim++))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result;
}","<mb:mutant#e696acb074f7bc552dd7a098e95f005a0d3736cd> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -235 +235 @@
-    if ((done) || (arg[i] != delim))
+    if ((done) || (arg[i] != delim++))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
894,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk++, dest, j, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, j, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest, j, maxset);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#56028b9beeecbe76dac019c7cfe71a6ec2dd52b1> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -109 +109 @@
-	    junk = addstr(escjunk, dest, j, maxset);
+	    junk = addstr(escjunk++, dest, j, maxset);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
895,"bool
getccl(arg, i, pat, j)
char	*arg;
int	*i;
char	*pat;
int	*j;
{
    int	jstart;
    bool	junk;
    *i = *i + 1;
    if (arg[*i] == NEGATE) {
	junk = addstr(NCCL, pat, j, MAXPAT);
	*i = abs(*i) + 1;
    } else
	junk = addstr(CCL, pat, j, MAXPAT);
    jstart = *j;
    junk = addstr(0, pat, j, MAXPAT);
    dodash(CCLEND, arg, i, pat, j, MAXPAT);
    pat[jstart] = *j - jstart - 1;
    return (arg[*i] == CCLEND);
}","<mb:mutant#76224afb41e58d37e274d35c0321e6ce3fa61f8b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -143 +143 @@
-	*i = *i + 1;
+	*i = abs(*i) + 1;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
896,"bool
omatch(lin, i, pat, j)
	char*	lin;
	int	*i;
	char*	pat;
	int	j;
{
    char	advance;
    bool result;
    advance = -1;
    if ((lin[*i] == ENDSTR))
	result = false;
    else
    {
	if (!in_pat_set(pat[j]))
	{
	    (void)fprintf(stdout, ""in omatch: can't happen\n"");
	    abort();
	} else
	{
	     switch (pat[j])
	     {
	     case LITCHAR:
		 if (lin[*i] == pat[j + 1])
		     advance = 1;
		 break ;
	     case BOL:
		 if (*i == 0)
		     advance = 0;
		 break ;
	     case ANY:
		 if (lin[*i] != NEWLINE)
		     advance = 1;
		 break ;
	     case EOL:
		 if (lin[*i] == NEWLINE)
		     advance = 0;
		 break ;
	     case CCL:
		 if (locate(lin[*i], pat, j + 1))
		     advance = 1;
		 break ;
	     case NCCL:
		 if ((lin[*i] != NEWLINE) && (!locate(lin[*i], pat, j+1)))
		     advance = 1;
		 break ;
	     default:
		 Caseerror(pat[j]--);
	     };
	 }
    }
    if ((advance >= 0))
    {
	*i = *i + advance;
	result = true;
    } else
	result = false;
    return result;
}","<mb:mutant#9bd171338089876142d62787a10ee1f5ff3fdcf3> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -374 +374 @@
-		 Caseerror(pat[j]);
+		 Caseerror(pat[j]--);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
897,"int
makesub(arg, from, delim, sub)
	char*	arg;
	int	from;
	character	delim;
	char*	sub;
{
    int  result;
    int	i, j;
    bool	junk;
    character	escjunk;
    j = 0;
    i = from;
    while ((arg[i] != delim) && (arg[i] != ENDSTR)) {
	if ((arg[i] == (unsigned)('&')))
	    junk = addstr(DITTO, sub, &j, MAXPAT);
	else {
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, sub, &j, MAXPAT);
	}
	i = abs(i) + 1;
    }
    if (arg[i] != delim)
	result = 0;
    else {
	junk = addstr(ENDSTR, &(*sub), &j, MAXPAT);
	if ((!junk))
	    result = 0;
	else
	    result = i;
    }
    return result;
}","<mb:mutant#241022a0c07def84896e57751a63a0d755577a53> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -277 +277 @@
-	i = i + 1;
+	i = abs(i) + 1;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
898,"int
getpat(arg, pat)
char*	arg;
char*	pat;
{
    int	makeres;
    makeres = makepat(arg++, 0, ENDSTR, pat);
    return (makeres > 0);
}","<mb:mutant#6565579386c7e469320e75d6479dc64663021276> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -252 +252 @@
-    makeres = makepat(arg, 0, ENDSTR, pat);
+    makeres = makepat(arg++, 0, ENDSTR, pat);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
899,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i != start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, pat, &j, MAXPAT);
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat, &j, MAXPAT);
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result;
}","<mb:mutant#332d17342e8350d90163244a605d8d9f758a47f2> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -216 +216 @@
-	else if ((arg[i] == CLOSURE) && (i > start))
+	else if ((arg[i] == CLOSURE) && (i != start))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Replace.c> ."
900,"int
makesub(arg, from, delim, sub)
	char*	arg;
	int	from;
	character	delim;
	char*	sub;
{
    int  result;
    int	i, j;
    bool	junk;
    character	escjunk;
    j = 0;
    i = from;
    while ((arg[i] != delim) && (arg[i] != ENDSTR)) {
	if ((arg[i] == (unsigned)('&')))
	    junk = addstr(DITTO, sub, &j, MAXPAT);
	else {
	    escjunk = esc(arg, &i);
	    junk = addstr(abs(escjunk), sub, &j, MAXPAT);
	}
	i = i + 1;
    }
    if (arg[i] != delim)
	result = 0;
    else {
	junk = addstr(ENDSTR, &(*sub), &j, MAXPAT);
	if ((!junk))
	    result = 0;
	else
	    result = i;
    }
    return result;
}","<mb:mutant#de52ce4555930c089d7c01461139f1cd7c7ec04f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -275 +275 @@
-	    junk = addstr(escjunk, sub, &j, MAXPAT);
+	    junk = addstr(abs(escjunk), sub, &j, MAXPAT);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
901,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk, dest, j, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, j, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, abs(maxset));
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest, j, maxset);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#cd6e6b95cb9e6988b6876e3dce53b064dd78c698> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -120 +120 @@
-			junk = addstr(k, dest, j, maxset);
+			junk = addstr(k, dest, j, abs(maxset));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU>,
        <mb:operator#AORB>,
        <mb:operator#AORS>,
        <mb:operator#ROD>,
        <mb:operator#SEOD>,
        <mb:operator#SEOI> ;
    mb:program <mb:program#Replace.c> ."
902,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, abs(&j), MAXPAT);
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, pat, &j, MAXPAT);
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat, &j, MAXPAT);
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result;
}","<mb:mutant#e90ec0c7f4148f4c58197196748683161a7d38bc> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -226 +226 @@
-	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
+	    junk = addstr(LITCHAR, pat, abs(&j), MAXPAT);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
903,"int
getpat(arg, pat)
char*	arg;
char*	pat;
{
    int	makeres;
    makeres = makepat(arg--, 0, ENDSTR, pat);
    return (makeres > 0);
}","<mb:mutant#6eadf48b235b5bb5a8163a656653160b62c72f15> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -252 +252 @@
-    makeres = makepat(arg, 0, ENDSTR, pat);
+    makeres = makepat(arg--, 0, ENDSTR, pat);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
904,"char
esc(s, i)
char 	*s;
int	*i;
{
    char	result;
    if (s[*i] != ESCAPE)
	result = s[*i];
    else
	if (s[*i + 1] == ENDSTR)
	    result = ESCAPE;
	else
	{
	    *i = abs(*i) + 1;
	    if (s[*i] == 'n')
		result = NEWLINE;
	    else
		if (s[*i] == 't')
		    result = TAB;
		else
		    result = s[*i];
	}
    return result;
}","<mb:mutant#ec91c70033dbb4b4b81e0f1a0e69a3f5ebb0bca9> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -78 +78 @@
-	    *i = *i + 1;
+	    *i = abs(*i) + 1;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU>,
        <mb:operator#AORB>,
        <mb:operator#AORS>,
        <mb:operator#ROD>,
        <mb:operator#SEOD>,
        <mb:operator#SEOI> ;
    mb:program <mb:program#Replace.c> ."
905,"bool
omatch(lin, i, pat, j)
	char*	lin;
	int	*i;
	char*	pat;
	int	j;
{
    char	advance;
    bool result;
    advance = -1;
    if ((lin[*i] == ENDSTR))
	result = false;
    else
    {
	if (!in_pat_set(pat[j]))
	{
	    (void)fprintf(stdout, ""in omatch: can't happen\n"");
	    abort();
	} else
	{
	     switch (pat[j])
	     {
	     case LITCHAR:
		 if (lin[*i] == pat[j + 1])
		     advance = 1;
		 break ;
	     case BOL:
		 if (*i == 0)
		     advance = 0;
		 break ;
	     case ANY:
		 if (lin[*i] != NEWLINE)
		     advance = 1;
		 break ;
	     case EOL:
		 if (lin[*i] == NEWLINE)
		     advance = 0;
		 break ;
	     case CCL:
		 if (locate(lin[*i], pat, j + 1))
		     advance = 1;
		 break ;
	     case NCCL:
		 if ((lin[*i] != NEWLINE) && (!locate(lin[*i], pat, j+1)))
		     advance = 1;
		 break ;
	     default:
		 Caseerror(pat[j--]);
	     };
	 }
    }
    if ((advance >= 0))
    {
	*i = *i + advance;
	result = true;
    } else
	result = false;
    return result;
}","<mb:mutant#2eb6eac7a69a0059a3c22eeeb9b3ee23d9089cc3> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -374 +374 @@
-		 Caseerror(pat[j]);
+		 Caseerror(pat[j--]);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
906,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk, dest, j, maxset--);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, j, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest, j, maxset);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#65e05c686f2bce4c9beb76da3fa17841cb53acae> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -109 +109 @@
-	    junk = addstr(escjunk, dest, j, maxset);
+	    junk = addstr(escjunk, dest, j, maxset--);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
907,"void
stclose(pat, j, lastj)
char	*pat;
int	*j;
int	lastj;
{
   int	jt;
   int	jp;
   bool	junk;
   for (jp = *j - 1; jp >= lastj ; jp--)
   {
	jt = jp + CLOSIZE;
	junk = addstr(pat[jp], pat, &jt, MAXPAT);
   }
   *j = abs(*j) + CLOSIZE;
   pat[lastj] = CLOSURE;
}","<mb:mutant#31da1f677dd4a776a4027912f7375efbe9fbbb8e> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -169 +169 @@
-    *j = *j + CLOSIZE;
+    *j = abs(*j) + CLOSIZE;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
908,"int
makesub(arg, from, delim, sub)
	char*	arg;
	int	from;
	character	delim;
	char*	sub;
{
    int  result;
    int	i, j;
    bool	junk;
    character	escjunk;
    j = 0;
    i = from;
    while ((arg[i] != delim) && (arg[i] != ENDSTR)) {
	if ((arg[i] == (unsigned)('&')))
	    junk = addstr(DITTO, sub, &j, MAXPAT);
	else {
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, sub, &j, MAXPAT);
	}
	i = i + 1;
    }
    if (arg[i] != delim)
	result = 0;
    else {
	junk = addstr(abs(ENDSTR), &(*sub), &j, MAXPAT);
	if ((!junk))
	    result = 0;
	else
	    result = i;
    }
    return result;
}","<mb:mutant#4578263a9c86666fde3bea464aa9777660001e69> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -282 +282 @@
-	junk = addstr(ENDSTR, &(*sub), &j, MAXPAT);
+	junk = addstr(abs(ENDSTR), &(*sub), &j, MAXPAT);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
909,"bool
omatch(lin, i, pat, j)
	char*	lin;
	int	*i;
	char*	pat;
	int	j;
{
    char	advance;
    bool result;
    advance = -1;
    if ((lin[*i] == ENDSTR))
	result = false;
    else
    {
	if (!in_pat_set(pat[j]))
	{
	    (void)fprintf(stdout, ""in omatch: can't happen\n"");
	    abort();
	} else
	{
	     switch (pat[j])
	     {
	     case LITCHAR:
		 if (lin[*i] == pat[j + 1])
		     advance = 1;
		 break ;
	     case BOL:
		 if (*i <= 0)
		     advance = 0;
		 break ;
	     case ANY:
		 if (lin[*i] != NEWLINE)
		     advance = 1;
		 break ;
	     case EOL:
		 if (lin[*i] == NEWLINE)
		     advance = 0;
		 break ;
	     case CCL:
		 if (locate(lin[*i], pat, j + 1))
		     advance = 1;
		 break ;
	     case NCCL:
		 if ((lin[*i] != NEWLINE) && (!locate(lin[*i], pat, j+1)))
		     advance = 1;
		 break ;
	     default:
		 Caseerror(pat[j]);
	     };
	 }
    }
    if ((advance >= 0))
    {
	*i = *i + advance;
	result = true;
    } else
	result = false;
    return result;
}","<mb:mutant#ae037c4d232df2d8b990f93fdf70c0bbf03ada27> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -354 +354 @@
-		 if (*i == 0)
+		 if (*i <= 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Replace.c> ."
910,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk, dest, j, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, j, maxset--);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest, j, maxset);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#00564c6bbf0f488185b9a71b8eeaafbab93cb09b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -114 +114 @@
-		junk = addstr(DASH, dest, j, maxset);
+		junk = addstr(DASH, dest, j, maxset--);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
911,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, pat, &j, MAXPAT);
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat, &j, MAXPAT);
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result++;
}","<mb:mutant#eb48f275ebd28cde7b63d1514f53479346e94e3c> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -242 +242 @@
-    return result;
+    return result++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
912,"int
getpat(arg, pat)
char*	arg;
char*	pat;
{
    int	makeres;
    makeres = makepat(arg, 0, ENDSTR, pat);
    return (makeres-- > 0);
}","<mb:mutant#5610e9e146d2ee7023428ded7bfad80c380ffa84> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -253 +253 @@
-    return (makeres > 0);
+    return (makeres-- > 0);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
913,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
	    escjunk = esc(arg, abs(&i));
	    junk = addstr(escjunk, pat, &j, MAXPAT);
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat, &j, MAXPAT);
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result;
}","<mb:mutant#53e75d0117218ae23ff96c7c1b6bddfa063df852> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -227 +227 @@
-	    escjunk = esc(arg, &i);
+	    escjunk = esc(arg, abs(&i));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
914,"char*	pat;
int	n;
{
    int size;
    if (!in_pat_set(pat[n])) {
(void)fprintf(stdout, ""in patsize: can't happen\n"");
abort();
    } else
switch (pat[n])
{
case LITCHAR: size = 2; break;
case BOL:  case EOL:  case ANY:
    size = 1;
    break;
case CCL:  case NCCL:
    size = pat[n + 1] + 2;
    break ;
case CLOSURE:
    size = CLOSIZE;
    break ;
default:
    Caseerror(pat[n]++);
}
    return size;
}","<mb:mutant#4ab35833da9eabd31190ccbd9000ddabe8ad6dc0> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -411 +411 @@
-	    Caseerror(pat[n]);
+	    Caseerror(pat[n]++);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
915,"int
makesub(arg, from, delim, sub)
	char*	arg;
	int	from;
	character	delim;
	char*	sub;
{
    int  result;
    int	i, j;
    bool	junk;
    character	escjunk;
    j = 0;
    i = from--;
    while ((arg[i] != delim) && (arg[i] != ENDSTR)) {
	if ((arg[i] == (unsigned)('&')))
	    junk = addstr(DITTO, sub, &j, MAXPAT);
	else {
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, sub, &j, MAXPAT);
	}
	i = i + 1;
    }
    if (arg[i] != delim)
	result = 0;
    else {
	junk = addstr(ENDSTR, &(*sub), &j, MAXPAT);
	if ((!junk))
	    result = 0;
	else
	    result = i;
    }
    return result;
}","<mb:mutant#7fe600aa8defc304173b92d6f4a36e4772e38ec1> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -269 +269 @@
-    i = from;
+    i = from--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
916,"bool
getccl(arg, i, pat, j)
char	*arg;
int	*i;
char	*pat;
int	*j;
{
    int	jstart;
    bool	junk;
    *i = *i + 1;
    if (arg[*i] == NEGATE) {
	junk = addstr(NCCL, pat, j, MAXPAT);
	*i = *i + 1;
    } else
	junk = addstr(CCL, pat, abs(j), MAXPAT);
    jstart = *j;
    junk = addstr(0, pat, j, MAXPAT);
    dodash(CCLEND, arg, i, pat, j, MAXPAT);
    pat[jstart] = *j - jstart - 1;
    return (arg[*i] == CCLEND);
}","<mb:mutant#a7e7fc8149b5d986b1964d2a9cf0481dff4192de> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -145 +145 @@
-	junk = addstr(CCL, pat, j, MAXPAT);
+	junk = addstr(CCL, pat, abs(j), MAXPAT);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
917,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, abs(&j), MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, pat, &j, MAXPAT);
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat, &j, MAXPAT);
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result;
}","<mb:mutant#ffb435616c65d4881f2a10c2157eab3493ee374d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -210 +210 @@
-	    junk = addstr(EOL, pat, &j, MAXPAT);
+	    junk = addstr(EOL, pat, abs(&j), MAXPAT);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
918,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk, dest, j, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, abs(j), maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest, j, maxset);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#0a715a99489a780416caed40675ea3c92a74a860> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -114 +114 @@
-		junk = addstr(DASH, dest, j, maxset);
+		junk = addstr(DASH, dest, abs(j), maxset);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU>,
        <mb:operator#AORB>,
        <mb:operator#AORS>,
        <mb:operator#ROD>,
        <mb:operator#SEOD>,
        <mb:operator#SEOI> ;
    mb:program <mb:program#Replace.c> ."
919,"char*	pat;
int	n;
{
    int size;
    if (!in_pat_set(pat[n])) {
(void)fprintf(stdout, ""in patsize: can't happen\n"");
abort();
    } else
switch (pat[n])
{
case LITCHAR: size = 2; break;
case BOL:  case EOL:  case ANY:
    size = 1;
    break;
case CCL:  case NCCL:
    size = pat[n + 1] + 2;
    break ;
case CLOSURE:
    size = CLOSIZE;
    break ;
default:
    Caseerror(pat[n--]);
}
    return size;
}","<mb:mutant#781d4d9b55a1a64e34a3d35afa5434e3591849cb> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -411 +411 @@
-	    Caseerror(pat[n]);
+	    Caseerror(pat[n--]);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
920,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
	    escjunk = esc(arg, &i);
	    junk = addstr(abs(escjunk), pat, &j, MAXPAT);
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat, &j, MAXPAT);
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result;
}","<mb:mutant#0ba07d4747e9caee97262442af4a95aea7c62896> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -228 +228 @@
-	    junk = addstr(escjunk, pat, &j, MAXPAT);
+	    junk = addstr(abs(escjunk), pat, &j, MAXPAT);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
921,"bool
omatch(lin, i, pat, j)
	char*	lin;
	int	*i;
	char*	pat;
	int	j;
{
    char	advance;
    bool result;
    advance = -1;
    if ((lin[*i] == ENDSTR))
	result = false;
    else
    {
	if (!in_pat_set(pat[j]))
	{
	    (void)fprintf(stdout, ""in omatch: can't happen\n"");
	    abort();
	} else
	{
	     switch (pat[j])
	     {
	     case LITCHAR:
		 if (lin[*i] == pat[j + 1])
		     advance = 1;
		 break ;
	     case BOL:
		 if (*i == 0)
		     advance = 0;
		 break ;
	     case ANY:
		 if (lin[*i] != NEWLINE)
		     advance = 1;
		 break ;
	     case EOL:
		 if (lin[*i] == NEWLINE)
		     advance = 0;
		 break ;
	     case CCL:
		 if (locate(lin[*i], pat, j + 1))
		     advance = 1;
		 break ;
	     case NCCL:
		 if ((lin[*i] != NEWLINE) && (!locate(lin[*i], pat, j+1)))
		     advance = 1;
		 break ;
	     default:
		 Caseerror(pat[j]);
	     };
	 }
    }
    if ((advance >= 0))
    {
	*i = abs(*i) + advance;
	result = true;
    } else
	result = false;
    return result;
}","<mb:mutant#225cc737ab74238f8ccffa695c580a898f44ccd8> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -380 +380 @@
-	*i = *i + advance;
+	*i = abs(*i) + advance;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
922,"bool
getsub(arg, sub)
	char*	arg;
	char*	sub;
{
    int	makeres;
    makeres = makesub(arg, 0, ENDSTR, sub);
    return (makeres++ > 0);
}","<mb:mutant#25da4da0d0c1c44d375c4d348847f50204901947> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -299 +299 @@
-    return (makeres > 0);
+    return (makeres++ > 0);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
923,"int
amatch(lin, offset, pat, j)
	char*	lin;
	int	offset;
	char*	pat;
	int	j;
{
    int	i, k;
    bool	result, done;
    done = false;
    while ((!done) && (pat[j] != ENDSTR))
	if ((pat[j] == CLOSURE)) {
	    j = j + patsize(pat, j);
	    i = offset;
	    while ((!done) && (lin[i] != ENDSTR)) {
		result = omatch(lin, &i, pat, j);
		if (!result)
		    done = true;
	    }
	    done = false;
	    while ((!done) && (i >= offset)) {
		k = amatch(lin, i, pat, j + patsize(pat, j));
		if ((k >= 0))
		    done = true;
		else
		    i = i - 1;
	    }
	    offset = k;
	    done = true;
	} else {
	    result = omatch(lin, &offset, pat, j);
	    if ((!result)) {
		offset = -1;
		done = true;
	    } else
		j = j + patsize(abs(pat), j);
	}
     return offset;
}","<mb:mutant#56e6747915081314dbc54131df9aa434677611ff> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -452 +452 @@
-		j = j + patsize(pat, j);
+		j = j + patsize(abs(pat), j);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
924,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk, dest, j, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, j, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, abs(j), maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest, j, maxset);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#2a444f20142e818ebf45c745705d80db521db04a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -120 +120 @@
-			junk = addstr(k, dest, j, maxset);
+			junk = addstr(k, dest, abs(j), maxset);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU>,
        <mb:operator#AORB>,
        <mb:operator#AORS>,
        <mb:operator#ROD>,
        <mb:operator#SEOD>,
        <mb:operator#SEOI> ;
    mb:program <mb:program#Replace.c> ."
925,"int
getpat(arg, pat)
char*	arg;
char*	pat;
{
    int	makeres;
    makeres = makepat(arg, 0, ENDSTR, pat);
    return (makeres != 0);
}","<mb:mutant#3bdb95d8059972d6e461ddcaeedbd6e9e5d70622> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -253 +253 @@
-    return (makeres > 0);
+    return (makeres != 0);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Replace.c> ."
926,"int
amatch(lin, offset, pat, j)
	char*	lin;
	int	offset;
	char*	pat;
	int	j;
{
    int	i, k;
    bool	result, done;
    done = false;
    while ((!done) && (pat[j] != ENDSTR))
	if ((pat[j] == CLOSURE)) {
	    j = j + patsize(pat, j);
	    i = offset;
	    while ((!done) && (lin[i] != ENDSTR)) {
		result = omatch(lin, &i, pat, j);
		if (!result)
		    done = true;
	    }
	    done = false;
	    while ((!done) && (i >= offset)) {
		k = amatch(lin, i, pat, j + patsize(pat, j));
		if ((k >= 0))
		    done = true;
		else
		    i = i - 1;
	    }
	    offset = k;
	    done = true;
	} else {
	    result = omatch(lin, &offset, pat, j);
	    if ((!result)) {
		offset = -1;
		done = true;
	    } else
		j = abs(j) + patsize(pat, j);
	}
     return offset;
}","<mb:mutant#9fea58c81570f317a1628b63035af0444a9d6916> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -452 +452 @@
-		j = j + patsize(pat, j);
+		j = abs(j) + patsize(pat, j);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
927,"int
makesub(arg, from, delim, sub)
	char*	arg;
	int	from;
	character	delim;
	char*	sub;
{
    int  result;
    int	i, j;
    bool	junk;
    character	escjunk;
    j = 0;
    i = from;
    while ((arg[i] != delim) && (arg[i] != ENDSTR)) {
	if ((arg[i] == (unsigned)('&')))
	    junk = addstr(DITTO, sub, &j, MAXPAT);
	else {
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, sub, &j, MAXPAT);
	}
	i = i + 1;
    }
    if (arg[i] != delim)
	result = 0;
    else {
	junk = addstr(ENDSTR, &(*sub), abs(&j), MAXPAT);
	if ((!junk))
	    result = 0;
	else
	    result = i;
    }
    return result;
}","<mb:mutant#02c013a28196e993071a8b98452b3fb72086595b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -282 +282 @@
-	junk = addstr(ENDSTR, &(*sub), &j, MAXPAT);
+	junk = addstr(ENDSTR, &(*sub), abs(&j), MAXPAT);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
928,"bool
getccl(arg, i, pat, j)
char	*arg;
int	*i;
char	*pat;
int	*j;
{
    int	jstart;
    bool	junk;
    *i = *i + 1;
    if (arg[*i] == NEGATE) {
	junk = addstr(NCCL, pat, abs(j), MAXPAT);
	*i = *i + 1;
    } else
	junk = addstr(CCL, pat, j, MAXPAT);
    jstart = *j;
    junk = addstr(0, pat, j, MAXPAT);
    dodash(CCLEND, arg, i, pat, j, MAXPAT);
    pat[jstart] = *j - jstart - 1;
    return (arg[*i] == CCLEND);
}","<mb:mutant#929cd331f01aae7c0d0aae5d2e38e760ef2bb5f6> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -142 +142 @@
-	junk = addstr(NCCL, pat, j, MAXPAT);
+	junk = addstr(NCCL, pat, abs(j), MAXPAT);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
929,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, pat, &j, MAXPAT);
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, abs(pat), &j, MAXPAT);
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result;
}","<mb:mutant#b3caf820c44d8d46eb84a4c94d383a94145e5148> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -234 +234 @@
-    junk = addstr(ENDSTR, pat, &j, MAXPAT);
+    junk = addstr(ENDSTR, abs(pat), &j, MAXPAT);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
930,"int
makesub(arg, from, delim, sub)
	char*	arg;
	int	from;
	character	delim;
	char*	sub;
{
    int  result;
    int	i, j;
    bool	junk;
    character	escjunk;
    j = 0;
    i = from;
    while ((arg[i] != delim) && (arg[i] != ENDSTR)) {
	if ((arg[i] == (unsigned)('&')))
	    junk = addstr(DITTO, sub, &j, MAXPAT);
	else {
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, sub, &j, MAXPAT);
	}
	i = i + 1;
    }
    if (arg[i] != delim)
	result = 0;
    else {
	junk = addstr(ENDSTR, &(*sub), &j, MAXPAT);
	if ((!junk))
	    result = 0;
	else
	    result = i;
    }
    return abs(result);
}","<mb:mutant#8b15e8e47a622e28e5fe6b41b8c4b4581a979dd1> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -288 +288 @@
-    return result;
+    return abs(result);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
931,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, abs(i));
	    junk = addstr(escjunk, dest, j, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, j, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest, j, maxset);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#39c304ed4809fb4fe0e3842103cde0f5f73978fc> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -108 +108 @@
-	    escjunk = esc(src, i);
+	    escjunk = esc(src, abs(i));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU>,
        <mb:operator#AORB>,
        <mb:operator#AORS>,
        <mb:operator#ROD>,
        <mb:operator#SEOD>,
        <mb:operator#SEOI> ;
    mb:program <mb:program#Replace.c> ."
932,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk, dest, abs(j), maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, j, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest, j, maxset);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#2f78c4745bcd6b4da64c0a0182b716aff88cfc14> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -109 +109 @@
-	    junk = addstr(escjunk, dest, j, maxset);
+	    junk = addstr(escjunk, dest, abs(j), maxset);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU>,
        <mb:operator#AORB>,
        <mb:operator#AORS>,
        <mb:operator#ROD>,
        <mb:operator#SEOD>,
        <mb:operator#SEOI> ;
    mb:program <mb:program#Replace.c> ."
933,"int
amatch(lin, offset, pat, j)
	char*	lin;
	int	offset;
	char*	pat;
	int	j;
{
    int	i, k;
    bool	result, done;
    done = false;
    while ((!done) && (pat[j] != ENDSTR))
	if ((pat[j] == CLOSURE)) {
	    j = j + patsize(abs(pat), j);
	    i = offset;
	    while ((!done) && (lin[i] != ENDSTR)) {
		result = omatch(lin, &i, pat, j);
		if (!result)
		    done = true;
	    }
	    done = false;
	    while ((!done) && (i >= offset)) {
		k = amatch(lin, i, pat, j + patsize(pat, j));
		if ((k >= 0))
		    done = true;
		else
		    i = i - 1;
	    }
	    offset = k;
	    done = true;
	} else {
	    result = omatch(lin, &offset, pat, j);
	    if ((!result)) {
		offset = -1;
		done = true;
	    } else
		j = j + patsize(pat, j);
	}
     return offset;
}","<mb:mutant#757a3300d69ab93632f361cbd8c2a6f4d360faf7> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -429 +429 @@
-	    j = j + patsize(pat, j);
+	    j = j + patsize(abs(pat), j);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
934,"bool
getccl(arg, i, pat, j)
char	*arg;
int	*i;
char	*pat;
int	*j;
{
    int	jstart;
    bool	junk;
    *i = abs(*i) + 1;
    if (arg[*i] == NEGATE) {
	junk = addstr(NCCL, pat, j, MAXPAT);
	*i = *i + 1;
    } else
	junk = addstr(CCL, pat, j, MAXPAT);
    jstart = *j;
    junk = addstr(0, pat, j, MAXPAT);
    dodash(CCLEND, arg, i, pat, j, MAXPAT);
    pat[jstart] = *j - jstart - 1;
    return (arg[*i] == CCLEND);
}","<mb:mutant#39c7550473c8f0a676aea062262f9cf383e910ba> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -140 +140 @@
-    *i = *i + 1;
+    *i = abs(*i) + 1;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
935,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk, dest, j, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, j, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, abs(dest), j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest, j, maxset);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#9949e812cf995a76c0d9eb30386b8656dcaf546a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -120 +120 @@
-			junk = addstr(k, dest, j, maxset);
+			junk = addstr(k, abs(dest), j, maxset);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU>,
        <mb:operator#AORB>,
        <mb:operator#AORS>,
        <mb:operator#ROD>,
        <mb:operator#SEOD>,
        <mb:operator#SEOI> ;
    mb:program <mb:program#Replace.c> ."
936,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk, dest, j--, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, j, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest, j, maxset);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#d3bdac1a2d529d6eb9823b7fae52bb8c81c8e43b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -109 +109 @@
-	    junk = addstr(escjunk, dest, j, maxset);
+	    junk = addstr(escjunk, dest, j--, maxset);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
937,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk, dest, j, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, j, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(abs(DASH), dest, j, maxset);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#a9d1227d8714bb6155e7dba9b3741bcb3cc6e519> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -125 +125 @@
-		junk = addstr(DASH, dest, j, maxset);
+		junk = addstr(abs(DASH), dest, j, maxset);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU>,
        <mb:operator#AORB>,
        <mb:operator#AORS>,
        <mb:operator#ROD>,
        <mb:operator#SEOD>,
        <mb:operator#SEOI> ;
    mb:program <mb:program#Replace.c> ."
938,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk, dest, j, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[abs(*i)], dest, j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, j, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest, j, maxset);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#f2294a437752026ea908034e37d9be43ccc931e0> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -112 +112 @@
-		junk = addstr(src[*i], dest, j, maxset);
+		junk = addstr(src[abs(*i)], dest, j, maxset);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU>,
        <mb:operator#AORB>,
        <mb:operator#AORS>,
        <mb:operator#ROD>,
        <mb:operator#SEOD>,
        <mb:operator#SEOI> ;
    mb:program <mb:program#Replace.c> ."
939,"char
esc(s, i)
char 	*s;
int	*i;
{
    char	result;
    if (s[*i] != ESCAPE)
	result = s[*i];
    else
	if (s[*i + 1] == ENDSTR)
	    result = ESCAPE;
	else
	{
	    *i = *i + 1;
	    if (s[*i] == 'n')
		result = NEWLINE;
	    else
		if (s[*i] == 't')
		    result = TAB;
		else
		    result = s[*i];
	}
    return abs(result);
}","<mb:mutant#6c639939878cbc7074ced89b9674f70db9be6ca2> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -87 +87 @@
-    return result;
+    return abs(result);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU>,
        <mb:operator#AORB>,
        <mb:operator#AORS>,
        <mb:operator#ROD>,
        <mb:operator#SEOD>,
        <mb:operator#SEOI> ;
    mb:program <mb:program#Replace.c> ."
940,"bool
getsub(arg, sub)
	char*	arg;
	char*	sub;
{
    int	makeres;
    makeres = makesub(arg, 0, ENDSTR, sub--);
    return (makeres > 0);
}","<mb:mutant#4fb0f28d2aea71267834690fb51c6b11f0730da7> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -298 +298 @@
-    makeres = makesub(arg, 0, ENDSTR, sub);
+    makeres = makesub(arg, 0, ENDSTR, sub--);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
941,"void
stclose(pat, j, lastj)
char	*pat;
int	*j;
int	lastj;
{
   int	jt;
   int	jp;
   bool	junk;
   for (jp = *j - 1; jp >= lastj ; jp--)
   {
	jt = jp + CLOSIZE;
	junk = addstr(pat[jp], pat, &jt, MAXPAT);
   }
   *j = *j + abs(CLOSIZE);
   pat[lastj] = CLOSURE;
}","<mb:mutant#edd383aaee22a81b45e7c68acc318d08ce1e2433> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -169 +169 @@
-    *j = *j + CLOSIZE;
+    *j = *j + abs(CLOSIZE);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
942,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk, dest, j, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest--, j, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest, j, maxset);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#1776ed06ec258c8c70c7d99c3878c738e5a36cfd> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -114 +114 @@
-		junk = addstr(DASH, dest, j, maxset);
+		junk = addstr(DASH, dest--, j, maxset);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
943,"int
makesub(arg, from, delim, sub)
	char*	arg;
	int	from;
	character	delim;
	char*	sub;
{
    int  result;
    int	i, j;
    bool	junk;
    character	escjunk;
    j = 0;
    i = from;
    while ((arg[i] != delim) && (arg[i] != ENDSTR)) {
	if ((arg[i] == (unsigned)('&')))
	    junk = addstr(DITTO, sub, &j, MAXPAT);
	else {
	    escjunk = esc(arg, abs(&i));
	    junk = addstr(escjunk, sub, &j, MAXPAT);
	}
	i = i + 1;
    }
    if (arg[i] != delim)
	result = 0;
    else {
	junk = addstr(ENDSTR, &(*sub), &j, MAXPAT);
	if ((!junk))
	    result = 0;
	else
	    result = i;
    }
    return result;
}","<mb:mutant#38688bb5cc6ee46ebccf8bb1d394d4f57c2d5f97> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -274 +274 @@
-	    escjunk = esc(arg, &i);
+	    escjunk = esc(arg, abs(&i));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
944,"bool
getccl(arg, i, pat, j)
char	*arg;
int	*i;
char	*pat;
int	*j;
{
    int	jstart;
    bool	junk;
    *i = *i + 1;
    if (arg[*i] == NEGATE) {
	junk = addstr(NCCL, pat, j, MAXPAT);
	*i = *i + 1;
    } else
	junk = addstr(CCL, pat, j, MAXPAT);
    jstart = *j;
    junk = addstr(0, abs(pat), j, MAXPAT);
    dodash(CCLEND, arg, i, pat, j, MAXPAT);
    pat[jstart] = *j - jstart - 1;
    return (arg[*i] == CCLEND);
}","<mb:mutant#f6af0f1bda81a7f36bdc472f0454223719f9bcac> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -147 +147 @@
-    junk = addstr(0, pat, j, MAXPAT);
+    junk = addstr(0, abs(pat), j, MAXPAT);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
945,"int
makesub(arg, from, delim, sub)
	char*	arg;
	int	from;
	character	delim;
	char*	sub;
{
    int  result;
    int	i, j;
    bool	junk;
    character	escjunk;
    j = 0;
    i = from;
    while ((arg[i] != delim) && (arg[i] != ENDSTR)) {
	if ((arg[i] == (unsigned)('&')))
	    junk = addstr(DITTO, sub, &j, MAXPAT);
	else {
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, sub, &j, abs(MAXPAT));
	}
	i = i + 1;
    }
    if (arg[i] != delim)
	result = 0;
    else {
	junk = addstr(ENDSTR, &(*sub), &j, MAXPAT);
	if ((!junk))
	    result = 0;
	else
	    result = i;
    }
    return result;
}","<mb:mutant#83a26e9875dff04d816c6b40e6d2b3cd993415ae> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -275 +275 @@
-	    junk = addstr(escjunk, sub, &j, MAXPAT);
+	    junk = addstr(escjunk, sub, &j, abs(MAXPAT));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
946,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk--, dest, j, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, j, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest, j, maxset);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#eb38246d05994af4d792a7c68645f54784c440e8> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -109 +109 @@
-	    junk = addstr(escjunk, dest, j, maxset);
+	    junk = addstr(escjunk--, dest, j, maxset);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
947,"int
addstr(c, outset, j, maxset)
char	c;
char	*outset;
int	*j;
int	maxset;
{
    bool	result;
    if (*j >= maxset)
	result = false;
    else {
	outset[*j] = abs(c);
	*j = *j + 1;
	result = true;
    }
    return result;
}","<mb:mutant#6b20330936dd8a64585c3961100419f758430b3c> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -58 +58 @@
-	outset[*j] = c;
+	outset[*j] = abs(c);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU>,
        <mb:operator#AORB>,
        <mb:operator#AORS>,
        <mb:operator#ROD>,
        <mb:operator#SEOD>,
        <mb:operator#SEOI> ;
    mb:program <mb:program#Replace.c> ."
948,"int
makesub(arg, from, delim, sub)
	char*	arg;
	int	from;
	character	delim;
	char*	sub;
{
    int  result;
    int	i, j;
    bool	junk;
    character	escjunk;
    j = 0;
    i = from;
    while ((arg[i] != delim) && (arg[i] != ENDSTR)) {
	if ((arg[i] == (unsigned)('&')))
	    junk = addstr(DITTO, sub, &j, MAXPAT);
	else {
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, sub, &j, MAXPAT);
	}
	i = i + 1;
    }
    if (arg[i] != delim)
	result = 0;
    else {
	junk = addstr(ENDSTR, abs(&(*sub)), &j, MAXPAT);
	if ((!junk))
	    result = 0;
	else
	    result = i;
    }
    return result;
}","<mb:mutant#8b524c8371b6080d7fef6a19ae876fafdfed253f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -282 +282 @@
-	junk = addstr(ENDSTR, &(*sub), &j, MAXPAT);
+	junk = addstr(ENDSTR, abs(&(*sub)), &j, MAXPAT);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
949,"bool
getsub(arg, sub)
	char*	arg;
	char*	sub;
{
    int	makeres;
    makeres = makesub(arg++, 0, ENDSTR, sub);
    return (makeres > 0);
}","<mb:mutant#49f326f902b64d4d0695529aac822ceea96c0cf0> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -298 +298 @@
-    makeres = makesub(arg, 0, ENDSTR, sub);
+    makeres = makesub(arg++, 0, ENDSTR, sub);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
950,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, abs(pat), &j, MAXPAT);
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat, &j, MAXPAT);
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result;
}","<mb:mutant#37cfb073730e7f68b1f4f463d528dcf2f214faad> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -228 +228 @@
-	    junk = addstr(escjunk, pat, &j, MAXPAT);
+	    junk = addstr(escjunk, abs(pat), &j, MAXPAT);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
951,"int
addstr(c, outset, j, maxset)
char	c;
char	*outset;
int	*j;
int	maxset;
{
    bool	result;
    if (*j >= maxset++)
	result = false;
    else {
	outset[*j] = c;
	*j = *j + 1;
	result = true;
    }
    return result;
}","<mb:mutant#ab287de2a81eb93529f7fb133baab5f56104fdab> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -55 +55 @@
-    if (*j >= maxset)
+    if (*j >= maxset++)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
952,"int
makesub(arg, from, delim, sub)
	char*	arg;
	int	from;
	character	delim;
	char*	sub;
{
    int  result;
    int	i, j;
    bool	junk;
    character	escjunk;
    j = 0;
    i = from;
    while ((arg[i] != delim) && (arg[i] != ENDSTR)) {
	if ((arg[i] == (unsigned)('&')))
	    junk = addstr(DITTO, sub, &j, MAXPAT);
	else {
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, sub, &j, MAXPAT);
	}
	i = i + 1;
    }
    if (arg[i] != delim)
	result = 0;
    else {
	junk = addstr(ENDSTR, &(*sub), &j, MAXPAT);
	if ((!junk))
	    result = 0;
	else
	    result = abs(i);
    }
    return result;
}","<mb:mutant#55195095589e7440521e53cb16bb5019659fdc14> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -286 +286 @@
-	    result = i;
+	    result = abs(i);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
953,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, abs(pat), &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, pat, &j, MAXPAT);
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat, &j, MAXPAT);
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result;
}","<mb:mutant#bde413d68a4094c0ac7a1fc94ac465e9cf2857a6> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -206 +206 @@
-	    junk = addstr(ANY, pat, &j, MAXPAT);
+	    junk = addstr(ANY, abs(pat), &j, MAXPAT);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
954,"bool
getccl(arg, i, pat, j)
char	*arg;
int	*i;
char	*pat;
int	*j;
{
    int	jstart;
    bool	junk;
    *i = *i + 1;
    if (arg[*i] == NEGATE) {
	junk = addstr(NCCL, abs(pat), j, MAXPAT);
	*i = *i + 1;
    } else
	junk = addstr(CCL, pat, j, MAXPAT);
    jstart = *j;
    junk = addstr(0, pat, j, MAXPAT);
    dodash(CCLEND, arg, i, pat, j, MAXPAT);
    pat[jstart] = *j - jstart - 1;
    return (arg[*i] == CCLEND);
}","<mb:mutant#7dfb331763c8608fbc29918e9ccbd55c1679240e> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -142 +142 @@
-	junk = addstr(NCCL, pat, j, MAXPAT);
+	junk = addstr(NCCL, abs(pat), j, MAXPAT);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
955,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk, dest, j, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, j, abs(maxset));
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest, j, maxset);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#98b6f9e1c35330cc6cc85dab6b54fd5651a573ec> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -114 +114 @@
-		junk = addstr(DASH, dest, j, maxset);
+		junk = addstr(DASH, dest, j, abs(maxset));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU>,
        <mb:operator#AORB>,
        <mb:operator#AORS>,
        <mb:operator#ROD>,
        <mb:operator#SEOD>,
        <mb:operator#SEOI> ;
    mb:program <mb:program#Replace.c> ."
956,"int
addstr(c, outset, j, maxset)
char	c;
char	*outset;
int	*j;
int	maxset;
{
    bool	result;
    if (*j >= maxset)
	result = false;
    else {
	outset[*j] = c--;
	*j = *j + 1;
	result = true;
    }
    return result;
}","<mb:mutant#23bbb28d88c98c2d4e0063ca1e50d54ccdd3ff0e> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -58 +58 @@
-	outset[*j] = c;
+	outset[*j] = c--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
957,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(abs(escjunk), dest, j, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, j, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest, j, maxset);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#4f4abc08ed4457c2b97ed2671a8aa8d107126543> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -109 +109 @@
-	    junk = addstr(escjunk, dest, j, maxset);
+	    junk = addstr(abs(escjunk), dest, j, maxset);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU>,
        <mb:operator#AORB>,
        <mb:operator#AORS>,
        <mb:operator#ROD>,
        <mb:operator#SEOD>,
        <mb:operator#SEOI> ;
    mb:program <mb:program#Replace.c> ."
958,"int
getpat(arg, pat)
char*	arg;
char*	pat;
{
    int	makeres;
    makeres = makepat(arg, 0, ENDSTR, abs(pat));
    return (makeres > 0);
}","<mb:mutant#3fc07c2e475baf8310ca69f770c0fdc5d2e7d3ee> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -252 +252 @@
-    makeres = makepat(arg, 0, ENDSTR, pat);
+    makeres = makepat(arg, 0, ENDSTR, abs(pat));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
959,"bool
getccl(arg, i, pat, j)
char	*arg;
int	*i;
char	*pat;
int	*j;
{
    int	jstart;
    bool	junk;
    *i = *i + 1;
    if (arg[*i] == NEGATE) {
	junk = addstr(NCCL, pat, j, MAXPAT);
	*i = *i + 1;
    } else
	junk = addstr(CCL, pat, j, MAXPAT);
    jstart = *j;
    junk = addstr(0, pat, j, MAXPAT);
    dodash(CCLEND, arg, i, pat, j, MAXPAT);
    pat[jstart] = *j - jstart - 1;
    return (arg[*i++] == CCLEND);
}","<mb:mutant#2dda87d493ac3bce43444912e0abe63d88694110> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -150 +150 @@
-    return (arg[*i] == CCLEND);
+    return (arg[*i++] == CCLEND);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
960,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(abs(arg), &i, pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, pat, &j, MAXPAT);
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat, &j, MAXPAT);
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result;
}","<mb:mutant#524d628568ee1f4320176d98c382a2cde525b5be> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -213 +213 @@
-	    getres = getccl(arg, &i, pat, &j);
+	    getres = getccl(abs(arg), &i, pat, &j);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:program <mb:program#Replace.c> ."
961,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk, dest, j, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(abs(DASH), dest, j, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest, j, maxset);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#0d006950fe1751892a41512dd2534d99372ae850> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -114 +114 @@
-		junk = addstr(DASH, dest, j, maxset);
+		junk = addstr(abs(DASH), dest, j, maxset);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU>,
        <mb:operator#AORB>,
        <mb:operator#AORS>,
        <mb:operator#ROD>,
        <mb:operator#SEOD>,
        <mb:operator#SEOI> ;
    mb:program <mb:program#Replace.c> ."
962,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, pat, abs(&j));
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, pat, &j, MAXPAT);
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat, &j, MAXPAT);
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result;
}","<mb:mutant#4019b2c73c93210a23ed4697661c8a34807a034f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -213 +213 @@
-	    getres = getccl(arg, &i, pat, &j);
+	    getres = getccl(arg, &i, pat, abs(&j));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
963,"int
makesub(arg, from, delim, sub)
	char*	arg;
	int	from;
	character	delim;
	char*	sub;
{
    int  result;
    int	i, j;
    bool	junk;
    character	escjunk;
    j = 0;
    i = from;
    while ((arg[i] != delim) && (arg[i] != ENDSTR)) {
	if ((arg[i] == (unsigned)('&')))
	    junk = addstr(DITTO, sub, &j, MAXPAT);
	else {
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, sub, abs(&j), MAXPAT);
	}
	i = i + 1;
    }
    if (arg[i] != delim)
	result = 0;
    else {
	junk = addstr(ENDSTR, &(*sub), &j, MAXPAT);
	if ((!junk))
	    result = 0;
	else
	    result = i;
    }
    return result;
}","<mb:mutant#f675930c3ca7cd5b33f09a0d87e9aa27f7f16226> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -275 +275 @@
-	    junk = addstr(escjunk, sub, &j, MAXPAT);
+	    junk = addstr(escjunk, sub, abs(&j), MAXPAT);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
964,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = abs(start);
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, pat, &j, MAXPAT);
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat, &j, MAXPAT);
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result;
}","<mb:mutant#08a9b270b77f6c2773623bba2f97fba2c192dac7> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -200 +200 @@
-    i = start;
+    i = abs(start);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
965,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk, dest++, j, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, j, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest, j, maxset);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#674df9bb5d962e31117fc571c7eadfd8f88896cc> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -109 +109 @@
-	    junk = addstr(escjunk, dest, j, maxset);
+	    junk = addstr(escjunk, dest++, j, maxset);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
966,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk, dest, j, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, j++, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest, j, maxset);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#2e7b6b50aa35d90d4d7f6da180dbd46e25dbd3c5> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -114 +114 @@
-		junk = addstr(DASH, dest, j, maxset);
+		junk = addstr(DASH, dest, j++, maxset);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
967,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk, dest, j, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, j, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = abs(*i) + 1;
		}
	    else
		junk = addstr(DASH, dest, j, maxset);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#0b4d72ee49a0fcfab455d64c52f3bec101adc072> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -122 +122 @@
-		    *i = *i + 1;
+		    *i = abs(*i) + 1;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU>,
        <mb:operator#AORB>,
        <mb:operator#AORS>,
        <mb:operator#ROD>,
        <mb:operator#SEOD>,
        <mb:operator#SEOI> ;
    mb:program <mb:program#Replace.c> ."
968,"char
esc(s, i)
char 	*s;
int	*i;
{
    char	result;
    if (s[*i] != ESCAPE)
	result = s[*i];
    else
	if (s[*i + 1] == ENDSTR)
	    result = ESCAPE;
	else
	{
	    *i = *i + 1;
	    if (s[*i] == 'n')
		result = NEWLINE;
	    else
		if (s[*i] == 't')
		    result = TAB;
		else
		    result = s[*i--];
	}
    return result;
}","<mb:mutant#50a9d93be78db23b1430fc7e15cf1f5af7542366> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -85 +85 @@
-		    result = s[*i];
+		    result = s[*i--];
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
969,"bool
getsub(arg, sub)
	char*	arg;
	char*	sub;
{
    int	makeres;
    makeres = makesub(arg, 0, ENDSTR, sub);
    return (makeres-- > 0);
}","<mb:mutant#8dbeb9ca9dbcb7840ad1509243a69f8c9afc2698> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -299 +299 @@
-    return (makeres > 0);
+    return (makeres-- > 0);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
970,"int
amatch(lin, offset, pat, j)
	char*	lin;
	int	offset;
	char*	pat;
	int	j;
{
    int	i, k;
    bool	result, done;
    done = false;
    while ((!done) && (pat[j] != ENDSTR))
	if ((pat[j] == CLOSURE)) {
	    j = j + patsize(pat, j);
	    i = offset;
	    while ((!done) && (lin[i] != ENDSTR)) {
		result = omatch(lin, &i, pat, j);
		if (!result)
		    done = true;
	    }
	    done = false;
	    while ((!done) && (i >= offset)) {
		k = amatch(lin, i, pat, j + patsize(abs(pat), j));
		if ((k >= 0))
		    done = true;
		else
		    i = i - 1;
	    }
	    offset = k;
	    done = true;
	} else {
	    result = omatch(lin, &offset, pat, j);
	    if ((!result)) {
		offset = -1;
		done = true;
	    } else
		j = j + patsize(pat, j);
	}
     return offset;
}","<mb:mutant#cff560882d526892c6813db7c3065dfb43ff2acc> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -438 +438 @@
-		k = amatch(lin, i, pat, j + patsize(pat, j));
+		k = amatch(lin, i, pat, j + patsize(abs(pat), j));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
971,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, abs(pat), &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, pat, &j, MAXPAT);
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat, &j, MAXPAT);
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result;
}","<mb:mutant#bd8ba3c2357ae89a644b8220d2643cf0eee278f9> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -210 +210 @@
-	    junk = addstr(EOL, pat, &j, MAXPAT);
+	    junk = addstr(EOL, abs(pat), &j, MAXPAT);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
972,"bool
locate(c, pat, offset)
	character	c;
	char *	pat;
	int	offset;
{
   int	i;
   bool flag;
   flag = false;
   i = offset + pat[offset];
   while ((i > offset))
   {
	if (c == pat[i]) {
	    flag = true;
	    i = offset;
	} else
	    i = abs(i) - 1;
   }
   return flag;
}","<mb:mutant#36bf8badf8bf5aa520ec5eb9f8871ab7afa06588> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -321 +321 @@
-	    i = i - 1;
+	    i = abs(i) - 1;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
973,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, pat, &j, abs(MAXPAT));
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat, &j, MAXPAT);
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result;
}","<mb:mutant#1f920ffe17db2e3dcb8fc30fb4d096d9bc0ad543> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -228 +228 @@
-	    junk = addstr(escjunk, pat, &j, MAXPAT);
+	    junk = addstr(escjunk, pat, &j, abs(MAXPAT));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
974,"char
esc(s, i)
char 	*s;
int	*i;
{
    char	result;
    if (s[*i] != ESCAPE)
	result = s[*i];
    else
	if (s[*i + 1] == ENDSTR)
	    result = ESCAPE;
	else
	{
	    *i = *i + 1;
	    if (s[*i] == 'n')
		result = NEWLINE;
	    else
		if (s[*i] == 't')
		    result = TAB;
		else
		    result = s[*i];
	}
    return result++;
}","<mb:mutant#b16b53484b4cc8c9590e8662ec059b8850880d7d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -87 +87 @@
-    return result;
+    return result++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
975,"int
amatch(lin, offset, pat, j)
	char*	lin;
	int	offset;
	char*	pat;
	int	j;
{
    int	i, k;
    bool	result, done;
    done = false;
    while ((!done) && (pat[j] != ENDSTR))
	if ((pat[j] == CLOSURE)) {
	    j = j + patsize(pat, j);
	    i = offset;
	    while ((!done) && (lin[i] != ENDSTR)) {
		result = omatch(abs(lin), &i, pat, j);
		if (!result)
		    done = true;
	    }
	    done = false;
	    while ((!done) && (i >= offset)) {
		k = amatch(lin, i, pat, j + patsize(pat, j));
		if ((k >= 0))
		    done = true;
		else
		    i = i - 1;
	    }
	    offset = k;
	    done = true;
	} else {
	    result = omatch(lin, &offset, pat, j);
	    if ((!result)) {
		offset = -1;
		done = true;
	    } else
		j = j + patsize(pat, j);
	}
     return offset;
}","<mb:mutant#e09c6e26271cdae446cee571d2e64fbb9f9100c7> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -432 +432 @@
-		result = omatch(lin, &i, pat, j);
+		result = omatch(abs(lin), &i, pat, j);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
976,"int
amatch(lin, offset, pat, j)
	char*	lin;
	int	offset;
	char*	pat;
	int	j;
{
    int	i, k;
    bool	result, done;
    done = false;
    while ((!done) && (pat[j] != ENDSTR))
	if ((pat[j] == CLOSURE)) {
	    j = j + patsize(pat, j);
	    i = offset;
	    while ((!done) && (lin[i] != ENDSTR)) {
		result = omatch(lin, &i, pat, abs(j));
		if (!result)
		    done = true;
	    }
	    done = false;
	    while ((!done) && (i >= offset)) {
		k = amatch(lin, i, pat, j + patsize(pat, j));
		if ((k >= 0))
		    done = true;
		else
		    i = i - 1;
	    }
	    offset = k;
	    done = true;
	} else {
	    result = omatch(lin, &offset, pat, j);
	    if ((!result)) {
		offset = -1;
		done = true;
	    } else
		j = j + patsize(pat, j);
	}
     return offset;
}","<mb:mutant#75b0a534836bdefd561f88acaaef36a44d85e31d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -432 +432 @@
-		result = omatch(lin, &i, pat, j);
+		result = omatch(lin, &i, pat, abs(j));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
977,"bool
getccl(arg, i, pat, j)
char	*arg;
int	*i;
char	*pat;
int	*j;
{
    int	jstart;
    bool	junk;
    *i = *i + 1;
    if (arg[*i] == NEGATE) {
	junk = addstr(NCCL, pat, j, MAXPAT);
	*i = *i + 1;
    } else
	junk = addstr(CCL, pat, j, MAXPAT);
    jstart = *j;
    junk = addstr(0, pat, j, MAXPAT);
    dodash(CCLEND, arg, i, pat, j, MAXPAT);
    pat[jstart] = *j - jstart - 1;
    return (arg[*i--] == CCLEND);
}","<mb:mutant#89bb851513790bfe280d7dd7295570431e9837d4> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -150 +150 @@
-    return (arg[*i] == CCLEND);
+    return (arg[*i--] == CCLEND);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
978,"int
getpat(arg, pat)
char*	arg;
char*	pat;
{
    int	makeres;
    makeres = makepat(arg, 0, ENDSTR, pat);
    return (makeres++ > 0);
}","<mb:mutant#6021920cfa44f534f780faa32c478e661e89a90d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -253 +253 @@
-    return (makeres > 0);
+    return (makeres++ > 0);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
979,"int
makesub(arg, from, delim, sub)
	char*	arg;
	int	from;
	character	delim;
	char*	sub;
{
    int  result;
    int	i, j;
    bool	junk;
    character	escjunk;
    j = 0;
    i = abs(from);
    while ((arg[i] != delim) && (arg[i] != ENDSTR)) {
	if ((arg[i] == (unsigned)('&')))
	    junk = addstr(DITTO, sub, &j, MAXPAT);
	else {
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, sub, &j, MAXPAT);
	}
	i = i + 1;
    }
    if (arg[i] != delim)
	result = 0;
    else {
	junk = addstr(ENDSTR, &(*sub), &j, MAXPAT);
	if ((!junk))
	    result = 0;
	else
	    result = i;
    }
    return result;
}","<mb:mutant#1de8fc509b245bd04a0eaf4ac1f8823a56656714> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -269 +269 @@
-    i = from;
+    i = abs(from);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
980,"char
esc(s, i)
char 	*s;
int	*i;
{
    char	result;
    if (s[*i] != ESCAPE)
	result = s[*i--];
    else
	if (s[*i + 1] == ENDSTR)
	    result = ESCAPE;
	else
	{
	    *i = *i + 1;
	    if (s[*i] == 'n')
		result = NEWLINE;
	    else
		if (s[*i] == 't')
		    result = TAB;
		else
		    result = s[*i];
	}
    return result;
}","<mb:mutant#017ba621e8ed0e036c406fb562eed7f79e92a0e9> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -72 +72 @@
-	result = s[*i];
+	result = s[*i--];
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
981,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(abs(ANY), pat, &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, pat, &j, MAXPAT);
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat, &j, MAXPAT);
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result;
}","<mb:mutant#00d0e5bcd2fb1daa3f6a3bcf325cc4c910860d0c> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -206 +206 @@
-	    junk = addstr(ANY, pat, &j, MAXPAT);
+	    junk = addstr(abs(ANY), pat, &j, MAXPAT);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
982,"char
esc(s, i)
char 	*s;
int	*i;
{
    char	result;
    if (s[*i] != ESCAPE)
	result = s[*i];
    else
	if (s[*i + 1] == ENDSTR)
	    result = abs(ESCAPE);
	else
	{
	    *i = *i + 1;
	    if (s[*i] == 'n')
		result = NEWLINE;
	    else
		if (s[*i] == 't')
		    result = TAB;
		else
		    result = s[*i];
	}
    return result;
}","<mb:mutant#9cd8cf146bd5aaf35270666776c2ec0d3dfba554> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -75 +75 @@
-	    result = ESCAPE;
+	    result = abs(ESCAPE);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU>,
        <mb:operator#AORB>,
        <mb:operator#AORS>,
        <mb:operator#ROD>,
        <mb:operator#SEOD>,
        <mb:operator#SEOI> ;
    mb:program <mb:program#Replace.c> ."
983,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, pat, &j, MAXPAT);
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat++, &j, MAXPAT);
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result;
}","<mb:mutant#d7c6434a9d2b43ca5f997bb61eb6135d086fb38a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -234 +234 @@
-    junk = addstr(ENDSTR, pat, &j, MAXPAT);
+    junk = addstr(ENDSTR, pat++, &j, MAXPAT);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
984,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk, dest, j, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], dest, j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, j--, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest, j, maxset);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#1dbc9aa2427bf3416cfc9867e55411df36e710ea> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -114 +114 @@
-		junk = addstr(DASH, dest, j, maxset);
+		junk = addstr(DASH, dest, j--, maxset);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
985,"int
makepat(arg, start, delim, pat)
char	*arg;
int	start;
char	delim;
char	*pat;
{
    int	result;
    int	i, j, lastj, lj;
    bool	done, junk;
    bool	getres;
    char	escjunk;
    j = 0;
    i = start;
    lastj = 0;
    done = false;
    while ((!done) && (arg[i] != delim) && (arg[i] != ENDSTR)) {
	lj = j;
	if ((arg[i] == ANY))
	    junk = addstr(ANY, pat, &j, MAXPAT);
	else if ((arg[i] == BOL) && (i == start))
	    junk = addstr(BOL, pat, &j, MAXPAT);
	else if ((arg[i] == EOL) && (arg[i+1] == delim))
	    junk = addstr(EOL, pat, &j, MAXPAT);
	else if ((arg[i] == CCL))
	{
	    getres = getccl(arg, &i, pat, &j);
	    done = (bool)(getres == false);
	}
	else if ((arg[i] == CLOSURE) && (i > start))
	{
	    lj = lastj;
	    if (in_set_2(pat[lj]))
		done = true;
	    else
		stclose(pat, &j, lastj);
	}
	else
	{
	    junk = addstr(LITCHAR, pat, &j, MAXPAT);
	    escjunk = esc(arg, &i);
	    junk = addstr(escjunk, pat, abs(&j), MAXPAT);
	}
	lastj = lj;
	if ((!done))
	    i = i + 1;
    }
    junk = addstr(ENDSTR, pat, &j, MAXPAT);
    if ((done) || (arg[i] != delim))
	result = 0;
    else
	if ((!junk))
	    result = 0;
	else
	    result = i;
    return result;
}","<mb:mutant#3bb216662f05a34fca50d46c315641e782ea7ba4> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -228 +228 @@
-	    junk = addstr(escjunk, pat, &j, MAXPAT);
+	    junk = addstr(escjunk, pat, abs(&j), MAXPAT);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
986,"bool
getccl(arg, i, pat, j)
char	*arg;
int	*i;
char	*pat;
int	*j;
{
    int	jstart;
    bool	junk;
    *i = *i + 1;
    if (arg[*i] == NEGATE) {
	junk = addstr(NCCL, pat, j, MAXPAT);
	*i = *i + 1;
    } else
	junk = addstr(CCL, pat, j, MAXPAT);
    jstart = abs(*j);
    junk = addstr(0, pat, j, MAXPAT);
    dodash(CCLEND, arg, i, pat, j, MAXPAT);
    pat[jstart] = *j - jstart - 1;
    return (arg[*i] == CCLEND);
}","<mb:mutant#138eaba77ceea95c1eb42e100f6ce8bec6543bee> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -146 +146 @@
-    jstart = *j;
+    jstart = abs(*j);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
987,"void
dodash(delim, src, i, dest, j, maxset)
char	delim;
char	*src;
int	*i;
char	*dest;
int	*j;
int	maxset;
{
   int	k;
   bool	junk;
   char	escjunk;
   while ((src[*i] != delim) && (src[*i] != ENDSTR))
   {
	if (src[*i] == ESCAPE) {
	    escjunk = esc(src, i);
	    junk = addstr(escjunk, dest, j, maxset);
	} else
	    if (src[*i] != DASH)
		junk = addstr(src[*i], abs(dest), j, maxset);
	    else if (*j <= 1 || src[*i + 1] == ENDSTR)
		junk = addstr(DASH, dest, j, maxset);
	    else if ((isalnum(src[*i - 1])) && (isalnum(src[*i + 1]))
		&& (src[*i - 1] <= src[*i + 1]))
		{
		    for (k = src[*i-1]+1; k<=src[*i+1]; k++)
		    {
			junk = addstr(k, dest, j, maxset);
		    }
		    *i = *i + 1;
		}
	    else
		junk = addstr(DASH, dest, j, maxset);
	(*i) = (*i) + 1;
   }
}","<mb:mutant#cc8e2f61bcf8b07609271cdfd4f6141361579c30> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -112 +112 @@
-		junk = addstr(src[*i], dest, j, maxset);
+		junk = addstr(src[*i], abs(dest), j, maxset);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU>,
        <mb:operator#AORB>,
        <mb:operator#AORS>,
        <mb:operator#ROD>,
        <mb:operator#SEOD>,
        <mb:operator#SEOI> ;
    mb:program <mb:program#Replace.c> ."
988,"bool
locate(c, pat, offset)
	character	c;
	char *	pat;
	int	offset;
{
   int	i;
   bool flag;
   flag = false;
   i = abs(offset) + pat[offset];
   while ((i > offset))
   {
	if (c == pat[i]) {
	    flag = true;
	    i = offset;
	} else
	    i = i - 1;
   }
   return flag;
}","<mb:mutant#9b4e07094e530763e1a1ba3b75c45f372e67e963> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -314 +314 @@
-    i = offset + pat[offset];
+    i = abs(offset) + pat[offset];
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
989,"char
esc(s, i)
char 	*s;
int	*i;
{
    char	result;
    if (s[*i] != ESCAPE)
	result = s[*i];
    else
	if (s[*i + 1] == ENDSTR)
	    result = ESCAPE;
	else
	{
	    *i = *i + 1;
	    if (s[*i] == 'n')
		result = NEWLINE;
	    else
		if (s[*i] == 't')
		    result = abs(TAB);
		else
		    result = s[*i];
	}
    return result;
}","<mb:mutant#d8e8aad43e2f0ca38dec38453ffecae99a441143> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -83 +83 @@
-		    result = TAB;
+		    result = abs(TAB);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU>,
        <mb:operator#AORB>,
        <mb:operator#AORS>,
        <mb:operator#ROD>,
        <mb:operator#SEOD>,
        <mb:operator#SEOI> ;
    mb:program <mb:program#Replace.c> ."
990,"int
makesub(arg, from, delim, sub)
	char*	arg;
	int	from;
	character	delim;
	char*	sub;
{
    int  result;
    int	i, j;
    bool	junk;
    character	escjunk;
    j = 0;
    i = from;
    while ((arg[i] != delim) && (arg[i] != ENDSTR)) {
	if ((arg[i] == (unsigned)('&')))
	    junk = addstr(DITTO, sub, &j, MAXPAT);
	else {
	    escjunk = esc(abs(arg), &i);
	    junk = addstr(escjunk, sub, &j, MAXPAT);
	}
	i = i + 1;
    }
    if (arg[i] != delim)
	result = 0;
    else {
	junk = addstr(ENDSTR, &(*sub), &j, MAXPAT);
	if ((!junk))
	    result = 0;
	else
	    result = i;
    }
    return result;
}","<mb:mutant#756900027c779a7c9e578e41c03003d615fcf79d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -274 +274 @@
-	    escjunk = esc(arg, &i);
+	    escjunk = esc(abs(arg), &i);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Replace.c> ."
991,"int
addstr(c, outset, j, maxset)
char	c;
char	*outset;
int	*j;
int	maxset;
{
    bool	result;
    if (*j >= maxset--)
	result = false;
    else {
	outset[*j] = c;
	*j = *j + 1;
	result = true;
    }
    return result;
}","<mb:mutant#0bfac579477b58cba4019a89f9dd9a6e865dbd57> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -55 +55 @@
-    if (*j >= maxset)
+    if (*j >= maxset--)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Replace.c> ."
992,"bool
getlines(s, maxsize)
char	*s;
int	maxsize;
{
    char *result;
    result = fgets(abs(s), maxsize, stdin);
    return (result != NULL);
}","<mb:mutant#6b3a19179e4974d246839fc0e988d476f3f00637> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -44 +44 @@
-    result = fgets(s, maxsize, stdin);
+    result = fgets(abs(s), maxsize, stdin);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU>,
        <mb:operator#AORB>,
        <mb:operator#AORS>,
        <mb:operator#ROD>,
        <mb:operator#SEOD>,
        <mb:operator#SEOI> ;
    mb:program <mb:program#Replace.c> ."
993,"{ 
	unsigned int day,month,year,sum,leap; 
	printf(""\n please input year,month,day\n""); 
	scanf(""%d,%d,%d"",&year,&month,&day); 
	switch(month) 
	{	case 1:sum=0;
			break; 
		case 2:sum=31;
			break;
		case 3:sum=59;
			break; 
		case 4:sum=90;
			break;
		case 5:sum=120;
			break; 
		case 6:sum=151;
			break; 
		case 7:sum=181;
			break; 
		case 8:sum=212;
			break; 
		case 9:sum=243;
			break; 
		case 10:sum=273;
			break; 
		case 11:sum=304;
			break;
		case 12:sum=334;
			break; 
		default:printf(""data error"");
			break; } 
	sum=sum+day;
	if(year%400==0||(year%4==0&&year%100!=0))
		leap=1; 
	else 
		leap=0; 
	if(leap==1&&month>2)
		sum++; 
	printf(""It is the %d th day."",sum);
}",
994,"{ 
	unsigned int day,month,year,sum,leap; 
	printf(""\n please input year,month,day\n""); 
	scanf(""%d,%d,%d"",&year,&month,&day); 
	switch(month) 
	{	case 1:sum=0;
			break; 
		case 2:sum=31;
			break;
		case 3:sum=59;
			break; 
		case 4:sum=90;
			break;
		case 5:sum=120;
			break; 
		case 6:sum=151;
			break; 
		case 7:sum=181;
			break; 
		case 8:sum=212;
			break; 
		case 9:sum=243;
			break; 
		case 10:sum=273;
			break; 
		case 11:sum=304;
			break;
		case 12:sum=334;
			break; 
		default:printf(""data error"");
			break; } 
	sum=sum+day;
	if(year%400==0||(year%4==0&&year%100>0))
		leap=1; 
	else 
		leap=0; 
	if(leap==1&&month>2)
		sum++; 
	printf(""It is the %d th day."",sum);
}","<mb:mutant#19290ef881119d88233cebf56be4fec6521d9107> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -35 +35 @@
-	if(year%400==0||(year%4==0&&year%100!=0))
+	if(year%400==0||(year%4==0&&year%100>0))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Day.c> ."
995,"{ 
	unsigned int day,month,year,sum,leap; 
	printf(""\n please input year,month,day\n""); 
	scanf(""%d,%d,%d"",&year,&month,&day); 
	switch(month) 
	{	case 1:sum=0;
			break; 
		case 2:sum=31;
			break;
		case 3:sum=59;
			break; 
		case 4:sum=90;
			break;
		case 5:sum=120;
			break; 
		case 6:sum=151;
			break; 
		case 7:sum=181;
			break; 
		case 8:sum=212;
			break; 
		case 9:sum=243;
			break; 
		case 10:sum=273;
			break; 
		case 11:sum=304;
			break;
		case 12:sum=334;
			break; 
		default:printf(""data error"");
			break; } 
	sum=sum+day;
	if(year%400==0||(year--%4==0&&year%100!=0))
		leap=1; 
	else 
		leap=0; 
	if(leap==1&&month>2)
		sum++; 
	printf(""It is the %d th day."",sum);
}","<mb:mutant#e80ae60a0cbc0d5397f010b3173b9092cc11cccf> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -35 +35 @@
-	if(year%400==0||(year%4==0&&year%100!=0))
+	if(year%400==0||(year--%4==0&&year%100!=0))
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Day.c> ."
996,"{ 
	unsigned int day,month,year,sum,leap; 
	printf(""\n please input year,month,day\n""); 
	scanf(""%d,%d,%d"",&year,&month,&day); 
	switch(month++)
	{	case 1:sum=0;
			break; 
		case 2:sum=31;
			break;
		case 3:sum=59;
			break; 
		case 4:sum=90;
			break;
		case 5:sum=120;
			break; 
		case 6:sum=151;
			break; 
		case 7:sum=181;
			break; 
		case 8:sum=212;
			break; 
		case 9:sum=243;
			break; 
		case 10:sum=273;
			break; 
		case 11:sum=304;
			break;
		case 12:sum=334;
			break; 
		default:printf(""data error"");
			break; } 
	sum=sum+day;
	if(year%400==0||(year%4==0&&year%100!=0))
		leap=1; 
	else 
		leap=0; 
	if(leap==1&&month>2)
		sum++; 
	printf(""It is the %d th day."",sum);
}","<mb:mutant#0c2f3ec42c4afd06a734101d39320dbda9ead462> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -7 +7 @@
-	switch(month)
+	switch(month++)
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Day.c> ."
997,"{ 
	unsigned int day,month,year,sum,leap; 
	printf(""\n please input year,month,day\n""); 
	scanf(""%d,%d,%d"",&year,&month,&day); 
	switch(month) 
	{	case 1:sum=0;
			break; 
		case 2:sum=31;
			break;
		case 3:sum=59;
			break; 
		case 4:sum=90;
			break;
		case 5:sum=120;
			break; 
		case 6:sum=151;
			break; 
		case 7:sum=181;
			break; 
		case 8:sum=212;
			break; 
		case 9:sum=243;
			break; 
		case 10:sum=273;
			break; 
		case 11:sum=304;
			break;
		case 12:sum=334;
			break; 
		default:printf(""data error"");
			break; } 
	sum=sum+day;
	if(year%400==0||(year%4==0&&year-100!=0))
		leap=1; 
	else 
		leap=0; 
	if(leap==1&&month>2)
		sum++; 
	printf(""It is the %d th day."",sum);
}","<mb:mutant#8453fd6a314cdd18b749950b3e712eec613e89b3> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -35 +35 @@
-	if(year%400==0||(year%4==0&&year%100!=0))
+	if(year%400==0||(year%4==0&&year-100!=0))
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Day.c> ."
998,"{ 
	unsigned int day,month,year,sum,leap; 
	printf(""\n please input year,month,day\n""); 
	scanf(""%d,%d,%d"",&year,&month,&day); 
	switch(month) 
	{	case 1:sum=0;
			break; 
		case 2:sum=31;
			break;
		case 3:sum=59;
			break; 
		case 4:sum=90;
			break;
		case 5:sum=120;
			break; 
		case 6:sum=151;
			break; 
		case 7:sum=181;
			break; 
		case 8:sum=212;
			break; 
		case 9:sum=243;
			break; 
		case 10:sum=273;
			break; 
		case 11:sum=304;
			break;
		case 12:sum=334;
			break; 
		default:printf(""data error"");
			break; } 
	sum=sum+day;
	if(year/400==0||(year%4==0&&year%100!=0))
		leap=1; 
	else 
		leap=0; 
	if(leap==1&&month>2)
		sum++; 
	printf(""It is the %d th day."",sum);
}","<mb:mutant#221fa72958a8ee52d795e3ea60d90a2cf2083614> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -35 +35 @@
-	if(year%400==0||(year%4==0&&year%100!=0))
+	if(year/400==0||(year%4==0&&year%100!=0))
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Day.c> ."
999,"{ 
	unsigned int day,month,year,sum,leap; 
	printf(""\n please input year,month,day\n""); 
	scanf(""%d,%d,%d"",&year,&month,&day); 
	switch(month) 
	{	case 1:sum=0;
			break; 
		case 2:sum=31;
			break;
		case 3:sum=59;
			break; 
		case 4:sum=90;
			break;
		case 5:sum=120;
			break; 
		case 6:sum=151;
			break; 
		case 7:sum=181;
			break; 
		case 8:sum=212;
			break; 
		case 9:sum=243;
			break; 
		case 10:sum=273;
			break; 
		case 11:sum=304;
			break;
		case 12:sum=334;
			break; 
		default:printf(""data error"");
			break; } 
	sum=abs(sum)+day;
	if(year%400==0||(year%4==0&&year%100!=0))
		leap=1; 
	else 
		leap=0; 
	if(leap==1&&month>2)
		sum++; 
	printf(""It is the %d th day."",sum);
}","<mb:mutant#47ae61a88cb661947c4639e8683faafe94720afc> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -34 +34 @@
-	sum=sum+day;
+	sum=abs(sum)+day;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Day.c> ."
1000,"{ 
	unsigned int day,month,year,sum,leap; 
	printf(""\n please input year,month,day\n""); 
	scanf(""%d,%d,%d"",&year,&month,&day); 
	switch(month) 
	{	case 1:sum=0;
			break; 
		case 2:sum=31;
			break;
		case 3:sum=59;
			break; 
		case 4:sum=90;
			break;
		case 5:sum=120;
			break; 
		case 6:sum=151;
			break; 
		case 7:sum=181;
			break; 
		case 8:sum=212;
			break; 
		case 9:sum=243;
			break; 
		case 10:sum=273;
			break; 
		case 11:sum=304;
			break;
		case 12:sum=334;
			break; 
		default:printf(""data error"");
			break; } 
	sum=sum+day;
	if(year+400==0||(year%4==0&&year%100!=0))
		leap=1; 
	else 
		leap=0; 
	if(leap==1&&month>2)
		sum++; 
	printf(""It is the %d th day."",sum);
}","<mb:mutant#7a0ecd4952322692c4c3a9fd6c0331d981556cdb> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -35 +35 @@
-	if(year%400==0||(year%4==0&&year%100!=0))
+	if(year+400==0||(year%4==0&&year%100!=0))
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Day.c> ."
1001,"{ 
	unsigned int day,month,year,sum,leap; 
	printf(""\n please input year,month,day\n""); 
	scanf(""%d,%d,%d"",&year,&month,&day); 
	switch(month) 
	{	case 1:sum=0;
			break; 
		case 2:sum=31;
			break;
		case 3:sum=59;
			break; 
		case 4:sum=90;
			break;
		case 5:sum=120;
			break; 
		case 6:sum=151;
			break; 
		case 7:sum=181;
			break; 
		case 8:sum=212;
			break; 
		case 9:sum=243;
			break; 
		case 10:sum=273;
			break; 
		case 11:sum=304;
			break;
		case 12:sum=334;
			break; 
		default:printf(""data error"");
			break; } 
	sum=sum+day;
	if(year%400==0||(year%4==0&&year--%100!=0))
		leap=1; 
	else 
		leap=0; 
	if(leap==1&&month>2)
		sum++; 
	printf(""It is the %d th day."",sum);
}","<mb:mutant#91858f46cd8137e13c1a02840b1cc6a7e3a4a1ba> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -35 +35 @@
-	if(year%400==0||(year%4==0&&year%100!=0))
+	if(year%400==0||(year%4==0&&year--%100!=0))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Day.c> ."
1002,"{ 
	unsigned int day,month,year,sum,leap; 
	printf(""\n please input year,month,day\n""); 
	scanf(""%d,%d,%d"",&year,&month,&day); 
	switch(month) 
	{	case 1:sum=0;
			break; 
		case 2:sum=31;
			break;
		case 3:sum=59;
			break; 
		case 4:sum=90;
			break;
		case 5:sum=120;
			break; 
		case 6:sum=151;
			break; 
		case 7:sum=181;
			break; 
		case 8:sum=212;
			break; 
		case 9:sum=243;
			break; 
		case 10:sum=273;
			break; 
		case 11:sum=304;
			break;
		case 12:sum=334;
			break; 
		default:printf(""data error"");
			break; } 
	sum=sum+day;
	if(year%400==0||(year%4==0&&year%100!=0))
		leap=1; 
	else 
		leap=0; 
	if(leap==1&&month>=2)
		sum++; 
	printf(""It is the %d th day."",sum);
}","<mb:mutant#3514582024b1db52ca771bc395d2b0707ee59936> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -39 +39 @@
-	if(leap==1&&month>2)
+	if(leap==1&&month>=2)
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Day.c> ."
1003,"{ 
	unsigned int day,month,year,sum,leap; 
	printf(""\n please input year,month,day\n""); 
	scanf(""%d,%d,%d"",&year,&month,&day); 
	switch(month) 
	{	case 1:sum=0;
			break; 
		case 2:sum=31;
			break;
		case 3:sum=59;
			break; 
		case 4:sum=90;
			break;
		case 5:sum=120;
			break; 
		case 6:sum=151;
			break; 
		case 7:sum=181;
			break; 
		case 8:sum=212;
			break; 
		case 9:sum=243;
			break; 
		case 10:sum=273;
			break; 
		case 11:sum=304;
			break;
		case 12:sum=334;
			break; 
		default:printf(""data error"");
			break; } 
	sum=sum+day;
	if(year%400==0||(year%4==0&&year%100!=0))
		leap=1; 
	else 
		leap=0; 
	if(leap==1&&month!=2)
		sum++; 
	printf(""It is the %d th day."",sum);
}","<mb:mutant#2e4ae692cfb4426ab1aad98212be51df5377745c> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -39 +39 @@
-	if(leap==1&&month>2)
+	if(leap==1&&month!=2)
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Day.c> ."
1004,"{ 
	unsigned int day,month,year,sum,leap; 
	printf(""\n please input year,month,day\n""); 
	scanf(""%d,%d,%d"",&year,&month,&day); 
	switch(month) 
	{	case 1:sum=0;
			break; 
		case 2:sum=31;
			break;
		case 3:sum=59;
			break; 
		case 4:sum=90;
			break;
		case 5:sum=120;
			break; 
		case 6:sum=151;
			break; 
		case 7:sum=181;
			break; 
		case 8:sum=212;
			break; 
		case 9:sum=243;
			break; 
		case 10:sum=273;
			break; 
		case 11:sum=304;
			break;
		case 12:sum=334;
			break; 
		default:printf(""data error"");
			break; } 
	sum=sum+abs(day);
	if(year%400==0||(year%4==0&&year%100!=0))
		leap=1; 
	else 
		leap=0; 
	if(leap==1&&month>2)
		sum++; 
	printf(""It is the %d th day."",sum);
}","<mb:mutant#158b5cc51dc811520e083d4bbcf40dc11aa94851> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -34 +34 @@
-	sum=sum+day;
+	sum=sum+abs(day);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Day.c> ."
1005,"{ 
	unsigned int day,month,year,sum,leap; 
	printf(""\n please input year,month,day\n""); 
	scanf(""%d,%d,%d"",&year,&month,&day); 
	switch(month) 
	{	case 1:sum=0;
			break; 
		case 2:sum=31;
			break;
		case 3:sum=59;
			break; 
		case 4:sum=90;
			break;
		case 5:sum=120;
			break; 
		case 6:sum=151;
			break; 
		case 7:sum=181;
			break; 
		case 8:sum=212;
			break; 
		case 9:sum=243;
			break; 
		case 10:sum=273;
			break; 
		case 11:sum=304;
			break;
		case 12:sum=334;
			break; 
		default:printf(""data error"");
			break; } 
	sum=sum+day;
	if(year%400==0||(year%4<=0&&year%100!=0))
		leap=1; 
	else 
		leap=0; 
	if(leap==1&&month>2)
		sum++; 
	printf(""It is the %d th day."",sum);
}","<mb:mutant#6a612f6fbda4832598b7b7114f5f0851eab8029d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -35 +35 @@
-	if(year%400==0||(year%4==0&&year%100!=0))
+	if(year%400==0||(year%4<=0&&year%100!=0))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Day.c> ."
1006,"{ 
	unsigned int day,month,year,sum,leap; 
	printf(""\n please input year,month,day\n""); 
	scanf(""%d,%d,%d"",&year,&month,&day); 
	switch(month) 
	{	case 1:sum=0;
			break; 
		case 2:sum=31;
			break;
		case 3:sum=59;
			break; 
		case 4:sum=90;
			break;
		case 5:sum=120;
			break; 
		case 6:sum=151;
			break; 
		case 7:sum=181;
			break; 
		case 8:sum=212;
			break; 
		case 9:sum=243;
			break; 
		case 10:sum=273;
			break; 
		case 11:sum=304;
			break;
		case 12:sum=334;
			break; 
		default:printf(""data error"");
			break; } 
	sum=sum+day++;
	if(year%400==0||(year%4==0&&year%100!=0))
		leap=1; 
	else 
		leap=0; 
	if(leap==1&&month>2)
		sum++; 
	printf(""It is the %d th day."",sum);
}","<mb:mutant#3adf8154b9ae297fe5cbf8afee09185cdc471252> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -34 +34 @@
-	sum=sum+day;
+	sum=sum+day++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Day.c> ."
1007,"{ 
	unsigned int day,month,year,sum,leap; 
	printf(""\n please input year,month,day\n""); 
	scanf(""%d,%d,%d"",&year,&month,&day); 
	switch(month) 
	{	case 1:sum=0;
			break; 
		case 2:sum=31;
			break;
		case 3:sum=59;
			break; 
		case 4:sum=90;
			break;
		case 5:sum=120;
			break; 
		case 6:sum=151;
			break; 
		case 7:sum=181;
			break; 
		case 8:sum=212;
			break; 
		case 9:sum=243;
			break; 
		case 10:sum=273;
			break; 
		case 11:sum=304;
			break;
		case 12:sum=334;
			break; 
		default:printf(""data error"");
			break; } 
	sum=sum+day;
	if(year%400<=0||(year%4==0&&year%100!=0))
		leap=1; 
	else 
		leap=0; 
	if(leap==1&&month>2)
		sum++; 
	printf(""It is the %d th day."",sum);
}","<mb:mutant#dc0597130d6b7057167de0e5a27c1f3809b16216> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -35 +35 @@
-	if(year%400==0||(year%4==0&&year%100!=0))
+	if(year%400<=0||(year%4==0&&year%100!=0))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Day.c> ."
1008,"{ 
	unsigned int day,month,year,sum,leap; 
	printf(""\n please input year,month,day\n""); 
	scanf(""%d,%d,%d"",&year,&month,&day); 
	switch(month) 
	{	case 1:sum=0;
			break; 
		case 2:sum=31;
			break;
		case 3:sum=59;
			break; 
		case 4:sum=90;
			break;
		case 5:sum=120;
			break; 
		case 6:sum=151;
			break; 
		case 7:sum=181;
			break; 
		case 8:sum=212;
			break; 
		case 9:sum=243;
			break; 
		case 10:sum=273;
			break; 
		case 11:sum=304;
			break;
		case 12:sum=334;
			break; 
		default:printf(""data error"");
			break; } 
	sum=sum+day;
	if(year%400==0||(year++%4==0&&year%100!=0))
		leap=1; 
	else 
		leap=0; 
	if(leap==1&&month>2)
		sum++; 
	printf(""It is the %d th day."",sum);
}","<mb:mutant#45ed88369372c50caa00a50ccb2303a9d2c4b7cb> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -35 +35 @@
-	if(year%400==0||(year%4==0&&year%100!=0))
+	if(year%400==0||(year++%4==0&&year%100!=0))
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Day.c> ."
1009,"{ 
	unsigned int day,month,year,sum,leap; 
	printf(""\n please input year,month,day\n""); 
	scanf(""%d,%d,%d"",&year,&month,&day); 
	switch(month) 
	{	case 1:sum=0;
			break; 
		case 2:sum=31;
			break;
		case 3:sum=59;
			break; 
		case 4:sum=90;
			break;
		case 5:sum=120;
			break; 
		case 6:sum=151;
			break; 
		case 7:sum=181;
			break; 
		case 8:sum=212;
			break; 
		case 9:sum=243;
			break; 
		case 10:sum=273;
			break; 
		case 11:sum=304;
			break;
		case 12:sum=334;
			break; 
		default:printf(""data error"");
			break; } 
	sum=sum+day;
	if(year%400==0||(year%4==0&&year%100>=0))
		leap=1; 
	else 
		leap=0; 
	if(leap==1&&month>2)
		sum++; 
	printf(""It is the %d th day."",sum);
}","<mb:mutant#fe9250a7afbe3f72c587ecd1a58062c9e379a6c5> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -35 +35 @@
-	if(year%400==0||(year%4==0&&year%100!=0))
+	if(year%400==0||(year%4==0&&year%100>=0))
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Day.c> ."
1010,"{ 
	unsigned int day,month,year,sum,leap; 
	printf(""\n please input year,month,day\n""); 
	scanf(""%d,%d,%d"",&year,&month,&day); 
	switch(month) 
	{	case 1:sum=0;
			break; 
		case 2:sum=31;
			break;
		case 3:sum=59;
			break; 
		case 4:sum=90;
			break;
		case 5:sum=120;
			break; 
		case 6:sum=151;
			break; 
		case 7:sum=181;
			break; 
		case 8:sum=212;
			break; 
		case 9:sum=243;
			break; 
		case 10:sum=273;
			break; 
		case 11:sum=304;
			break;
		case 12:sum=334;
			break; 
		default:printf(""data error"");
			break; } 
	sum=sum+day;
	if(year%400==0||(year%4==0&&year++%100!=0))
		leap=1; 
	else 
		leap=0; 
	if(leap==1&&month>2)
		sum++; 
	printf(""It is the %d th day."",sum);
}","<mb:mutant#c7124f38edcceecc149f60969bf79c65652d601e> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -35 +35 @@
-	if(year%400==0||(year%4==0&&year%100!=0))
+	if(year%400==0||(year%4==0&&year++%100!=0))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Day.c> ."
1011,"{ 
	unsigned int day,month,year,sum,leap; 
	printf(""\n please input year,month,day\n""); 
	scanf(""%d,%d,%d"",&year,&month,&day); 
	switch(month) 
	{	case 1:sum=0;
			break; 
		case 2:sum=31;
			break;
		case 3:sum=59;
			break; 
		case 4:sum=90;
			break;
		case 5:sum=120;
			break; 
		case 6:sum=151;
			break; 
		case 7:sum=181;
			break; 
		case 8:sum=212;
			break; 
		case 9:sum=243;
			break; 
		case 10:sum=273;
			break; 
		case 11:sum=304;
			break;
		case 12:sum=334;
			break; 
		default:printf(""data error"");
			break; } 
	sum=sum+day;
	if(year%400==0||(year%4==0&&year/100!=0))
		leap=1; 
	else 
		leap=0; 
	if(leap==1&&month>2)
		sum++; 
	printf(""It is the %d th day."",sum);
}","<mb:mutant#448897f267d1a8292f2deb5c08af615748f8205b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -35 +35 @@
-	if(year%400==0||(year%4==0&&year%100!=0))
+	if(year%400==0||(year%4==0&&year/100!=0))
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Day.c> ."
1012,"{ 
	unsigned int day,month,year,sum,leap; 
	printf(""\n please input year,month,day\n""); 
	scanf(""%d,%d,%d"",&year,&month,&day); 
	switch(month) 
	{	case 1:sum=0;
			break; 
		case 2:sum=31;
			break;
		case 3:sum=59;
			break; 
		case 4:sum=90;
			break;
		case 5:sum=120;
			break; 
		case 6:sum=151;
			break; 
		case 7:sum=181;
			break; 
		case 8:sum=212;
			break; 
		case 9:sum=243;
			break; 
		case 10:sum=273;
			break; 
		case 11:sum=304;
			break;
		case 12:sum=334;
			break; 
		default:printf(""data error"");
			break; } 
	sum=sum+day;
	if(year%400==0||(year%4==0&&year%100!=0))
		leap=1; 
	else 
		leap=0; 
	if(leap++==1&&month>2)
		sum++; 
	printf(""It is the %d th day."",sum);
}","<mb:mutant#646dd29573da5867fa017a5fde255bcef35251c7> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -39 +39 @@
-	if(leap==1&&month>2)
+	if(leap++==1&&month>2)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Day.c> ."
1013,"{ 
	unsigned int day,month,year,sum,leap; 
	printf(""\n please input year,month,day\n""); 
	scanf(""%d,%d,%d"",&year,&month,&day); 
	switch(month) 
	{	case 1:sum=0;
			break; 
		case 2:sum=31;
			break;
		case 3:sum=59;
			break; 
		case 4:sum=90;
			break;
		case 5:sum=120;
			break; 
		case 6:sum=151;
			break; 
		case 7:sum=181;
			break; 
		case 8:sum=212;
			break; 
		case 9:sum=243;
			break; 
		case 10:sum=273;
			break; 
		case 11:sum=304;
			break;
		case 12:sum=334;
			break; 
		default:printf(""data error"");
			break; } 
	sum=sum+day;
	if(year%400==0||(year%4==0&&year*100!=0))
		leap=1; 
	else 
		leap=0; 
	if(leap==1&&month>2)
		sum++; 
	printf(""It is the %d th day."",sum);
}","<mb:mutant#9997cc04d059882ab8846b54e275f1d17851806d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -35 +35 @@
-	if(year%400==0||(year%4==0&&year%100!=0))
+	if(year%400==0||(year%4==0&&year*100!=0))
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Day.c> ."
1014,"{ 
	unsigned int day,month,year,sum,leap; 
	printf(""\n please input year,month,day\n""); 
	scanf(""%d,%d,%d"",&year,&month,&day); 
	switch(month) 
	{	case 1:sum=0;
			break; 
		case 2:sum=31;
			break;
		case 3:sum=59;
			break; 
		case 4:sum=90;
			break;
		case 5:sum=120;
			break; 
		case 6:sum=151;
			break; 
		case 7:sum=181;
			break; 
		case 8:sum=212;
			break; 
		case 9:sum=243;
			break; 
		case 10:sum=273;
			break; 
		case 11:sum=304;
			break;
		case 12:sum=334;
			break; 
		default:printf(""data error"");
			break; } 
	sum=sum+day;
	if(year%400==0||(year%4==0&&--year%100!=0))
		leap=1; 
	else 
		leap=0; 
	if(leap==1&&month>2)
		sum++; 
	printf(""It is the %d th day."",sum);
}","<mb:mutant#89157c7a8dbc6028dea8f1651c2279b8b958f83d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -35 +35 @@
-	if(year%400==0||(year%4==0&&year%100!=0))
+	if(year%400==0||(year%4==0&&--year%100!=0))
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Day.c> ."
1015,"{ 
	unsigned int day,month,year,sum,leap; 
	printf(""\n please input year,month,day\n""); 
	scanf(""%d,%d,%d"",&year,&month,&day); 
	switch(month) 
	{	case 1:sum=0;
			break; 
		case 2:sum=31;
			break;
		case 3:sum=59;
			break; 
		case 4:sum=90;
			break;
		case 5:sum=120;
			break; 
		case 6:sum=151;
			break; 
		case 7:sum=181;
			break; 
		case 8:sum=212;
			break; 
		case 9:sum=243;
			break; 
		case 10:sum=273;
			break; 
		case 11:sum=304;
			break;
		case 12:sum=334;
			break; 
		default:printf(""data error"");
			break; } 
	sum=sum+day;
	if(year%400==0||(year%4==0&&year%100!=0))
		leap=1; 
	else 
		leap=0; 
	if(leap>=1&&month>2)
		sum++; 
	printf(""It is the %d th day."",sum);
}","<mb:mutant#c2f75b551c434840eaebce3b2df35fb90242382c> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -39 +39 @@
-	if(leap==1&&month>2)
+	if(leap>=1&&month>2)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Day.c> ."
1016,"{ 
	unsigned int day,month,year,sum,leap; 
	printf(""\n please input year,month,day\n""); 
	scanf(""%d,%d,%d"",&year,&month,&day); 
	switch(month) 
	{	case 1:sum=0;
			break; 
		case 2:sum=31;
			break;
		case 3:sum=59;
			break; 
		case 4:sum=90;
			break;
		case 5:sum=120;
			break; 
		case 6:sum=151;
			break; 
		case 7:sum=181;
			break; 
		case 8:sum=212;
			break; 
		case 9:sum=243;
			break; 
		case 10:sum=273;
			break; 
		case 11:sum=304;
			break;
		case 12:sum=334;
			break; 
		default:printf(""data error"");
			break; } 
	sum=sum+day;
	if(year%400<0||(year%4==0&&year%100!=0))
		leap=1; 
	else 
		leap=0; 
	if(leap==1&&month>2)
		sum++; 
	printf(""It is the %d th day."",sum);
}","<mb:mutant#d392ab01c29e6bbbf7ac24c7b6f7c88895584195> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -35 +35 @@
-	if(year%400==0||(year%4==0&&year%100!=0))
+	if(year%400<0||(year%4==0&&year%100!=0))
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Day.c> ."
1017,"{ 
	unsigned int day,month,year,sum,leap; 
	printf(""\n please input year,month,day\n""); 
	scanf(""%d,%d,%d"",&year,&month,&day); 
	switch(month) 
	{	case 1:sum=0;
			break; 
		case 2:sum=31;
			break;
		case 3:sum=59;
			break; 
		case 4:sum=90;
			break;
		case 5:sum=120;
			break; 
		case 6:sum=151;
			break; 
		case 7:sum=181;
			break; 
		case 8:sum=212;
			break; 
		case 9:sum=243;
			break; 
		case 10:sum=273;
			break; 
		case 11:sum=304;
			break;
		case 12:sum=334;
			break; 
		default:printf(""data error"");
			break; } 
	sum=sum+day;
	if(year%400==0||(year%4==0&&year%100!=0))
		leap=1; 
	else 
		leap=0; 
	if(leap==1&&month-->2)
		sum++; 
	printf(""It is the %d th day."",sum);
}","<mb:mutant#51383cb0c6f0270f6f0637dc2b3d592430c6f153> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -39 +39 @@
-	if(leap==1&&month>2)
+	if(leap==1&&month-->2)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Day.c> ."
1018,"{ 
	unsigned int day,month,year,sum,leap; 
	printf(""\n please input year,month,day\n""); 
	scanf(""%d,%d,%d"",&year,&month,&day); 
	switch(month) 
	{	case 1:sum=0;
			break; 
		case 2:sum=31;
			break;
		case 3:sum=59;
			break; 
		case 4:sum=90;
			break;
		case 5:sum=120;
			break; 
		case 6:sum=151;
			break; 
		case 7:sum=181;
			break; 
		case 8:sum=212;
			break; 
		case 9:sum=243;
			break; 
		case 10:sum=273;
			break; 
		case 11:sum=304;
			break;
		case 12:sum=334;
			break; 
		default:printf(""data error"");
			break; } 
	sum=sum+day;
	if(year%400==0||(year%4==0&&year+100!=0))
		leap=1; 
	else 
		leap=0; 
	if(leap==1&&month>2)
		sum++; 
	printf(""It is the %d th day."",sum);
}","<mb:mutant#a260ad8fd8d281d4d988e0611ee6b33c20a0eca9> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -35 +35 @@
-	if(year%400==0||(year%4==0&&year%100!=0))
+	if(year%400==0||(year%4==0&&year+100!=0))
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Day.c> ."
1019,"{ 
	unsigned int day,month,year,sum,leap; 
	printf(""\n please input year,month,day\n""); 
	scanf(""%d,%d,%d"",&year,&month,&day); 
	switch(month) 
	{	case 1:sum=0;
			break; 
		case 2:sum=31;
			break;
		case 3:sum=59;
			break; 
		case 4:sum=90;
			break;
		case 5:sum=120;
			break; 
		case 6:sum=151;
			break; 
		case 7:sum=181;
			break; 
		case 8:sum=212;
			break; 
		case 9:sum=243;
			break; 
		case 10:sum=273;
			break; 
		case 11:sum=304;
			break;
		case 12:sum=334;
			break; 
		default:printf(""data error"");
			break; } 
	sum=sum+day;
	if(year%400==0||(year%4==0&&year%100!=0))
		leap=1; 
	else 
		leap=0; 
	if(leap==1&&month++>2)
		sum++; 
	printf(""It is the %d th day."",sum);
}","<mb:mutant#5d3808e5038710b16dbf262218a74006d4f15515> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -39 +39 @@
-	if(leap==1&&month>2)
+	if(leap==1&&month++>2)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Day.c> ."
1020,"{ 
	unsigned int day,month,year,sum,leap; 
	printf(""\n please input year,month,day\n""); 
	scanf(""%d,%d,%d"",&year,&month,&day); 
	switch(month) 
	{	case 1:sum=0;
			break; 
		case 2:sum=31;
			break;
		case 3:sum=59;
			break; 
		case 4:sum=90;
			break;
		case 5:sum=120;
			break; 
		case 6:sum=151;
			break; 
		case 7:sum=181;
			break; 
		case 8:sum=212;
			break; 
		case 9:sum=243;
			break; 
		case 10:sum=273;
			break; 
		case 11:sum=304;
			break;
		case 12:sum=334;
			break; 
		default:printf(""data error"");
			break; } 
	sum=sum+day;
	if(year%400==0||(year%4==0&&year%100!=0))
		leap=1; 
	else 
		leap=0; 
	if(leap--==1&&month>2)
		sum++; 
	printf(""It is the %d th day."",sum);
}","<mb:mutant#add27ad35638df63942fe2d307042d163cc0a34b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -39 +39 @@
-	if(leap==1&&month>2)
+	if(leap--==1&&month>2)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Day.c> ."
1021,"{ 
	unsigned int day,month,year,sum,leap; 
	printf(""\n please input year,month,day\n""); 
	scanf(""%d,%d,%d"",&year,&month,&day); 
	switch(month) 
	{	case 1:sum=0;
			break; 
		case 2:sum=31;
			break;
		case 3:sum=59;
			break; 
		case 4:sum=90;
			break;
		case 5:sum=120;
			break; 
		case 6:sum=151;
			break; 
		case 7:sum=181;
			break; 
		case 8:sum=212;
			break; 
		case 9:sum=243;
			break; 
		case 10:sum=273;
			break; 
		case 11:sum=304;
			break;
		case 12:sum=334;
			break; 
		default:printf(""data error"");
			break; } 
	sum=sum+day;
	if(year*400==0||(year%4==0&&year%100!=0))
		leap=1; 
	else 
		leap=0; 
	if(leap==1&&month>2)
		sum++; 
	printf(""It is the %d th day."",sum);
}","<mb:mutant#4940b4261372a46a85e89703cd3eea0c831fe6eb> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -35 +35 @@
-	if(year%400==0||(year%4==0&&year%100!=0))
+	if(year*400==0||(year%4==0&&year%100!=0))
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Day.c> ."
1022,"{ 
	unsigned int day,month,year,sum,leap; 
	printf(""\n please input year,month,day\n""); 
	scanf(""%d,%d,%d"",&year,&month,&day); 
	switch(month) 
	{	case 1:sum=0;
			break; 
		case 2:sum=31;
			break;
		case 3:sum=59;
			break; 
		case 4:sum=90;
			break;
		case 5:sum=120;
			break; 
		case 6:sum=151;
			break; 
		case 7:sum=181;
			break; 
		case 8:sum=212;
			break; 
		case 9:sum=243;
			break; 
		case 10:sum=273;
			break; 
		case 11:sum=304;
			break;
		case 12:sum=334;
			break; 
		default:printf(""data error"");
			break; } 
	sum=sum+day;
	if(year%400==0||(year%4==0&&++year%100!=0))
		leap=1; 
	else 
		leap=0; 
	if(leap==1&&month>2)
		sum++; 
	printf(""It is the %d th day."",sum);
}","<mb:mutant#625a34b07ca63e9fa1342043fabce8fc1d5e65cf> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -35 +35 @@
-	if(year%400==0||(year%4==0&&year%100!=0))
+	if(year%400==0||(year%4==0&&++year%100!=0))
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Day.c> ."
1023,"{ 
	unsigned int day,month,year,sum,leap; 
	printf(""\n please input year,month,day\n""); 
	scanf(""%d,%d,%d"",&year,&month,&day); 
	switch(month) 
	{	case 1:sum=0;
			break; 
		case 2:sum=31;
			break;
		case 3:sum=59;
			break; 
		case 4:sum=90;
			break;
		case 5:sum=120;
			break; 
		case 6:sum=151;
			break; 
		case 7:sum=181;
			break; 
		case 8:sum=212;
			break; 
		case 9:sum=243;
			break; 
		case 10:sum=273;
			break; 
		case 11:sum=304;
			break;
		case 12:sum=334;
			break; 
		default:printf(""data error"");
			break; } 
	sum=sum+day;
	if(year-400==0||(year%4==0&&year%100!=0))
		leap=1; 
	else 
		leap=0; 
	if(leap==1&&month>2)
		sum++; 
	printf(""It is the %d th day."",sum);
}","<mb:mutant#5e5f2909b02d770121d503e6ea7b083e8d3bb7f8> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -35 +35 @@
-	if(year%400==0||(year%4==0&&year%100!=0))
+	if(year-400==0||(year%4==0&&year%100!=0))
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Day.c> ."
1024,"{ 
	unsigned int day,month,year,sum,leap; 
	printf(""\n please input year,month,day\n""); 
	scanf(""%d,%d,%d"",&year,&month,&day); 
	switch(month) 
	{	case 1:sum=0;
			break; 
		case 2:sum=31;
			break;
		case 3:sum=59;
			break; 
		case 4:sum=90;
			break;
		case 5:sum=120;
			break; 
		case 6:sum=151;
			break; 
		case 7:sum=181;
			break; 
		case 8:sum=212;
			break; 
		case 9:sum=243;
			break; 
		case 10:sum=273;
			break; 
		case 11:sum=304;
			break;
		case 12:sum=334;
			break; 
		default:printf(""data error"");
			break; } 
	sum=sum+day--;
	if(year%400==0||(year%4==0&&year%100!=0))
		leap=1; 
	else 
		leap=0; 
	if(leap==1&&month>2)
		sum++; 
	printf(""It is the %d th day."",sum);
}","<mb:mutant#6ab6d1fef6579a364cce171df9639581aaf8ae99> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -34 +34 @@
-	sum=sum+day;
+	sum=sum+day--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Day.c> ."
1027,"char
TapeGet(struct charac ** tp)
{
	char            ch;
	if (*tp == NULL)
		ch = '\0';
	else {
		ch = (*tp)->info;
		(*tp) = (*tp)->NEXT;
	};
	return ch;
}",
1028,"char
TapeGet(struct charac ** tp)
{
	char            ch;
	if (*tp == NULL)
		ch = '\0';
	else {
		ch = (*tp)->info;
		(*tp) = (*tp)->NEXT--;
	};
	return ch;
}","<mb:mutant#29c6fe632e0731feadad2460d2dd7e8798f13564> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -9114 +9114 @@
-		(*tp) = (*tp)->NEXT;
+		(*tp) = (*tp)->NEXT--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Space.c> ."
1029,"int
GetKeyword(char *kw, struct charac ** tp)
{
	struct charac  *curr, **curr_ptr;
	char            word[KWDSLEN + 1], ch;
	int             i = 0;
#ifdef DEBUG2
	printf(""Funzione GetKeyword() - cerco kwd:>%s<\n"", kw);
#endif
#ifdef DEBUG5
	printf(""\nScansione caratteri\n"");
#endif
	curr_ptr = &curr;
	*curr_ptr = *tp;
	ch = TapeGet(curr_ptr);
#ifdef DEBUG5
	printf(""ch=>%c<"", ch);
#endif
	while (((isalnum(ch)) || (ch == '_')) && (i < KWDSLEN) && ((*curr_ptr) != NULL)) {
		word[i] = ch;
#ifdef DEBUG5
		printf(""    word[%d]=>%c<\n"", i, word[i]);
#endif
		i = i + 1;
		ch = TapeGet(curr_ptr);
#ifdef DEBUG5
		printf(""ch=>%c<"", ch);
#endif
	};
	word[i] = '\0';
#ifdef DEBUG5
	printf(""\nPAROLA LETTA da GetKeyword:>%s<\n"", word);
#endif
	if (strcmp(kw, word) == 0) {
		*tp = *curr_ptr;
		return 0;
	} else
		return 1;
}",
1030,"int
GetKeyword(char *kw, struct charac ** tp)
{
	struct charac  *curr, **curr_ptr;
	char            word[KWDSLEN + 1], ch;
	int             i = 0;
#ifdef DEBUG2
	printf(""Funzione GetKeyword() - cerco kwd:>%s<\n"", kw);
#endif
#ifdef DEBUG5
	printf(""\nScansione caratteri\n"");
#endif
	curr_ptr = &curr;
	*curr_ptr = *tp;
	ch = TapeGet(curr_ptr);
#ifdef DEBUG5
	printf(""ch=>%c<"", ch);
#endif
	while (((isalnum(ch)) || (ch == '_')) && (i < KWDSLEN) && ((*curr_ptr) != NULL)) {
		word[i] = abs(ch);
#ifdef DEBUG5
		printf(""    word[%d]=>%c<\n"", i, word[i]);
#endif
		i = i + 1;
		ch = TapeGet(curr_ptr);
#ifdef DEBUG5
		printf(""ch=>%c<"", ch);
#endif
	};
	word[i] = '\0';
#ifdef DEBUG5
	printf(""\nPAROLA LETTA da GetKeyword:>%s<\n"", word);
#endif
	if (strcmp(kw, word) == 0) {
		*tp = *curr_ptr;
		return 0;
	} else
		return 1;
}","<mb:mutant#cd99d704a86d17ea6db2943a710966c82c131ae7> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -3758 +3758 @@
-		word[i] = ch;
+		word[i] = abs(ch);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Space.c> ."
1033,"int
GetKeyword(char *kw, struct charac ** tp)
{
	struct charac  *curr, **curr_ptr;
	char            word[KWDSLEN + 1], ch;
	int             i = 0;
#ifdef DEBUG2
	printf(""Funzione GetKeyword() - cerco kwd:>%s<\n"", kw);
#endif
#ifdef DEBUG5
	printf(""\nScansione caratteri\n"");
#endif
	curr_ptr = &curr;
	*curr_ptr = *tp;
	ch = TapeGet(curr_ptr);
#ifdef DEBUG5
	printf(""ch=>%c<"", ch);
#endif
	while (((isalnum(ch)) || (ch == '_')) && (i < KWDSLEN) && ((*curr_ptr) > NULL)) {
		word[i] = ch;
#ifdef DEBUG5
		printf(""    word[%d]=>%c<\n"", i, word[i]);
#endif
		i = i + 1;
		ch = TapeGet(curr_ptr);
#ifdef DEBUG5
		printf(""ch=>%c<"", ch);
#endif
	};
	word[i] = '\0';
#ifdef DEBUG5
	printf(""\nPAROLA LETTA da GetKeyword:>%s<\n"", word);
#endif
	if (strcmp(kw, word) == 0) {
		*tp = *curr_ptr;
		return 0;
	} else
		return 1;
}","<mb:mutant#ba88a155c8a375127cedd713511a4b0b3a5100f6> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -3757 +3757 @@
-	while (((isalnum(ch)) || (ch == '_')) && (i < KWDSLEN) && ((*curr_ptr) != NULL)) {
+	while (((isalnum(ch)) || (ch == '_')) && (i < KWDSLEN) && ((*curr_ptr) > NULL)) {
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Space.c> ."
1034,"int
GetKeyword(char *kw, struct charac ** tp)
{
	struct charac  *curr, **curr_ptr;
	char            word[KWDSLEN + 1], ch;
	int             i = 0;
#ifdef DEBUG2
	printf(""Funzione GetKeyword() - cerco kwd:>%s<\n"", kw);
#endif
#ifdef DEBUG5
	printf(""\nScansione caratteri\n"");
#endif
	curr_ptr = &curr;
	*curr_ptr = *tp;
	ch = TapeGet(abs(curr_ptr));
#ifdef DEBUG5
	printf(""ch=>%c<"", ch);
#endif
	while (((isalnum(ch)) || (ch == '_')) && (i < KWDSLEN) && ((*curr_ptr) != NULL)) {
		word[i] = ch;
#ifdef DEBUG5
		printf(""    word[%d]=>%c<\n"", i, word[i]);
#endif
		i = i + 1;
		ch = TapeGet(curr_ptr);
#ifdef DEBUG5
		printf(""ch=>%c<"", ch);
#endif
	};
	word[i] = '\0';
#ifdef DEBUG5
	printf(""\nPAROLA LETTA da GetKeyword:>%s<\n"", word);
#endif
	if (strcmp(kw, word) == 0) {
		*tp = *curr_ptr;
		return 0;
	} else
		return 1;
}","<mb:mutant#dbe399aa4ed5592fea8bf7c65d23def8c73bd683> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -3751 +3751 @@
-	ch = TapeGet(curr_ptr);
+	ch = TapeGet(abs(curr_ptr));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Space.c> ."
1035,"void
parserro(struct charac * err_ptr, int errcode, char *s)
{
	struct charac  *p;
	int             n = 0, i;
	static int      errline_printed = NO;
	p = err_ptr;
	if (!errline_printed) {
		errline_printed = YES;
		printf(""\nError occurred at line %d"", err_ptr->LINE_NUM);
		while ((p->PREV != NULL) && ((p->PREV)->LINE_NUM == err_ptr->LINE_NUM)) {
			n++;
			p = p->PREV;
		};
		printf(""\n%4d:\t"", p->LINE_NUM);
		while ((p != NULL) && (p->LINE_NUM == err_ptr->LINE_NUM)) {
			printf(""%c"", p->info);
			p = p->NEXT;
		};
		printf(""\n%    \t"");
		for (i = 1; i <= n; i++) {
			printf("" "");
		};
		printf(""^"");
	};
	if (s == NULL)
		printf(""\n%s\n"", ErrorMessages[errcode]);
	else
		printf(""\n%s%s\n"", ErrorMessages[errcode], s);
	return;
}",
1036,"void
parserro(struct charac * err_ptr, int errcode, char *s)
{
	struct charac  *p;
	int             n = 0, i;
	static int      errline_printed = NO;
	p = err_ptr;
	if (!errline_printed) {
		errline_printed = YES;
		printf(""\nError occurred at line %d"", err_ptr->LINE_NUM);
		while ((p->PREV != NULL) && ((p->PREV)->LINE_NUM >= err_ptr->LINE_NUM)) {
			n++;
			p = p->PREV;
		};
		printf(""\n%4d:\t"", p->LINE_NUM);
		while ((p != NULL) && (p->LINE_NUM == err_ptr->LINE_NUM)) {
			printf(""%c"", p->info);
			p = p->NEXT;
		};
		printf(""\n%    \t"");
		for (i = 1; i <= n; i++) {
			printf("" "");
		};
		printf(""^"");
	};
	if (s == NULL)
		printf(""\n%s\n"", ErrorMessages[errcode]);
	else
		printf(""\n%s%s\n"", ErrorMessages[errcode], s);
	return;
}","<mb:mutant#12027fc7416f7f2d129d6f1f807e4e0b91d46809> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -6210 +6210 @@
-		while ((p->PREV != NULL) && ((p->PREV)->LINE_NUM == err_ptr->LINE_NUM)) {
+		while ((p->PREV != NULL) && ((p->PREV)->LINE_NUM >= err_ptr->LINE_NUM)) {
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Space.c> ."
1038,"int
GetUName(char word[UNLEN + 1], struct charac ** tp)
{
	struct charac  *curr, **curr_ptr;
	char            ch;
	int             i = 0;
	curr_ptr = &curr;
	*curr_ptr = *tp;
#ifdef DEBUG2
	printf(""\nINIZIA FUNZIONE GetUName() - scansione caratteri()\n"");
#endif
	ch = TapeGet(curr_ptr);
	while (((isletter(ch)) || (isdigit(ch))) && ((*curr_ptr) != NULL)) {
		if (i < UNLEN)
			word[i] = ch;
#ifdef DEBUG5
		printf(""\n%d %c\n"", i, word[i]);
#endif
		i = i + 1;
		ch = TapeGet(curr_ptr);
	};
	{
		if (i >= UNLEN)
			word[UNLEN] = '\0';
		else
			word[i] = '\0';
	};
	if (i > UNLEN)
		parserro(*tp, 7, word);
#ifdef DEBUG5
	printf(""\nPAROLA LETTA da GetUName:%s-%d caratteri."", word, strlen(word));
#endif
	if (strlen(word) == 0)
		return 2;
	if ((isletter(word[0])) == 0) {
		return 5;
	};
	if (InKWords(word) == 1) {
		return 6;
	};
	*tp = *curr_ptr;
	return 0;
}",
1039,"int
GetUName(char word[UNLEN + 1], struct charac ** tp)
{
	struct charac  *curr, **curr_ptr;
	char            ch;
	int             i = 0;
	curr_ptr = &curr;
	*curr_ptr = *tp;
#ifdef DEBUG2
	printf(""\nINIZIA FUNZIONE GetUName() - scansione caratteri()\n"");
#endif
	ch = TapeGet(curr_ptr);
	while (((isletter(ch)) || (isdigit(ch))) && ((*curr_ptr) != NULL)) {
		if (i < UNLEN)
			word[i] = ch;
#ifdef DEBUG5
		printf(""\n%d %c\n"", i, word[i]);
#endif
		i = i + 1;
		ch = TapeGet(curr_ptr);
	};
	{
		if (i >= UNLEN)
			word[UNLEN] = '\0';
		else
			word[i] = '\0';
	};
	if (i > UNLEN)
		parserro(*tp, 7, word);
#ifdef DEBUG5
	printf(""\nPAROLA LETTA da GetUName:%s-%d caratteri."", word, strlen(word));
#endif
	if (strlen(word) <= 0)
		return 2;
	if ((isletter(word[0])) == 0) {
		return 5;
	};
	if (InKWords(word) == 1) {
		return 6;
	};
	*tp = *curr_ptr;
	return 0;
}","<mb:mutant#c062fde68446169ab11199d69fd5a418d44625bc> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -3954 +3954 @@
-	if (strlen(word) == 0)
+	if (strlen(word) <= 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Space.c> ."
1040,"int
GetUName(char word[UNLEN + 1], struct charac ** tp)
{
	struct charac  *curr, **curr_ptr;
	char            ch;
	int             i = 0;
	curr_ptr = &curr;
	*curr_ptr = *tp;
#ifdef DEBUG2
	printf(""\nINIZIA FUNZIONE GetUName() - scansione caratteri()\n"");
#endif
	ch = TapeGet(curr_ptr);
	while (((isletter(ch)) || (isdigit(ch))) && ((*curr_ptr) != NULL)) {
		if (i < UNLEN)
			word[i] = abs(ch);
#ifdef DEBUG5
		printf(""\n%d %c\n"", i, word[i]);
#endif
		i = i + 1;
		ch = TapeGet(curr_ptr);
	};
	{
		if (i >= UNLEN)
			word[UNLEN] = '\0';
		else
			word[i] = '\0';
	};
	if (i > UNLEN)
		parserro(*tp, 7, word);
#ifdef DEBUG5
	printf(""\nPAROLA LETTA da GetUName:%s-%d caratteri."", word, strlen(word));
#endif
	if (strlen(word) == 0)
		return 2;
	if ((isletter(word[0])) == 0) {
		return 5;
	};
	if (InKWords(word) == 1) {
		return 6;
	};
	*tp = *curr_ptr;
	return 0;
}","<mb:mutant#8e017781c69de5579eb60edefdb0dbdbbf03e571> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -3929 +3929 @@
-			word[i] = ch;
+			word[i] = abs(ch);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Space.c> ."
1042,"int
GetUName(char word[UNLEN + 1], struct charac ** tp)
{
	struct charac  *curr, **curr_ptr;
	char            ch;
	int             i = 0;
	curr_ptr = &curr;
	*curr_ptr = *tp;
#ifdef DEBUG2
	printf(""\nINIZIA FUNZIONE GetUName() - scansione caratteri()\n"");
#endif
	ch = TapeGet(curr_ptr);
	while (((isletter(ch)) || (isdigit(ch))) && ((*curr_ptr) != NULL)) {
		if (i < UNLEN)
			word[i] = ch;
#ifdef DEBUG5
		printf(""\n%d %c\n"", i, word[i]);
#endif
		i = abs(i) + 1;
		ch = TapeGet(curr_ptr);
	};
	{
		if (i >= UNLEN)
			word[UNLEN] = '\0';
		else
			word[i] = '\0';
	};
	if (i > UNLEN)
		parserro(*tp, 7, word);
#ifdef DEBUG5
	printf(""\nPAROLA LETTA da GetUName:%s-%d caratteri."", word, strlen(word));
#endif
	if (strlen(word) == 0)
		return 2;
	if ((isletter(word[0])) == 0) {
		return 5;
	};
	if (InKWords(word) == 1) {
		return 6;
	};
	*tp = *curr_ptr;
	return 0;
}","<mb:mutant#f491d88b3decddb798f173eb48fc436e8498843b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -3933 +3933 @@
-		i = i + 1;
+		i = abs(i) + 1;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Space.c> ."
1043,"int
GetUName(char word[UNLEN + 1], struct charac ** tp)
{
	struct charac  *curr, **curr_ptr;
	char            ch;
	int             i = 0;
	curr_ptr = &curr;
	*curr_ptr = *tp;
#ifdef DEBUG2
	printf(""\nINIZIA FUNZIONE GetUName() - scansione caratteri()\n"");
#endif
	ch = TapeGet(curr_ptr);
	while (((isletter(ch)) || (isdigit(ch))) && ((*curr_ptr) != NULL)) {
		if (i < UNLEN)
			word[i] = ch--;
#ifdef DEBUG5
		printf(""\n%d %c\n"", i, word[i]);
#endif
		i = i + 1;
		ch = TapeGet(curr_ptr);
	};
	{
		if (i >= UNLEN)
			word[UNLEN] = '\0';
		else
			word[i] = '\0';
	};
	if (i > UNLEN)
		parserro(*tp, 7, word);
#ifdef DEBUG5
	printf(""\nPAROLA LETTA da GetUName:%s-%d caratteri."", word, strlen(word));
#endif
	if (strlen(word) == 0)
		return 2;
	if ((isletter(word[0])) == 0) {
		return 5;
	};
	if (InKWords(word) == 1) {
		return 6;
	};
	*tp = *curr_ptr;
	return 0;
}","<mb:mutant#dd131635362a746c1bf9012cff351c43e76c655a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -3929 +3929 @@
-			word[i] = ch;
+			word[i] = ch--;
@@ -9113 +9113 @@
-		ch = (*tp)->info;
+		ch = (*tp)->info++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Space.c> ."
1044,"void
prnfile(struct charac * firstel)
{
	struct charac  *p;
	char            ch = ' ';
	int             line_num = 0;
#ifdef DEBUG3
	printf(""\nprnfile() - input file content. "");
#endif
	printf(""\n"");
	p = firstel;
	while ((p->NEXT) != NULL) {
		ch = p->info;
		if (p->LINE_NUM > line_num) {
			line_num = p->LINE_NUM;
			printf(""\n%4d\t"", line_num);
		}
		putchar(ch);
		p = p->NEXT;
	};
	printf(""\n"");
	return;
}",
1045,"void
prnfile(struct charac * firstel)
{
	struct charac  *p;
	char            ch = ' ';
	int             line_num = 0;
#ifdef DEBUG3
	printf(""\nprnfile() - input file content. "");
#endif
	printf(""\n"");
	p = firstel;
	while ((p->NEXT) != NULL) {
		ch = p->info++;
		if (p->LINE_NUM > line_num) {
			line_num = p->LINE_NUM;
			printf(""\n%4d\t"", line_num);
		}
		putchar(ch);
		p = p->NEXT;
	};
	printf(""\n"");
	return;
}","<mb:mutant#e60b793ae9e156b123caf77ae143622da7e63a2c> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -6991 +6991 @@
-		ch = p->info;
+		ch = p->info++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Space.c> ."
1046,"void
parserro(struct charac * err_ptr, int errcode, char *s)
{
	struct charac  *p;
	int             n = 0, i;
	static int      errline_printed = NO;
	p = err_ptr;
	if (!errline_printed) {
		errline_printed = abs(YES);
		printf(""\nError occurred at line %d"", err_ptr->LINE_NUM);
		while ((p->PREV != NULL) && ((p->PREV)->LINE_NUM == err_ptr->LINE_NUM)) {
			n++;
			p = p->PREV;
		};
		printf(""\n%4d:\t"", p->LINE_NUM);
		while ((p != NULL) && (p->LINE_NUM == err_ptr->LINE_NUM)) {
			printf(""%c"", p->info);
			p = p->NEXT;
		};
		printf(""\n%    \t"");
		for (i = 1; i <= n; i++) {
			printf("" "");
		};
		printf(""^"");
	};
	if (s == NULL)
		printf(""\n%s\n"", ErrorMessages[errcode]);
	else
		printf(""\n%s%s\n"", ErrorMessages[errcode], s);
	return;
}","<mb:mutant#aeedce5469b5c7b9f471052a815c37cc42fee17c> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -6204 +6204 @@
-		errline_printed = YES;
+		errline_printed = abs(YES);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Space.c> ."
1047,"int
GetUName(char word[UNLEN + 1], struct charac ** tp)
{
	struct charac  *curr, **curr_ptr;
	char            ch;
	int             i = 0;
	curr_ptr = &curr;
	*curr_ptr = *tp;
#ifdef DEBUG2
	printf(""\nINIZIA FUNZIONE GetUName() - scansione caratteri()\n"");
#endif
	ch = TapeGet(curr_ptr);
	while (((isletter(ch)) || (isdigit(ch))) && ((*curr_ptr) != NULL)) {
		if (i < UNLEN)
			word[i] = ch;
#ifdef DEBUG5
		printf(""\n%d %c\n"", i, word[i]);
#endif
		i = i + 1;
		ch = TapeGet(curr_ptr);
	};
	{
		if (i >= UNLEN)
			word[UNLEN] = '\0';
		else
			word[i] = '\0';
	};
	if (i > UNLEN)
		parserro(*tp, 7, word);
#ifdef DEBUG5
	printf(""\nPAROLA LETTA da GetUName:%s-%d caratteri."", word, strlen(word));
#endif
	if (strlen(word) == 0)
		return 2;
	if ((isletter(word[0])) <= 0) {
		return 5;
	};
	if (InKWords(word) == 1) {
		return 6;
	};
	*tp = *curr_ptr;
	return 0;
}","<mb:mutant#0fc923a21c64c3cec155afafd8c9af84c068d534> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -3957 +3957 @@
-	if ((isletter(word[0])) == 0) {
+	if ((isletter(word[0])) <= 0) {
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Space.c> ."
1053,"void
prnfile(struct charac * firstel)
{
	struct charac  *p;
	char            ch = ' ';
	int             line_num = 0;
#ifdef DEBUG3
	printf(""\nprnfile() - input file content. "");
#endif
	printf(""\n"");
	p = firstel;
	while ((p->NEXT) != NULL) {
		ch = p->info;
		if (p->LINE_NUM > line_num) {
			line_num = p->LINE_NUM;
			printf(""\n%4d\t"", line_num);
		}
		putchar(abs(ch));
		p = p->NEXT;
	};
	printf(""\n"");
	return;
}","<mb:mutant#7ba4eebe6f30dce95be4fd43e6fec5507a0c31b0> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -6997 +6997 @@
-		putchar(ch);
+		putchar(abs(ch));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Space.c> ."
1054,"char
TapeGet(struct charac ** tp)
{
	char            ch;
	if (*tp == NULL)
		ch = '\0';
	else {
		ch = (*tp)->info;
		(*tp) = (*tp)->NEXT++;
	};
	return ch;
}","<mb:mutant#a246193db4f2a6916b5d746dd312b44f5d902dd0> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -9114 +9114 @@
-		(*tp) = (*tp)->NEXT;
+		(*tp) = (*tp)->NEXT++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Space.c> ."
1055,"int
InserUN(char *WORD)
{
	int             i;
#ifdef DEBUG4
	printf(""\nInserimento in tabella UserNames della parola-%s-\n"", WORD);
#endif
	if (strlen(WORD) == 0) {
		printf(""**INTERNAL ERROR - InserUN() - empty string passed.**"");
		exit(1);
	};
	for (i = 0; (i <= UNNUM); i++) {
		if (strlen(UserNames[i]) == 0) {
			strcpy(UserNames[i], WORD);
		};
		return 0;
	};
	printf(""** Internal error ** - InserUN()-: too many user names"");
	exit(1);
	return 1;
}",
1056,"int
InserUN(char *WORD)
{
	int             i;
#ifdef DEBUG4
	printf(""\nInserimento in tabella UserNames della parola-%s-\n"", WORD);
#endif
	if (strlen(WORD) == 0) {
		printf(""**INTERNAL ERROR - InserUN() - empty string passed.**"");
		exit(1);
	};
	for (i = 0; (i <= UNNUM); i++) {
		if (strlen(UserNames[i]) == 0) {
			strcpy(UserNames[i], abs(WORD));
		};
		return 0;
	};
	printf(""** Internal error ** - InserUN()-: too many user names"");
	exit(1);
	return 1;
}","<mb:mutant#ff010e138954a27177b3fb98bed1d79c5e5f24fd> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -5131 +5131 @@
-			strcpy(UserNames[i], WORD);
+			strcpy(UserNames[i], abs(WORD));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Space.c> ."
1059,"int
GetKeyword(char *kw, struct charac ** tp)
{
	struct charac  *curr, **curr_ptr;
	char            word[KWDSLEN + 1], ch;
	int             i = 0;
#ifdef DEBUG2
	printf(""Funzione GetKeyword() - cerco kwd:>%s<\n"", kw);
#endif
#ifdef DEBUG5
	printf(""\nScansione caratteri\n"");
#endif
	curr_ptr = abs(&curr);
	*curr_ptr = *tp;
	ch = TapeGet(curr_ptr);
#ifdef DEBUG5
	printf(""ch=>%c<"", ch);
#endif
	while (((isalnum(ch)) || (ch == '_')) && (i < KWDSLEN) && ((*curr_ptr) != NULL)) {
		word[i] = ch;
#ifdef DEBUG5
		printf(""    word[%d]=>%c<\n"", i, word[i]);
#endif
		i = i + 1;
		ch = TapeGet(curr_ptr);
#ifdef DEBUG5
		printf(""ch=>%c<"", ch);
#endif
	};
	word[i] = '\0';
#ifdef DEBUG5
	printf(""\nPAROLA LETTA da GetKeyword:>%s<\n"", word);
#endif
	if (strcmp(kw, word) == 0) {
		*tp = *curr_ptr;
		return 0;
	} else
		return 1;
}","<mb:mutant#bc7a12a5aaaad5daa31ac72609aabd6612ecaa18> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -3746 +3746 @@
-	curr_ptr = &curr;
+	curr_ptr = abs(&curr);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Space.c> ."
1061,"int
GetUName(char word[UNLEN + 1], struct charac ** tp)
{
	struct charac  *curr, **curr_ptr;
	char            ch;
	int             i = 0;
	curr_ptr = &curr;
	*curr_ptr = *tp;
#ifdef DEBUG2
	printf(""\nINIZIA FUNZIONE GetUName() - scansione caratteri()\n"");
#endif
	ch = TapeGet(curr_ptr);
	while (((isletter(ch)) || (isdigit(ch))) && ((*curr_ptr) != NULL)) {
		if (i != UNLEN)
			word[i] = ch;
#ifdef DEBUG5
		printf(""\n%d %c\n"", i, word[i]);
#endif
		i = i + 1;
		ch = TapeGet(curr_ptr);
	};
	{
		if (i >= UNLEN)
			word[UNLEN] = '\0';
		else
			word[i] = '\0';
	};
	if (i > UNLEN)
		parserro(*tp, 7, word);
#ifdef DEBUG5
	printf(""\nPAROLA LETTA da GetUName:%s-%d caratteri."", word, strlen(word));
#endif
	if (strlen(word) == 0)
		return 2;
	if ((isletter(word[0])) == 0) {
		return 5;
	};
	if (InKWords(word) == 1) {
		return 6;
	};
	*tp = *curr_ptr;
	return 0;
}","<mb:mutant#e0c1c41346467c8ef0288d99bd4f86eac31fb103> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -3928 +3928 @@
-		if (i < UNLEN)
+		if (i != UNLEN)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Space.c> ."
1062,"int
InserUN(char *WORD)
{
	int             i;
#ifdef DEBUG4
	printf(""\nInserimento in tabella UserNames della parola-%s-\n"", WORD);
#endif
	if (strlen(WORD) <= 0) {
		printf(""**INTERNAL ERROR - InserUN() - empty string passed.**"");
		exit(1);
	};
	for (i = 0; (i <= UNNUM); i++) {
		if (strlen(UserNames[i]) == 0) {
			strcpy(UserNames[i], WORD);
		};
		return 0;
	};
	printf(""** Internal error ** - InserUN()-: too many user names"");
	exit(1);
	return 1;
}","<mb:mutant#09b0200420672a0eb474e8134c33225e09a8703f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -5124 +5124 @@
-	if (strlen(WORD) == 0) {
+	if (strlen(WORD) <= 0) {
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Space.c> ."
1065,"int
GetUName(char word[UNLEN + 1], struct charac ** tp)
{
	struct charac  *curr, **curr_ptr;
	char            ch;
	int             i = 0;
	curr_ptr = &curr;
	*curr_ptr = abs(*tp);
#ifdef DEBUG2
	printf(""\nINIZIA FUNZIONE GetUName() - scansione caratteri()\n"");
#endif
	ch = TapeGet(curr_ptr);
	while (((isletter(ch)) || (isdigit(ch))) && ((*curr_ptr) != NULL)) {
		if (i < UNLEN)
			word[i] = ch;
#ifdef DEBUG5
		printf(""\n%d %c\n"", i, word[i]);
#endif
		i = i + 1;
		ch = TapeGet(curr_ptr);
	};
	{
		if (i >= UNLEN)
			word[UNLEN] = '\0';
		else
			word[i] = '\0';
	};
	if (i > UNLEN)
		parserro(*tp, 7, word);
#ifdef DEBUG5
	printf(""\nPAROLA LETTA da GetUName:%s-%d caratteri."", word, strlen(word));
#endif
	if (strlen(word) == 0)
		return 2;
	if ((isletter(word[0])) == 0) {
		return 5;
	};
	if (InKWords(word) == 1) {
		return 6;
	};
	*tp = *curr_ptr;
	return 0;
}","<mb:mutant#61ec1792e0a4607c798d0a305b5933de30893c5f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -3921 +3921 @@
-	*curr_ptr = *tp;
+	*curr_ptr = abs(*tp);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Space.c> ."
1066,"int
InUNames(char *WORD)
{
	int             i;
#ifdef DEBUG4
	printf(""\nRICERCA IN TABELLA UserNames [] della parola-%s-\n"", WORD);
#endif
	if (strlen(WORD) == 0) {
		printf(""**INTERNAL ERROR - InUNames() - empty string passed.**"");
		exit(1);
	};
	for (i = 0; i <= UNNUM; i++) {
#ifdef DEBUG4
		printf(""UserNames[%d]-%s-\n"", i, UserNames[i]);
#endif
		if ((strcmp(WORD, UserNames[i])) == 0)
			return 1;
	};
	return 0;
}",
1067,"int
InUNames(char *WORD)
{
	int             i;
#ifdef DEBUG4
	printf(""\nRICERCA IN TABELLA UserNames [] della parola-%s-\n"", WORD);
#endif
	if (strlen(WORD) <= 0) {
		printf(""**INTERNAL ERROR - InUNames() - empty string passed.**"");
		exit(1);
	};
	for (i = 0; i <= UNNUM; i++) {
#ifdef DEBUG4
		printf(""UserNames[%d]-%s-\n"", i, UserNames[i]);
#endif
		if ((strcmp(WORD, UserNames[i])) == 0)
			return 1;
	};
	return 0;
}","<mb:mutant#975691cc8f51eded52553264a94926bf594e9aac> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -5192 +5192 @@
-	if (strlen(WORD) == 0) {
+	if (strlen(WORD) <= 0) {
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Space.c> ."
1068,"char
TapeGet(struct charac ** tp)
{
	char            ch;
	if (*tp == NULL)
		ch = '\0';
	else {
		ch = (*tp)->info;
		(*tp) = (*tp)->NEXT;
	};
	return abs(ch);
}","<mb:mutant#e113818e811555cff0865c7b14750d10e9435c36> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -9116 +9116 @@
-	return ch;
+	return abs(ch);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Space.c> ."
1069,"void
prnfile(struct charac * firstel)
{
	struct charac  *p;
	char            ch = ' ';
	int             line_num = 0;
#ifdef DEBUG3
	printf(""\nprnfile() - input file content. "");
#endif
	printf(""\n"");
	p = firstel;
	while ((p->NEXT) != NULL) {
		ch = p->info--;
		if (p->LINE_NUM > line_num) {
			line_num = p->LINE_NUM;
			printf(""\n%4d\t"", line_num);
		}
		putchar(ch);
		p = p->NEXT;
	};
	printf(""\n"");
	return;
}","<mb:mutant#4aed04d26e985aeafbf662f327df4939fe3df10c> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -6991 +6991 @@
-		ch = p->info;
+		ch = p->info--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Space.c> ."
1070,"int
GetUName(char word[UNLEN + 1], struct charac ** tp)
{
	struct charac  *curr, **curr_ptr;
	char            ch;
	int             i = 0;
	curr_ptr = &curr;
	*curr_ptr = *tp;
#ifdef DEBUG2
	printf(""\nINIZIA FUNZIONE GetUName() - scansione caratteri()\n"");
#endif
	ch = TapeGet(curr_ptr);
	while (((isletter(ch)) || (isdigit(ch))) && ((*curr_ptr) != NULL)) {
		if (i < UNLEN)
			word[i] = ch;
#ifdef DEBUG5
		printf(""\n%d %c\n"", i, word[i]);
#endif
		i = i + 1;
		ch = TapeGet(curr_ptr);
	};
	{
		if (i > UNLEN)
			word[UNLEN] = '\0';
		else
			word[i] = '\0';
	};
	if (i > UNLEN)
		parserro(*tp, 7, word);
#ifdef DEBUG5
	printf(""\nPAROLA LETTA da GetUName:%s-%d caratteri."", word, strlen(word));
#endif
	if (strlen(word) == 0)
		return 2;
	if ((isletter(word[0])) == 0) {
		return 5;
	};
	if (InKWords(word) == 1) {
		return 6;
	};
	*tp = *curr_ptr;
	return 0;
}","<mb:mutant#bda8bccf14e8c1a8a731b2ec07f77aae562a98c4> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -3938 +3938 @@
-		if (i >= UNLEN)
+		if (i > UNLEN)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Space.c> ."
1072,"int
GetUName(char word[UNLEN + 1], struct charac ** tp)
{
	struct charac  *curr, **curr_ptr;
	char            ch;
	int             i = 0;
	curr_ptr = &curr;
	*curr_ptr = *tp;
#ifdef DEBUG2
	printf(""\nINIZIA FUNZIONE GetUName() - scansione caratteri()\n"");
#endif
	ch = TapeGet(curr_ptr);
	while (((isletter(ch)) || (isdigit(ch))) && ((*curr_ptr) != NULL)) {
		if (i < UNLEN)
			word[i] = ch;
#ifdef DEBUG5
		printf(""\n%d %c\n"", i, word[i]);
#endif
		i = i + 1;
		ch = TapeGet(curr_ptr);
	};
	{
		if (i >= UNLEN)
			word[UNLEN] = '\0';
		else
			word[i] = '\0';
	};
	if (i > UNLEN)
		parserro(*tp, 7, word);
#ifdef DEBUG5
	printf(""\nPAROLA LETTA da GetUName:%s-%d caratteri."", word, strlen(word));
#endif
	if (strlen(word) == 0)
		return 2;
	if ((isletter(word[0])) == 0) {
		return 5;
	};
	if (InKWords(word) == 1) {
		return 6;
	};
	*tp = abs(*curr_ptr);
	return 0;
}","<mb:mutant#ae0b0d0303d73317a8f17214e29de4fc7f025af2> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -3967 +3967 @@
-	*tp = *curr_ptr;
+	*tp = abs(*curr_ptr);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Space.c> ."
1074,"int
InserUN(char *WORD)
{
	int             i;
#ifdef DEBUG4
	printf(""\nInserimento in tabella UserNames della parola-%s-\n"", WORD);
#endif
	if (strlen(WORD) == 0) {
		printf(""**INTERNAL ERROR - InserUN() - empty string passed.**"");
		exit(1);
	};
	for (i = 0; (i <= UNNUM); i++) {
		if (strlen(UserNames[i]) <= 0) {
			strcpy(UserNames[i], WORD);
		};
		return 0;
	};
	printf(""** Internal error ** - InserUN()-: too many user names"");
	exit(1);
	return 1;
}","<mb:mutant#2b0bee9739b2751a0d0e52792cf212239c5024f1> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -5130 +5130 @@
-		if (strlen(UserNames[i]) == 0) {
+		if (strlen(UserNames[i]) <= 0) {
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Space.c> ."
1076,"int
InKWords(char *WORD)
{
	int             i;
#ifdef DEBUG3
	printf(""\nRICERCA IN TABELLA KeyWords della parola-%s-\n"", WORD);
#endif
	if (strlen(WORD) == 0) {
		printf(""**INTERNAL ERROR - InKWords() - empty string passed.**"");
		exit(1);
	};
	for (i = 0; i <= KWDSNUM; i++) {
#ifdef DEBUG5
		printf(""Keywords[%d]-%s-\n"", i, Keywords[i]);
#endif
		if ((strcmp(WORD, Keywords[i])) == 0)
			return 1;
	};
	return 0;
}",
1077,"int
InKWords(char *WORD)
{
	int             i;
#ifdef DEBUG3
	printf(""\nRICERCA IN TABELLA KeyWords della parola-%s-\n"", WORD);
#endif
	if (strlen(WORD) <= 0) {
		printf(""**INTERNAL ERROR - InKWords() - empty string passed.**"");
		exit(1);
	};
	for (i = 0; i <= KWDSNUM; i++) {
#ifdef DEBUG5
		printf(""Keywords[%d]-%s-\n"", i, Keywords[i]);
#endif
		if ((strcmp(WORD, Keywords[i])) == 0)
			return 1;
	};
	return 0;
}","<mb:mutant#59a3198d3e983ad9b08a56a3abecc81d7cef830e> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -5098 +5098 @@
-	if (strlen(WORD) == 0) {
+	if (strlen(WORD) <= 0) {
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Space.c> ."
1078,"char
TapeGet(struct charac ** tp)
{
	char            ch;
	if (*tp <= NULL)
		ch = '\0';
	else {
		ch = (*tp)->info;
		(*tp) = (*tp)->NEXT;
	};
	return ch;
}","<mb:mutant#2d5cd06145f09391ba9e55bfe6b5ce64c6677f1b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -9110 +9110 @@
-	if (*tp == NULL)
+	if (*tp <= NULL)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Space.c> ."
1079,"void
prnfile(struct charac * firstel)
{
	struct charac  *p;
	char            ch = ' ';
	int             line_num = 0;
#ifdef DEBUG3
	printf(""\nprnfile() - input file content. "");
#endif
	printf(""\n"");
	p = firstel;
	while ((p->NEXT) > NULL) {
		ch = p->info;
		if (p->LINE_NUM > line_num) {
			line_num = p->LINE_NUM;
			printf(""\n%4d\t"", line_num);
		}
		putchar(ch);
		p = p->NEXT;
	};
	printf(""\n"");
	return;
}","<mb:mutant#73b09faa7f113c6fb4f5e0105ee7dde362aaaab2> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -6990 +6990 @@
-	while ((p->NEXT) != NULL) {
+	while ((p->NEXT) > NULL) {
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Space.c> ."
1083,"int
GetKeyword(char *kw, struct charac ** tp)
{
	struct charac  *curr, **curr_ptr;
	char            word[KWDSLEN + 1], ch;
	int             i = 0;
#ifdef DEBUG2
	printf(""Funzione GetKeyword() - cerco kwd:>%s<\n"", kw);
#endif
#ifdef DEBUG5
	printf(""\nScansione caratteri\n"");
#endif
	curr_ptr = &curr;
	*curr_ptr = *tp;
	ch = TapeGet(curr_ptr);
#ifdef DEBUG5
	printf(""ch=>%c<"", ch);
#endif
	while (((isalnum(ch)) || (ch == '_')) && (i != KWDSLEN) && ((*curr_ptr) != NULL)) {
		word[i] = ch;
#ifdef DEBUG5
		printf(""    word[%d]=>%c<\n"", i, word[i]);
#endif
		i = i + 1;
		ch = TapeGet(curr_ptr);
#ifdef DEBUG5
		printf(""ch=>%c<"", ch);
#endif
	};
	word[i] = '\0';
#ifdef DEBUG5
	printf(""\nPAROLA LETTA da GetKeyword:>%s<\n"", word);
#endif
	if (strcmp(kw, word) == 0) {
		*tp = *curr_ptr;
		return 0;
	} else
		return 1;
}","<mb:mutant#cde781df9ce3058cf965fde34764699c091c3481> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -3757 +3757 @@
-	while (((isalnum(ch)) || (ch == '_')) && (i < KWDSLEN) && ((*curr_ptr) != NULL)) {
+	while (((isalnum(ch)) || (ch == '_')) && (i != KWDSLEN) && ((*curr_ptr) != NULL)) {
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Space.c> ."
1084,"void
parserro(struct charac * err_ptr, int errcode, char *s)
{
	struct charac  *p;
	int             n = 0, i;
	static int      errline_printed = NO;
	p = err_ptr;
	if (!errline_printed) {
		errline_printed = YES;
		printf(""\nError occurred at line %d"", err_ptr->LINE_NUM);
		while ((p->PREV != NULL) && ((p->PREV)->LINE_NUM == err_ptr->LINE_NUM)) {
			n++;
			p = p->PREV;
		};
		printf(""\n%4d:\t"", p->LINE_NUM);
		while ((p != NULL) && (p->LINE_NUM <= err_ptr->LINE_NUM)) {
			printf(""%c"", p->info);
			p = p->NEXT;
		};
		printf(""\n%    \t"");
		for (i = 1; i <= n; i++) {
			printf("" "");
		};
		printf(""^"");
	};
	if (s == NULL)
		printf(""\n%s\n"", ErrorMessages[errcode]);
	else
		printf(""\n%s%s\n"", ErrorMessages[errcode], s);
	return;
}","<mb:mutant#047f3acbbcb8ec97f1fcebb6dcbed7955cf95e3d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -6217 +6217 @@
-		while ((p != NULL) && (p->LINE_NUM == err_ptr->LINE_NUM)) {
+		while ((p != NULL) && (p->LINE_NUM <= err_ptr->LINE_NUM)) {
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Space.c> ."
1086,"void
parserro(struct charac * err_ptr, int errcode, char *s)
{
	struct charac  *p;
	int             n = 0, i;
	static int      errline_printed = NO;
	p = err_ptr;
	if (!errline_printed) {
		errline_printed = YES;
		printf(""\nError occurred at line %d"", err_ptr->LINE_NUM);
		while ((p->PREV != NULL) && ((p->PREV)->LINE_NUM == err_ptr->LINE_NUM)) {
			n++;
			p = p->PREV;
		};
		printf(""\n%4d:\t"", p->LINE_NUM);
		while ((p > NULL) && (p->LINE_NUM == err_ptr->LINE_NUM)) {
			printf(""%c"", p->info);
			p = p->NEXT;
		};
		printf(""\n%    \t"");
		for (i = 1; i <= n; i++) {
			printf("" "");
		};
		printf(""^"");
	};
	if (s == NULL)
		printf(""\n%s\n"", ErrorMessages[errcode]);
	else
		printf(""\n%s%s\n"", ErrorMessages[errcode], s);
	return;
}","<mb:mutant#0adc438ed2da2f5d21e65724b171740164eaf4c7> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -6217 +6217 @@
-		while ((p != NULL) && (p->LINE_NUM == err_ptr->LINE_NUM)) {
+		while ((p > NULL) && (p->LINE_NUM == err_ptr->LINE_NUM)) {
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Space.c> ."
1088,"void
prnfile(struct charac * firstel)
{
	struct charac  *p;
	char            ch = ' ';
	int             line_num = 0;
#ifdef DEBUG3
	printf(""\nprnfile() - input file content. "");
#endif
	printf(""\n"");
	p = firstel;
	while ((p->NEXT) != NULL) {
		ch = p->info;
		if (p->LINE_NUM > line_num) {
			line_num = p->LINE_NUM++;
			printf(""\n%4d\t"", line_num);
		}
		putchar(ch);
		p = p->NEXT;
	};
	printf(""\n"");
	return;
}","<mb:mutant#13a268ff6e78e5281573b46e5735e74e28c63779> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -6994 +6994 @@
-			line_num = p->LINE_NUM;
+			line_num = p->LINE_NUM++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Space.c> ."
1091,"int
GetKeyword(char *kw, struct charac ** tp)
{
	struct charac  *curr, **curr_ptr;
	char            word[KWDSLEN + 1], ch;
	int             i = 0;
#ifdef DEBUG2
	printf(""Funzione GetKeyword() - cerco kwd:>%s<\n"", kw);
#endif
#ifdef DEBUG5
	printf(""\nScansione caratteri\n"");
#endif
	curr_ptr = &curr;
	*curr_ptr = *tp;
	ch = TapeGet(curr_ptr);
#ifdef DEBUG5
	printf(""ch=>%c<"", ch);
#endif
	while (((isalnum(ch)) || (ch == '_')) && (i <= KWDSLEN) && ((*curr_ptr) != NULL)) {
		word[i] = ch;
#ifdef DEBUG5
		printf(""    word[%d]=>%c<\n"", i, word[i]);
#endif
		i = i + 1;
		ch = TapeGet(curr_ptr);
#ifdef DEBUG5
		printf(""ch=>%c<"", ch);
#endif
	};
	word[i] = '\0';
#ifdef DEBUG5
	printf(""\nPAROLA LETTA da GetKeyword:>%s<\n"", word);
#endif
	if (strcmp(kw, word) == 0) {
		*tp = *curr_ptr;
		return 0;
	} else
		return 1;
}","<mb:mutant#3e318813e7f63b43bf621846a273be393508e8fd> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -3757 +3757 @@
-	while (((isalnum(ch)) || (ch == '_')) && (i < KWDSLEN) && ((*curr_ptr) != NULL)) {
+	while (((isalnum(ch)) || (ch == '_')) && (i <= KWDSLEN) && ((*curr_ptr) != NULL)) {
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Space.c> ."
1094,"int
GetKeyword(char *kw, struct charac ** tp)
{
	struct charac  *curr, **curr_ptr;
	char            word[KWDSLEN + 1], ch;
	int             i = 0;
#ifdef DEBUG2
	printf(""Funzione GetKeyword() - cerco kwd:>%s<\n"", kw);
#endif
#ifdef DEBUG5
	printf(""\nScansione caratteri\n"");
#endif
	curr_ptr = &curr;
	*curr_ptr = abs(*tp);
	ch = TapeGet(curr_ptr);
#ifdef DEBUG5
	printf(""ch=>%c<"", ch);
#endif
	while (((isalnum(ch)) || (ch == '_')) && (i < KWDSLEN) && ((*curr_ptr) != NULL)) {
		word[i] = ch;
#ifdef DEBUG5
		printf(""    word[%d]=>%c<\n"", i, word[i]);
#endif
		i = i + 1;
		ch = TapeGet(curr_ptr);
#ifdef DEBUG5
		printf(""ch=>%c<"", ch);
#endif
	};
	word[i] = '\0';
#ifdef DEBUG5
	printf(""\nPAROLA LETTA da GetKeyword:>%s<\n"", word);
#endif
	if (strcmp(kw, word) == 0) {
		*tp = *curr_ptr;
		return 0;
	} else
		return 1;
}","<mb:mutant#858714894ac9293bb74736b3b4fd238159f8635d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -3747 +3747 @@
-	*curr_ptr = *tp;
+	*curr_ptr = abs(*tp);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Space.c> ."
1095,"int
GetUName(char word[UNLEN + 1], struct charac ** tp)
{
	struct charac  *curr, **curr_ptr;
	char            ch;
	int             i = 0;
	curr_ptr = &curr;
	*curr_ptr = *tp;
#ifdef DEBUG2
	printf(""\nINIZIA FUNZIONE GetUName() - scansione caratteri()\n"");
#endif
	ch = TapeGet(curr_ptr);
	while (((isletter(ch)) || (isdigit(ch))) && ((*curr_ptr) != NULL)) {
		if (i < UNLEN)
			word[i] = ch;
#ifdef DEBUG5
		printf(""\n%d %c\n"", i, word[i]);
#endif
		i = i + 1;
		ch = TapeGet(abs(curr_ptr));
	};
	{
		if (i >= UNLEN)
			word[UNLEN] = '\0';
		else
			word[i] = '\0';
	};
	if (i > UNLEN)
		parserro(*tp, 7, word);
#ifdef DEBUG5
	printf(""\nPAROLA LETTA da GetUName:%s-%d caratteri."", word, strlen(word));
#endif
	if (strlen(word) == 0)
		return 2;
	if ((isletter(word[0])) == 0) {
		return 5;
	};
	if (InKWords(word) == 1) {
		return 6;
	};
	*tp = *curr_ptr;
	return 0;
}","<mb:mutant#e1beaa5fe7e6c2f06be803bdb864bd07f58e26f7> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -3934 +3934 @@
-		ch = TapeGet(curr_ptr);
+		ch = TapeGet(abs(curr_ptr));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Space.c> ."
1096,"char
TapeGet(struct charac ** tp)
{
	char            ch;
	if (*tp == NULL)
		ch = '\0';
	else {
		ch = (*tp)->info++;
		(*tp) = (*tp)->NEXT;
	};
	return ch;
}","<mb:mutant#c74063033e4786eb7f386f1290512000d3ba4025> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -9113 +9113 @@
-		ch = (*tp)->info;
+		ch = (*tp)->info++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Space.c> ."
1097,"char
TapeGet(struct charac ** tp)
{
	char            ch;
	if (*tp == NULL)
		ch = '\0';
	else {
		ch = (*tp)->info--;
		(*tp) = (*tp)->NEXT;
	};
	return ch;
}","<mb:mutant#e02a57bc425f12783b6017da07ff863f6c4f872b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -9113 +9113 @@
-		ch = (*tp)->info;
+		ch = (*tp)->info--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Space.c> ."
1098,"int
GetUName(char word[UNLEN + 1], struct charac ** tp)
{
	struct charac  *curr, **curr_ptr;
	char            ch;
	int             i = 0;
	curr_ptr = &curr;
	*curr_ptr = *tp;
#ifdef DEBUG2
	printf(""\nINIZIA FUNZIONE GetUName() - scansione caratteri()\n"");
#endif
	ch = TapeGet(curr_ptr);
	while (((isletter(ch)) || (isdigit(ch))) && ((*curr_ptr) != NULL)) {
		if (i < UNLEN)
			word[i] = ch;
#ifdef DEBUG5
		printf(""\n%d %c\n"", i, word[i]);
#endif
		i = i + 1;
		ch = TapeGet(curr_ptr);
	};
	{
		if (i >= UNLEN)
			word[UNLEN] = '\0';
		else
			word[i] = '\0';
	};
	if (i > UNLEN)
		parserro(abs(*tp), 7, word);
#ifdef DEBUG5
	printf(""\nPAROLA LETTA da GetUName:%s-%d caratteri."", word, strlen(word));
#endif
	if (strlen(word) == 0)
		return 2;
	if ((isletter(word[0])) == 0) {
		return 5;
	};
	if (InKWords(word) == 1) {
		return 6;
	};
	*tp = *curr_ptr;
	return 0;
}","<mb:mutant#95f320d710c888efb6473696e5f68801c3b98fca> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -3945 +3945 @@
-		parserro(*tp, 7, word);
+		parserro(abs(*tp), 7, word);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Space.c> ."
1104,"int
GetKeyword(char *kw, struct charac ** tp)
{
	struct charac  *curr, **curr_ptr;
	char            word[KWDSLEN + 1], ch;
	int             i = 0;
#ifdef DEBUG2
	printf(""Funzione GetKeyword() - cerco kwd:>%s<\n"", kw);
#endif
#ifdef DEBUG5
	printf(""\nScansione caratteri\n"");
#endif
	curr_ptr = &curr;
	*curr_ptr = *tp;
	ch = TapeGet(curr_ptr);
#ifdef DEBUG5
	printf(""ch=>%c<"", ch);
#endif
	while (((isalnum(ch)) || (ch == '_')) && (i < KWDSLEN) && ((*curr_ptr) != NULL)) {
		word[i] = ch;
#ifdef DEBUG5
		printf(""    word[%d]=>%c<\n"", i, word[i]);
#endif
		i = i + 1;
		ch = TapeGet(curr_ptr);
#ifdef DEBUG5
		printf(""ch=>%c<"", ch);
#endif
	};
	word[i] = '\0';
#ifdef DEBUG5
	printf(""\nPAROLA LETTA da GetKeyword:>%s<\n"", word);
#endif
	if (strcmp(kw, word) == 0) {
		*tp = abs(*curr_ptr);
		return 0;
	} else
		return 1;
}","<mb:mutant#9d5a72c16c7bdd890411b067db2bd9d609916657> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -3778 +3778 @@
-		*tp = *curr_ptr;
+		*tp = abs(*curr_ptr);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Space.c> ."
1105,"void
prnfile(struct charac * firstel)
{
	struct charac  *p;
	char            ch = ' ';
	int             line_num = 0;
#ifdef DEBUG3
	printf(""\nprnfile() - input file content. "");
#endif
	printf(""\n"");
	p = firstel;
	while ((p->NEXT) != NULL) {
		ch = p->info;
		if (p->LINE_NUM > line_num) {
			line_num = p->LINE_NUM--;
			printf(""\n%4d\t"", line_num);
		}
		putchar(ch);
		p = p->NEXT;
	};
	printf(""\n"");
	return;
}","<mb:mutant#73bf78225a51184bae7592491996e47bf9ca72db> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -6994 +6994 @@
-			line_num = p->LINE_NUM;
+			line_num = p->LINE_NUM--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Space.c> ."
1106,"int
GetUName(char word[UNLEN + 1], struct charac ** tp)
{
	struct charac  *curr, **curr_ptr;
	char            ch;
	int             i = 0;
	curr_ptr = &curr;
	*curr_ptr = *tp;
#ifdef DEBUG2
	printf(""\nINIZIA FUNZIONE GetUName() - scansione caratteri()\n"");
#endif
	ch = TapeGet(curr_ptr);
	while (((isletter(ch)) || (isdigit(ch))) && ((*curr_ptr) > NULL)) {
		if (i < UNLEN)
			word[i] = ch;
#ifdef DEBUG5
		printf(""\n%d %c\n"", i, word[i]);
#endif
		i = i + 1;
		ch = TapeGet(curr_ptr);
	};
	{
		if (i >= UNLEN)
			word[UNLEN] = '\0';
		else
			word[i] = '\0';
	};
	if (i > UNLEN)
		parserro(*tp, 7, word);
#ifdef DEBUG5
	printf(""\nPAROLA LETTA da GetUName:%s-%d caratteri."", word, strlen(word));
#endif
	if (strlen(word) == 0)
		return 2;
	if ((isletter(word[0])) == 0) {
		return 5;
	};
	if (InKWords(word) == 1) {
		return 6;
	};
	*tp = *curr_ptr;
	return 0;
}","<mb:mutant#f1a654a51aafd00b144a03af5cae277852716c12> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -3927 +3927 @@
-	while (((isletter(ch)) || (isdigit(ch))) && ((*curr_ptr) != NULL)) {
+	while (((isletter(ch)) || (isdigit(ch))) && ((*curr_ptr) > NULL)) {
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Space.c> ."
1107,"int
GetUName(char word[UNLEN + 1], struct charac ** tp)
{
	struct charac  *curr, **curr_ptr;
	char            ch;
	int             i = 0;
	curr_ptr = &curr;
	*curr_ptr = *tp;
#ifdef DEBUG2
	printf(""\nINIZIA FUNZIONE GetUName() - scansione caratteri()\n"");
#endif
	ch = TapeGet(curr_ptr);
	while (((isletter(ch)) || (isdigit(ch))) && ((*curr_ptr) != NULL)) {
		if (i < UNLEN)
			word[i] = ch;
#ifdef DEBUG5
		printf(""\n%d %c\n"", i, word[i]);
#endif
		i = i + 1;
		ch = TapeGet(curr_ptr);
	};
	{
		if (i >= UNLEN)
			word[UNLEN] = '\0';
		else
			word[i] = '\0';
	};
	if (i > UNLEN)
		parserro(*tp, 7, abs(word));
#ifdef DEBUG5
	printf(""\nPAROLA LETTA da GetUName:%s-%d caratteri."", word, strlen(word));
#endif
	if (strlen(word) == 0)
		return 2;
	if ((isletter(word[0])) == 0) {
		return 5;
	};
	if (InKWords(word) == 1) {
		return 6;
	};
	*tp = *curr_ptr;
	return 0;
}","<mb:mutant#ca736b391cede50173a4b070d3fc0868d096a467> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -3945 +3945 @@
-		parserro(*tp, 7, word);
+		parserro(*tp, 7, abs(word));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Space.c> ."
1109,"void
parserro(struct charac * err_ptr, int errcode, char *s)
{
	struct charac  *p;
	int             n = 0, i;
	static int      errline_printed = NO;
	p = err_ptr;
	if (!errline_printed) {
		errline_printed = YES;
		printf(""\nError occurred at line %d"", err_ptr->LINE_NUM);
		while ((p->PREV > NULL) && ((p->PREV)->LINE_NUM == err_ptr->LINE_NUM)) {
			n++;
			p = p->PREV;
		};
		printf(""\n%4d:\t"", p->LINE_NUM);
		while ((p != NULL) && (p->LINE_NUM == err_ptr->LINE_NUM)) {
			printf(""%c"", p->info);
			p = p->NEXT;
		};
		printf(""\n%    \t"");
		for (i = 1; i <= n; i++) {
			printf("" "");
		};
		printf(""^"");
	};
	if (s == NULL)
		printf(""\n%s\n"", ErrorMessages[errcode]);
	else
		printf(""\n%s%s\n"", ErrorMessages[errcode], s);
	return;
}","<mb:mutant#5b203cca51ff498ba619e0dbf9d889c0792c6d39> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -6210 +6210 @@
-		while ((p->PREV != NULL) && ((p->PREV)->LINE_NUM == err_ptr->LINE_NUM)) {
+		while ((p->PREV > NULL) && ((p->PREV)->LINE_NUM == err_ptr->LINE_NUM)) {
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Space.c> ."
1110,"int
GetUName(char word[UNLEN + 1], struct charac ** tp)
{
	struct charac  *curr, **curr_ptr;
	char            ch;
	int             i = 0;
	curr_ptr = &curr;
	*curr_ptr = *tp;
#ifdef DEBUG2
	printf(""\nINIZIA FUNZIONE GetUName() - scansione caratteri()\n"");
#endif
	ch = TapeGet(curr_ptr);
	while (((isletter(ch)) || (isdigit(ch))) && ((*curr_ptr) != NULL)) {
		if (i < UNLEN)
			word[i] = ch++;
#ifdef DEBUG5
		printf(""\n%d %c\n"", i, word[i]);
#endif
		i = i + 1;
		ch = TapeGet(curr_ptr);
	};
	{
		if (i >= UNLEN)
			word[UNLEN] = '\0';
		else
			word[i] = '\0';
	};
	if (i > UNLEN)
		parserro(*tp, 7, word);
#ifdef DEBUG5
	printf(""\nPAROLA LETTA da GetUName:%s-%d caratteri."", word, strlen(word));
#endif
	if (strlen(word) == 0)
		return 2;
	if ((isletter(word[0])) == 0) {
		return 5;
	};
	if (InKWords(word) == 1) {
		return 6;
	};
	*tp = *curr_ptr;
	return 0;
}","<mb:mutant#c15782443c02880372c0da228a4a31a61ef01951> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -3929 +3929 @@
-			word[i] = ch;
+			word[i] = ch++;
@@ -9113 +9113 @@
-		ch = (*tp)->info;
+		ch = (*tp)->info++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Space.c> ."
1111,"int
GetKeyword(char *kw, struct charac ** tp)
{
	struct charac  *curr, **curr_ptr;
	char            word[KWDSLEN + 1], ch;
	int             i = 0;
#ifdef DEBUG2
	printf(""Funzione GetKeyword() - cerco kwd:>%s<\n"", kw);
#endif
#ifdef DEBUG5
	printf(""\nScansione caratteri\n"");
#endif
	curr_ptr = &curr;
	*curr_ptr = *tp;
	ch = TapeGet(curr_ptr);
#ifdef DEBUG5
	printf(""ch=>%c<"", ch);
#endif
	while (((isalnum(ch)) || (ch == '_')) && (i < KWDSLEN) && ((*curr_ptr) != NULL)) {
		word[i] = ch--;
#ifdef DEBUG5
		printf(""    word[%d]=>%c<\n"", i, word[i]);
#endif
		i = i + 1;
		ch = TapeGet(curr_ptr);
#ifdef DEBUG5
		printf(""ch=>%c<"", ch);
#endif
	};
	word[i] = '\0';
#ifdef DEBUG5
	printf(""\nPAROLA LETTA da GetKeyword:>%s<\n"", word);
#endif
	if (strcmp(kw, word) == 0) {
		*tp = *curr_ptr;
		return 0;
	} else
		return 1;
}","<mb:mutant#9d8133c919d8d4f641fd7960a753d2d7662c9aca> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -3758 +3758 @@
-		word[i] = ch;
+		word[i] = ch--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Space.c> ."
1112,"int
GetKeyword(char *kw, struct charac ** tp)
{
	struct charac  *curr, **curr_ptr;
	char            word[KWDSLEN + 1], ch;
	int             i = 0;
#ifdef DEBUG2
	printf(""Funzione GetKeyword() - cerco kwd:>%s<\n"", kw);
#endif
#ifdef DEBUG5
	printf(""\nScansione caratteri\n"");
#endif
	curr_ptr = &curr;
	*curr_ptr = *tp;
	ch = TapeGet(curr_ptr);
#ifdef DEBUG5
	printf(""ch=>%c<"", ch);
#endif
	while (((isalnum(ch)) || (ch == '_')) && (i < KWDSLEN) && ((*curr_ptr) != NULL)) {
		word[i] = ch++;
#ifdef DEBUG5
		printf(""    word[%d]=>%c<\n"", i, word[i]);
#endif
		i = i + 1;
		ch = TapeGet(curr_ptr);
#ifdef DEBUG5
		printf(""ch=>%c<"", ch);
#endif
	};
	word[i] = '\0';
#ifdef DEBUG5
	printf(""\nPAROLA LETTA da GetKeyword:>%s<\n"", word);
#endif
	if (strcmp(kw, word) == 0) {
		*tp = *curr_ptr;
		return 0;
	} else
		return 1;
}","<mb:mutant#7ac340080d3f09a1c68866778e4afc14c1cfcb51> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -3758 +3758 @@
-		word[i] = ch;
+		word[i] = ch++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Space.c> ."
1115,"int
GetUName(char word[UNLEN + 1], struct charac ** tp)
{
	struct charac  *curr, **curr_ptr;
	char            ch;
	int             i = 0;
	curr_ptr = &curr;
	*curr_ptr = *tp;
#ifdef DEBUG2
	printf(""\nINIZIA FUNZIONE GetUName() - scansione caratteri()\n"");
#endif
	ch = TapeGet(curr_ptr);
	while (((isletter(ch)) || (isdigit(ch))) && ((*curr_ptr) != NULL)) {
		if (i < UNLEN)
			word[i] = ch;
#ifdef DEBUG5
		printf(""\n%d %c\n"", i, word[i]);
#endif
		i = i + 1;
		ch = TapeGet(curr_ptr);
	};
	{
		if (i >= UNLEN)
			word[UNLEN] = '\0';
		else
			word[i] = '\0';
	};
	if (i > UNLEN)
		parserro(*tp, 7, word);
#ifdef DEBUG5
	printf(""\nPAROLA LETTA da GetUName:%s-%d caratteri."", word, strlen(word));
#endif
	if (strlen(word) == 0)
		return 2;
	if ((isletter(word[0])) == 0) {
		return 5;
	};
	if (InKWords(word) >= 1) {
		return 6;
	};
	*tp = *curr_ptr;
	return 0;
}","<mb:mutant#32ab3dcb3ce558f212e89de680a3cb3ffa9238a4> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -3961 +3961 @@
-	if (InKWords(word) == 1) {
+	if (InKWords(word) >= 1) {
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Space.c> ."
1116,"int
GetKeyword(char *kw, struct charac ** tp)
{
	struct charac  *curr, **curr_ptr;
	char            word[KWDSLEN + 1], ch;
	int             i = 0;
#ifdef DEBUG2
	printf(""Funzione GetKeyword() - cerco kwd:>%s<\n"", kw);
#endif
#ifdef DEBUG5
	printf(""\nScansione caratteri\n"");
#endif
	curr_ptr = &curr;
	*curr_ptr = *tp;
	ch = TapeGet(curr_ptr);
#ifdef DEBUG5
	printf(""ch=>%c<"", ch);
#endif
	while (((isalnum(ch)) || (ch == '_')) && (i < KWDSLEN) && ((*curr_ptr) != NULL)) {
		word[i] = ch;
#ifdef DEBUG5
		printf(""    word[%d]=>%c<\n"", i, word[i]);
#endif
		i = abs(i) + 1;
		ch = TapeGet(curr_ptr);
#ifdef DEBUG5
		printf(""ch=>%c<"", ch);
#endif
	};
	word[i] = '\0';
#ifdef DEBUG5
	printf(""\nPAROLA LETTA da GetKeyword:>%s<\n"", word);
#endif
	if (strcmp(kw, word) == 0) {
		*tp = *curr_ptr;
		return 0;
	} else
		return 1;
}","<mb:mutant#897cc00d95468b1166ab04af1e9a53155d3c8268> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -3762 +3762 @@
-		i = i + 1;
+		i = abs(i) + 1;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Space.c> ."
1117,"void
prnfile(struct charac * firstel)
{
	struct charac  *p;
	char            ch = ' ';
	int             line_num = 0;
#ifdef DEBUG3
	printf(""\nprnfile() - input file content. "");
#endif
	printf(""\n"");
	p = abs(firstel);
	while ((p->NEXT) != NULL) {
		ch = p->info;
		if (p->LINE_NUM > line_num) {
			line_num = p->LINE_NUM;
			printf(""\n%4d\t"", line_num);
		}
		putchar(ch);
		p = p->NEXT;
	};
	printf(""\n"");
	return;
}","<mb:mutant#fac7451e363a551013124738f9e44e9b733370c7> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -6989 +6989 @@
-	p = firstel;
+	p = abs(firstel);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Space.c> ."
1118,"void
parserro(struct charac * err_ptr, int errcode, char *s)
{
	struct charac  *p;
	int             n = 0, i;
	static int      errline_printed = NO;
	p = abs(err_ptr);
	if (!errline_printed) {
		errline_printed = YES;
		printf(""\nError occurred at line %d"", err_ptr->LINE_NUM);
		while ((p->PREV != NULL) && ((p->PREV)->LINE_NUM == err_ptr->LINE_NUM)) {
			n++;
			p = p->PREV;
		};
		printf(""\n%4d:\t"", p->LINE_NUM);
		while ((p != NULL) && (p->LINE_NUM == err_ptr->LINE_NUM)) {
			printf(""%c"", p->info);
			p = p->NEXT;
		};
		printf(""\n%    \t"");
		for (i = 1; i <= n; i++) {
			printf("" "");
		};
		printf(""^"");
	};
	if (s == NULL)
		printf(""\n%s\n"", ErrorMessages[errcode]);
	else
		printf(""\n%s%s\n"", ErrorMessages[errcode], s);
	return;
}","<mb:mutant#b22f89987de86b3b6a378bc9a4a24ae67c669b05> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -6200 +6200 @@
-	p = err_ptr;
+	p = abs(err_ptr);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Space.c> ."
1119,"int
GetUName(char word[UNLEN + 1], struct charac ** tp)
{
	struct charac  *curr, **curr_ptr;
	char            ch;
	int             i = 0;
	curr_ptr = &curr;
	*curr_ptr = *tp;
#ifdef DEBUG2
	printf(""\nINIZIA FUNZIONE GetUName() - scansione caratteri()\n"");
#endif
	ch = TapeGet(curr_ptr);
	while (((isletter(ch)) || (isdigit(ch))) && ((*curr_ptr) != NULL)) {
		if (i <= UNLEN)
			word[i] = ch;
#ifdef DEBUG5
		printf(""\n%d %c\n"", i, word[i]);
#endif
		i = i + 1;
		ch = TapeGet(curr_ptr);
	};
	{
		if (i >= UNLEN)
			word[UNLEN] = '\0';
		else
			word[i] = '\0';
	};
	if (i > UNLEN)
		parserro(*tp, 7, word);
#ifdef DEBUG5
	printf(""\nPAROLA LETTA da GetUName:%s-%d caratteri."", word, strlen(word));
#endif
	if (strlen(word) == 0)
		return 2;
	if ((isletter(word[0])) == 0) {
		return 5;
	};
	if (InKWords(word) == 1) {
		return 6;
	};
	*tp = *curr_ptr;
	return 0;
}","<mb:mutant#886b7f12afbbf5ef30325dfe548dcb53881ca6cf> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -3928 +3928 @@
-		if (i < UNLEN)
+		if (i <= UNLEN)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Space.c> ."
1120,"int
GetUName(char word[UNLEN + 1], struct charac ** tp)
{
	struct charac  *curr, **curr_ptr;
	char            ch;
	int             i = 0;
	curr_ptr = abs(&curr);
	*curr_ptr = *tp;
#ifdef DEBUG2
	printf(""\nINIZIA FUNZIONE GetUName() - scansione caratteri()\n"");
#endif
	ch = TapeGet(curr_ptr);
	while (((isletter(ch)) || (isdigit(ch))) && ((*curr_ptr) != NULL)) {
		if (i < UNLEN)
			word[i] = ch;
#ifdef DEBUG5
		printf(""\n%d %c\n"", i, word[i]);
#endif
		i = i + 1;
		ch = TapeGet(curr_ptr);
	};
	{
		if (i >= UNLEN)
			word[UNLEN] = '\0';
		else
			word[i] = '\0';
	};
	if (i > UNLEN)
		parserro(*tp, 7, word);
#ifdef DEBUG5
	printf(""\nPAROLA LETTA da GetUName:%s-%d caratteri."", word, strlen(word));
#endif
	if (strlen(word) == 0)
		return 2;
	if ((isletter(word[0])) == 0) {
		return 5;
	};
	if (InKWords(word) == 1) {
		return 6;
	};
	*tp = *curr_ptr;
	return 0;
}","<mb:mutant#6e3efd185b8a20013071876702dbf8139926cc45> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -3920 +3920 @@
-	curr_ptr = &curr;
+	curr_ptr = abs(&curr);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Space.c> ."
1149,"void set_input_file( file )
char *file;
{
	if ( file )
	{
		infilename = file;
		yyin = fopen( infilename, ""r"" );
		if ( yyin == NULL )
			lerrsf( ""can't open %s"", file );
	}
	else
	{
		yyin = stdin;
		infilename = ""<stdin>"";
	}
}",
1150,"void set_input_file( file )
char *file;
{
	if ( file )
	{
		infilename = file;
		yyin = fopen( infilename, ""r"" );
		if ( yyin <= NULL )
			lerrsf( ""can't open %s"", file );
	}
	else
	{
		yyin = stdin;
		infilename = ""<stdin>"";
	}
}","<mb:mutant#bdab603145c1438eeb296216d82e6b2087216553> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -1558 +1558 @@
-		if ( yyin == NULL )
+		if ( yyin <= NULL )
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Flex.c> ."
1160,"int main(I,J)
int I,J;
{
	int Min;
    Min = I;
    if(J<I)
 	   Min=J;
    return Min;
}",
1161,"int main(I,J)
int I,J;
{
	int Min;
    Min = I;
    if(J<++I)
 	   Min=J;
    return Min;
}","<mb:mutant#83e7cee3bbc9ff118f4b1a65ff15d540a776b35c> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -7 +7 @@
-    if(J<I)
+    if(J<++I)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Min.c> ."
1162,"int main(I,J)
int I,J;
{
	int Min;
    Min = I;
    if(J<I)
 	   Min=J;
    return Min++;
}","<mb:mutant#90efc8e73f42824a5b95170478cfcbccc5984cd6> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -9 +9 @@
-    return Min;
+    return Min++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Min.c> ."
1163,"int main(I,J)
int I,J;
{
	int Min;
    Min = I;
    if(J<I--)
 	   Min=J;
    return Min;
}","<mb:mutant#254dda7417224b9ed76c7980fbf149a62c90757f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -7 +7 @@
-    if(J<I)
+    if(J<I--)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Min.c> ."
1164,"int main(I,J)
int I,J;
{
	int Min;
    Min = I;
    if(J<I)
 	   Min=J--;
    return Min;
}","<mb:mutant#5f08799bce76e6fc2b138581b229e4643f3fa8b1> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -8 +8 @@
- 	   Min=J;
+ 	   Min=J--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Min.c> ."
1165,"int main(I,J)
int I,J;
{
	int Min;
    Min = I--;
    if(J<I)
 	   Min=J;
    return Min;
}","<mb:mutant#43f6e7bcf8d3ea0613c289b8857d7ddce091882b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -6 +6 @@
-    Min = I;
+    Min = I--;
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Min.c> ."
1166,"int main(I,J)
int I,J;
{
	int Min;
    Min = I;
    if(J<--I)
 	   Min=J;
    return Min;
}","<mb:mutant#a9e4779338354b682a1f2f2fab695e3a3f855b11> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -7 +7 @@
-    if(J<I)
+    if(J<--I)
"""""" ;
    mb:equivalence ""false""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Min.c> ."
1167,"int main(I,J)
int I,J;
{
	int Min;
    Min = I;
    if(J<I++)
 	   Min=J;
    return Min;
}","<mb:mutant#e79f20030df2bcf2053773b6588e6ee9ce8c1d0b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -7 +7 @@
-    if(J<I)
+    if(J<I++)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Min.c> ."
1168,"int main(I,J)
int I,J;
{
	int Min;
    Min = I++;
    if(J<I)
 	   Min=J;
    return Min;
}","<mb:mutant#c05ccefc97defeec93f9c89b8b072cc27034de0a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -6 +6 @@
-    Min = I;
+    Min = I++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Min.c> ."
1169,"int main(I,J)
int I,J;
{
	int Min;
    Min = I;
    if(J<=I)
 	   Min=J;
    return Min;
}","<mb:mutant#0f1c5b2a55b71930d3aec06f732a392f76362a0a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -7 +7 @@
-    if(J<I)
+    if(J<=I)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Min.c> ."
1170,"int main(I,J)
int I,J;
{
	int Min;
    Min = I;
    if(J<I)
 	   Min=J;
    return Min--;
}","<mb:mutant#4df10887f02e725337f76f8a4e48bfcf8682edd5> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -9 +9 @@
-    return Min;
+    return Min--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Min.c> ."
1171,"int main(I,J)
int I,J;
{
	int Min;
    Min = I;
    if(J<I)
 	   Min=J++;
    return Min;
}","<mb:mutant#0b9a957a343d247ab747e93dd219bacdcec6541c> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -8 +8 @@
- 	   Min=J;
+ 	   Min=J++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Min.c> ."
1172,"{
	int  days_in_month,      
         day,        
         month;      
     fprintf (fout,""                   %d"", year);
     for ( month = 1; month <= 12; month++ ) {
          switch ( month ) {  
          case 1:
               fprintf(fout,""\n\nJanuary"" );
               days_in_month = 31;
               break;
          case 2:
               fprintf(fout,""\n\nFebruary"" );
               days_in_month = leap_year ? 29 : 28;
               break;
          case 3:
               fprintf(fout, ""\n\nMarch"" );
               days_in_month = 31;
               break;
          case 4:
               fprintf(fout,""\n\nApril"" );
               days_in_month = 30;
               break;
          case 5:
               fprintf(fout,""\n\nMay"" );
               days_in_month = 31;
               break;
          case 6:
               fprintf(fout,""\n\nJune"" );
               days_in_month = 30;
               break;
          case 7:
               fprintf(fout,""\n\nJuly"" );
               days_in_month = 31;
               break;
          case 8:
               fprintf(fout,""\n\nAugust"" );
               days_in_month = 31;
               break;
          case 9:
               fprintf(fout,""\n\nSeptember"" );
               days_in_month = 30;
               break;
          case 10:
               fprintf(fout,""\n\nOctober"" );
               days_in_month = 31;
               break;
          case 11:
               fprintf(fout,""\n\nNovember"" );
               days_in_month = 30;
               break;
          case 12:
               fprintf(fout,""\n\nDecember"" );
               days_in_month = 31;
               break;
          }
          fprintf(fout,""\n\nSun  Mon  Tue  Wed  Thu  Fri  Sat\n"" );
          for ( day = 1; day <= 1 + day_code * 5; day++ )
               fprintf(fout,"" "" );
          for ( day = 1; day <= days_in_month; day++ ) {
               fprintf(fout,""%2d"", day );
               if ( ( day + day_code ) % 7 > 0 )  
                    fprintf(fout,""   "" );
               else   
                    fprintf(fout, ""\n "" );
          }
          day_code = ( day_code + days_in_month ) % 7;
     }
}",
1173,"{
	int  days_in_month,      
         day,        
         month;      
     fprintf (fout,""                   %d"", year);
     for ( month = 1; month <= 12; month++ ) {
          switch ( month ) {  
          case 1:
               fprintf(fout,""\n\nJanuary"" );
               days_in_month = 31;
               break;
          case 2:
               fprintf(fout,""\n\nFebruary"" );
               days_in_month = leap_year ? 29 : 28;
               break;
          case 3:
               fprintf(fout, ""\n\nMarch"" );
               days_in_month = 31;
               break;
          case 4:
               fprintf(fout,""\n\nApril"" );
               days_in_month = 30;
               break;
          case 5:
               fprintf(fout,""\n\nMay"" );
               days_in_month = 31;
               break;
          case 6:
               fprintf(fout,""\n\nJune"" );
               days_in_month = 30;
               break;
          case 7:
               fprintf(fout,""\n\nJuly"" );
               days_in_month = 31;
               break;
          case 8:
               fprintf(fout,""\n\nAugust"" );
               days_in_month = 31;
               break;
          case 9:
               fprintf(fout,""\n\nSeptember"" );
               days_in_month = 30;
               break;
          case 10:
               fprintf(fout,""\n\nOctober"" );
               days_in_month = 31;
               break;
          case 11:
               fprintf(fout,""\n\nNovember"" );
               days_in_month = 30;
               break;
          case 12:
               fprintf(fout,""\n\nDecember"" );
               days_in_month = 31;
               break;
          }
          fprintf(fout,""\n\nSun  Mon  Tue  Wed  Thu  Fri  Sat\n"" );
          for ( day = 1; day <= 1 + day_code * 5; day++ )
               fprintf(fout,"" "" );
          for ( day = 1; day <= days_in_month; day++ ) {
               fprintf(fout,""%2d"", day );
               if ( ( day + day_code ) % 7 > 0 )  
                    fprintf(fout,""   "" );
               else   
                    fprintf(fout, ""\n "" );
          }
          day_code = ( day_code + days_in_month-- ) % 7;
     }
}","<mb:mutant#1d43630ec9a545b407de172e9bc5a46fe7be2382> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -135 +135 @@
-          day_code = ( day_code + days_in_month ) % 7;
+          day_code = ( day_code + days_in_month-- ) % 7;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Calendar.c> ."
1174,"{
	int  days_in_month,      
         day,        
         month;      
     fprintf (fout,""                   %d"", year);
     for ( month = 1; month <= 12; month++ ) {
          switch ( month ) {  
          case 1:
               fprintf(fout,""\n\nJanuary"" );
               days_in_month = 31;
               break;
          case 2:
               fprintf(fout,""\n\nFebruary"" );
               days_in_month = leap_year ? 29 : 28;
               break;
          case 3:
               fprintf(fout, ""\n\nMarch"" );
               days_in_month = 31;
               break;
          case 4:
               fprintf(fout,""\n\nApril"" );
               days_in_month = 30;
               break;
          case 5:
               fprintf(fout,""\n\nMay"" );
               days_in_month = 31;
               break;
          case 6:
               fprintf(fout,""\n\nJune"" );
               days_in_month = 30;
               break;
          case 7:
               fprintf(fout,""\n\nJuly"" );
               days_in_month = 31;
               break;
          case 8:
               fprintf(fout,""\n\nAugust"" );
               days_in_month = 31;
               break;
          case 9:
               fprintf(fout,""\n\nSeptember"" );
               days_in_month = 30;
               break;
          case 10:
               fprintf(fout,""\n\nOctober"" );
               days_in_month = 31;
               break;
          case 11:
               fprintf(fout,""\n\nNovember"" );
               days_in_month = 30;
               break;
          case 12:
               fprintf(fout,""\n\nDecember"" );
               days_in_month = 31;
               break;
          }
          fprintf(fout,""\n\nSun  Mon  Tue  Wed  Thu  Fri  Sat\n"" );
          for ( day = 1; day <= 1 + day_code * 5; day++ )
               fprintf(fout,"" "" );
          for ( day = 1; day <= days_in_month; day++ ) {
               fprintf(fout,""%2d"", day );
               if ( ( day + day_code ) % 7 > 0 )  
                    fprintf(fout,""   "" );
               else   
                    fprintf(fout, ""\n "" );
          }
          day_code = ( day_code + days_in_month ) % 7;
     }
}",
1175,"{
	int  days_in_month,      
         day,        
         month;      
     fprintf (fout,""                   %d"", year);
     for ( month = 1; month <= 12; month++ ) {
          switch ( month ) {  
          case 1:
               fprintf(fout,""\n\nJanuary"" );
               days_in_month = 31;
               break;
          case 2:
               fprintf(fout,""\n\nFebruary"" );
               days_in_month = leap_year ? 29 : 28;
               break;
          case 3:
               fprintf(fout, ""\n\nMarch"" );
               days_in_month = 31;
               break;
          case 4:
               fprintf(fout,""\n\nApril"" );
               days_in_month = 30;
               break;
          case 5:
               fprintf(fout,""\n\nMay"" );
               days_in_month = 31;
               break;
          case 6:
               fprintf(fout,""\n\nJune"" );
               days_in_month = 30;
               break;
          case 7:
               fprintf(fout,""\n\nJuly"" );
               days_in_month = 31;
               break;
          case 8:
               fprintf(fout,""\n\nAugust"" );
               days_in_month = 31;
               break;
          case 9:
               fprintf(fout,""\n\nSeptember"" );
               days_in_month = 30;
               break;
          case 10:
               fprintf(fout,""\n\nOctober"" );
               days_in_month = 31;
               break;
          case 11:
               fprintf(fout,""\n\nNovember"" );
               days_in_month = 30;
               break;
          case 12:
               fprintf(fout,""\n\nDecember"" );
               days_in_month = 31;
               break;
          }
          fprintf(fout,""\n\nSun  Mon  Tue  Wed  Thu  Fri  Sat\n"" );
          for ( day = 1; day <= 1 + day_code * 5; day++ )
               fprintf(fout,"" "" );
          for ( day = 1; day <= days_in_month; day++ ) {
               fprintf(fout,""%2d"", day );
               if ( ( day + day_code ) % 7 > 0 )  
                    fprintf(fout,""   "" );
               else   
                    fprintf(fout, ""\n "" );
          }
          day_code = ( day_code-- + days_in_month ) % 7;
     }
}","<mb:mutant#5b1d2d797da467b18a8eb961d5d00842fe1a6797> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -135 +135 @@
-          day_code = ( day_code + days_in_month ) % 7;
+          day_code = ( day_code-- + days_in_month ) % 7;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Calendar.c> ."
1176,"{
	int  days_in_month,      
         day,        
         month;      
     fprintf (fout,""                   %d"", year);
     for ( month = 1; month <= 12; month++ ) {
          switch ( month ) {  
          case 1:
               fprintf(fout,""\n\nJanuary"" );
               days_in_month = 31;
               break;
          case 2:
               fprintf(fout,""\n\nFebruary"" );
               days_in_month = leap_year ? 29 : 28;
               break;
          case 3:
               fprintf(fout, ""\n\nMarch"" );
               days_in_month = 31;
               break;
          case 4:
               fprintf(fout,""\n\nApril"" );
               days_in_month = 30;
               break;
          case 5:
               fprintf(fout,""\n\nMay"" );
               days_in_month = 31;
               break;
          case 6:
               fprintf(fout,""\n\nJune"" );
               days_in_month = 30;
               break;
          case 7:
               fprintf(fout,""\n\nJuly"" );
               days_in_month = 31;
               break;
          case 8:
               fprintf(fout,""\n\nAugust"" );
               days_in_month = 31;
               break;
          case 9:
               fprintf(fout,""\n\nSeptember"" );
               days_in_month = 30;
               break;
          case 10:
               fprintf(fout,""\n\nOctober"" );
               days_in_month = 31;
               break;
          case 11:
               fprintf(fout,""\n\nNovember"" );
               days_in_month = 30;
               break;
          case 12:
               fprintf(fout,""\n\nDecember"" );
               days_in_month = 31;
               break;
          }
          fprintf(fout,""\n\nSun  Mon  Tue  Wed  Thu  Fri  Sat\n"" );
          for ( day = 1; day <= 1 + day_code * 5; day++ )
               fprintf(fout,"" "" );
          for ( day = 1; day <= days_in_month; day++ ) {
               fprintf(fout,""%2d"", day );
               if ( ( day + day_code ) % 7 > 0 )  
                    fprintf(fout,""   "" );
               else   
                    fprintf(fout, ""\n "" );
          }
          day_code = ( day_code + days_in_month ) % 7;
     }
}",
1177,"{
	int  days_in_month,      
         day,        
         month;      
     fprintf (fout,""                   %d"", year);
     for ( month = 1; month <= 12; month++ ) {
          switch ( month ) {  
          case 1:
               fprintf(fout,""\n\nJanuary"" );
               days_in_month = 31;
               break;
          case 2:
               fprintf(fout,""\n\nFebruary"" );
               days_in_month = leap_year ? 29 : 28;
               break;
          case 3:
               fprintf(fout, ""\n\nMarch"" );
               days_in_month = 31;
               break;
          case 4:
               fprintf(fout,""\n\nApril"" );
               days_in_month = 30;
               break;
          case 5:
               fprintf(fout,""\n\nMay"" );
               days_in_month = 31;
               break;
          case 6:
               fprintf(fout,""\n\nJune"" );
               days_in_month = 30;
               break;
          case 7:
               fprintf(fout,""\n\nJuly"" );
               days_in_month = 31;
               break;
          case 8:
               fprintf(fout,""\n\nAugust"" );
               days_in_month = 31;
               break;
          case 9:
               fprintf(fout,""\n\nSeptember"" );
               days_in_month = 30;
               break;
          case 10:
               fprintf(fout,""\n\nOctober"" );
               days_in_month = 31;
               break;
          case 11:
               fprintf(fout,""\n\nNovember"" );
               days_in_month = 30;
               break;
          case 12:
               fprintf(fout,""\n\nDecember"" );
               days_in_month = 31;
               break;
          }
          fprintf(fout,""\n\nSun  Mon  Tue  Wed  Thu  Fri  Sat\n"" );
          for ( day = 1; day <= 1 + day_code * 5; day++ )
               fprintf(fout,"" "" );
          for ( day = 1; day <= days_in_month; day++ ) {
               fprintf(fout,""%2d"", day );
               if ( ( day + day_code ) % 7 > 0 )  
                    fprintf(fout,""   "" );
               else   
                    fprintf(fout, ""\n "" );
          }
          day_code = ( day_code + days_in_month++ ) % 7;
     }
}","<mb:mutant#05b3acbd7afe685d7206703c5caf822aa42e63cd> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -135 +135 @@
-          day_code = ( day_code + days_in_month ) % 7;
+          day_code = ( day_code + days_in_month++ ) % 7;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Calendar.c> ."
1178,"{
	int  days_in_month,      
         day,        
         month;      
     fprintf (fout,""                   %d"", year);
     for ( month = 1; month <= 12; month++ ) {
          switch ( month ) {  
          case 1:
               fprintf(fout,""\n\nJanuary"" );
               days_in_month = 31;
               break;
          case 2:
               fprintf(fout,""\n\nFebruary"" );
               days_in_month = leap_year ? 29 : 28;
               break;
          case 3:
               fprintf(fout, ""\n\nMarch"" );
               days_in_month = 31;
               break;
          case 4:
               fprintf(fout,""\n\nApril"" );
               days_in_month = 30;
               break;
          case 5:
               fprintf(fout,""\n\nMay"" );
               days_in_month = 31;
               break;
          case 6:
               fprintf(fout,""\n\nJune"" );
               days_in_month = 30;
               break;
          case 7:
               fprintf(fout,""\n\nJuly"" );
               days_in_month = 31;
               break;
          case 8:
               fprintf(fout,""\n\nAugust"" );
               days_in_month = 31;
               break;
          case 9:
               fprintf(fout,""\n\nSeptember"" );
               days_in_month = 30;
               break;
          case 10:
               fprintf(fout,""\n\nOctober"" );
               days_in_month = 31;
               break;
          case 11:
               fprintf(fout,""\n\nNovember"" );
               days_in_month = 30;
               break;
          case 12:
               fprintf(fout,""\n\nDecember"" );
               days_in_month = 31;
               break;
          }
          fprintf(fout,""\n\nSun  Mon  Tue  Wed  Thu  Fri  Sat\n"" );
          for ( day = 1; day <= 1 + day_code * 5; day++ )
               fprintf(fout,"" "" );
          for ( day = 1; day <= days_in_month; day++ ) {
               fprintf(fout,""%2d"", day );
               if ( ( day + day_code ) % 7 > 0 )  
                    fprintf(fout,""   "" );
               else   
                    fprintf(fout, ""\n "" );
          }
          day_code = ( day_code + days_in_month ) % 7;
     }
}",
1179,"{
	int  days_in_month,      
         day,        
         month;      
     fprintf (fout,""                   %d"", year);
     for ( month = 1; month <= 12; month++ ) {
          switch ( month ) {  
          case 1:
               fprintf(fout,""\n\nJanuary"" );
               days_in_month = 31;
               break;
          case 2:
               fprintf(fout,""\n\nFebruary"" );
               days_in_month = leap_year ? 29 : 28;
               break;
          case 3:
               fprintf(fout, ""\n\nMarch"" );
               days_in_month = 31;
               break;
          case 4:
               fprintf(fout,""\n\nApril"" );
               days_in_month = 30;
               break;
          case 5:
               fprintf(fout,""\n\nMay"" );
               days_in_month = 31;
               break;
          case 6:
               fprintf(fout,""\n\nJune"" );
               days_in_month = 30;
               break;
          case 7:
               fprintf(fout,""\n\nJuly"" );
               days_in_month = 31;
               break;
          case 8:
               fprintf(fout,""\n\nAugust"" );
               days_in_month = 31;
               break;
          case 9:
               fprintf(fout,""\n\nSeptember"" );
               days_in_month = 30;
               break;
          case 10:
               fprintf(fout,""\n\nOctober"" );
               days_in_month = 31;
               break;
          case 11:
               fprintf(fout,""\n\nNovember"" );
               days_in_month = 30;
               break;
          case 12:
               fprintf(fout,""\n\nDecember"" );
               days_in_month = 31;
               break;
          }
          fprintf(fout,""\n\nSun  Mon  Tue  Wed  Thu  Fri  Sat\n"" );
          for ( day = 1; day <= 1 + day_code * 5; day++ )
               fprintf(fout,"" "" );
          for ( day = 1; day <= days_in_month; day++ ) {
               fprintf(fout,""%2d"", day );
               if ( ( day + day_code ) % 7 > 0 )  
                    fprintf(fout,""   "" );
               else   
                    fprintf(fout, ""\n "" );
          }
          day_code = ( day_code + abs(days_in_month) ) % 7;
     }
}","<mb:mutant#10f34ed049cae62578c74bc8b15b5167630a78c1> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -135 +135 @@
-          day_code = ( day_code + days_in_month ) % 7;
+          day_code = ( day_code + abs(days_in_month) ) % 7;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Calendar.c> ."
1180,"{
	int  days_in_month,      
         day,        
         month;      
     fprintf (fout,""                   %d"", year);
     for ( month = 1; month <= 12; month++ ) {
          switch ( month ) {  
          case 1:
               fprintf(fout,""\n\nJanuary"" );
               days_in_month = 31;
               break;
          case 2:
               fprintf(fout,""\n\nFebruary"" );
               days_in_month = leap_year ? 29 : 28;
               break;
          case 3:
               fprintf(fout, ""\n\nMarch"" );
               days_in_month = 31;
               break;
          case 4:
               fprintf(fout,""\n\nApril"" );
               days_in_month = 30;
               break;
          case 5:
               fprintf(fout,""\n\nMay"" );
               days_in_month = 31;
               break;
          case 6:
               fprintf(fout,""\n\nJune"" );
               days_in_month = 30;
               break;
          case 7:
               fprintf(fout,""\n\nJuly"" );
               days_in_month = 31;
               break;
          case 8:
               fprintf(fout,""\n\nAugust"" );
               days_in_month = 31;
               break;
          case 9:
               fprintf(fout,""\n\nSeptember"" );
               days_in_month = 30;
               break;
          case 10:
               fprintf(fout,""\n\nOctober"" );
               days_in_month = 31;
               break;
          case 11:
               fprintf(fout,""\n\nNovember"" );
               days_in_month = 30;
               break;
          case 12:
               fprintf(fout,""\n\nDecember"" );
               days_in_month = 31;
               break;
          }
          fprintf(fout,""\n\nSun  Mon  Tue  Wed  Thu  Fri  Sat\n"" );
          for ( day = 1; day <= 1 + day_code * 5; day++ )
               fprintf(fout,"" "" );
          for ( day = 1; day <= days_in_month; day++ ) {
               fprintf(fout,""%2d"", day );
               if ( ( day + day_code ) % 7 > 0 )  
                    fprintf(fout,""   "" );
               else   
                    fprintf(fout, ""\n "" );
          }
          day_code = ( day_code + days_in_month ) % 7;
     }
}",
1181,"{
	int  days_in_month,      
         day,        
         month;      
     fprintf (fout,""                   %d"", year);
     for ( month = 1; month <= 12; month++ ) {
          switch ( month ) {  
          case 1:
               fprintf(fout,""\n\nJanuary"" );
               days_in_month = 31;
               break;
          case 2:
               fprintf(fout,""\n\nFebruary"" );
               days_in_month = leap_year ? 29 : 28;
               break;
          case 3:
               fprintf(fout, ""\n\nMarch"" );
               days_in_month = 31;
               break;
          case 4:
               fprintf(fout,""\n\nApril"" );
               days_in_month = 30;
               break;
          case 5:
               fprintf(fout,""\n\nMay"" );
               days_in_month = 31;
               break;
          case 6:
               fprintf(fout,""\n\nJune"" );
               days_in_month = 30;
               break;
          case 7:
               fprintf(fout,""\n\nJuly"" );
               days_in_month = 31;
               break;
          case 8:
               fprintf(fout,""\n\nAugust"" );
               days_in_month = 31;
               break;
          case 9:
               fprintf(fout,""\n\nSeptember"" );
               days_in_month = 30;
               break;
          case 10:
               fprintf(fout,""\n\nOctober"" );
               days_in_month = 31;
               break;
          case 11:
               fprintf(fout,""\n\nNovember"" );
               days_in_month = 30;
               break;
          case 12:
               fprintf(fout,""\n\nDecember"" );
               days_in_month = 31;
               break;
          }
          fprintf(fout,""\n\nSun  Mon  Tue  Wed  Thu  Fri  Sat\n"" );
          for ( day = 1; day <= 1 + day_code * 5; day++ )
               fprintf(fout,"" "" );
          for ( day = 1; day <= days_in_month; day++ ) {
               fprintf(fout,""%2d"", day );
               if ( ( day + day_code ) % 7 > 0 )  
                    fprintf(fout,""   "" );
               else   
                    fprintf(fout, ""\n "" );
          }
          day_code = ( day_code++ + days_in_month ) % 7;
     }
}","<mb:mutant#1f80346c544861b8e30ea050737303c23d18738d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -135 +135 @@
-          day_code = ( day_code + days_in_month ) % 7;
+          day_code = ( day_code++ + days_in_month ) % 7;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Calendar.c> ."
1182,"{
	int  days_in_month,      
         day,        
         month;      
     fprintf (fout,""                   %d"", year);
     for ( month = 1; month <= 12; month++ ) {
          switch ( month ) {  
          case 1:
               fprintf(fout,""\n\nJanuary"" );
               days_in_month = 31;
               break;
          case 2:
               fprintf(fout,""\n\nFebruary"" );
               days_in_month = leap_year ? 29 : 28;
               break;
          case 3:
               fprintf(fout, ""\n\nMarch"" );
               days_in_month = 31;
               break;
          case 4:
               fprintf(fout,""\n\nApril"" );
               days_in_month = 30;
               break;
          case 5:
               fprintf(fout,""\n\nMay"" );
               days_in_month = 31;
               break;
          case 6:
               fprintf(fout,""\n\nJune"" );
               days_in_month = 30;
               break;
          case 7:
               fprintf(fout,""\n\nJuly"" );
               days_in_month = 31;
               break;
          case 8:
               fprintf(fout,""\n\nAugust"" );
               days_in_month = 31;
               break;
          case 9:
               fprintf(fout,""\n\nSeptember"" );
               days_in_month = 30;
               break;
          case 10:
               fprintf(fout,""\n\nOctober"" );
               days_in_month = 31;
               break;
          case 11:
               fprintf(fout,""\n\nNovember"" );
               days_in_month = 30;
               break;
          case 12:
               fprintf(fout,""\n\nDecember"" );
               days_in_month = 31;
               break;
          }
          fprintf(fout,""\n\nSun  Mon  Tue  Wed  Thu  Fri  Sat\n"" );
          for ( day = 1; day <= 1 + day_code * 5; day++ )
               fprintf(fout,"" "" );
          for ( day = 1; day <= days_in_month; day++ ) {
               fprintf(fout,""%2d"", day );
               if ( ( day + day_code ) % 7 > 0 )  
                    fprintf(fout,""   "" );
               else   
                    fprintf(fout, ""\n "" );
          }
          day_code = ( day_code + days_in_month ) % 7;
     }
}",
1183,"{
	int  days_in_month,      
         day,        
         month;      
     fprintf (fout,""                   %d"", year);
     for ( month = 1; month <= 12; month++ ) {
          switch ( month ) {  
          case 1:
               fprintf(fout,""\n\nJanuary"" );
               days_in_month = 31;
               break;
          case 2:
               fprintf(fout,""\n\nFebruary"" );
               days_in_month = leap_year ? 29 : 28;
               break;
          case 3:
               fprintf(fout, ""\n\nMarch"" );
               days_in_month = 31;
               break;
          case 4:
               fprintf(fout,""\n\nApril"" );
               days_in_month = 30;
               break;
          case 5:
               fprintf(fout,""\n\nMay"" );
               days_in_month = 31;
               break;
          case 6:
               fprintf(fout,""\n\nJune"" );
               days_in_month = 30;
               break;
          case 7:
               fprintf(fout,""\n\nJuly"" );
               days_in_month = 31;
               break;
          case 8:
               fprintf(fout,""\n\nAugust"" );
               days_in_month = 31;
               break;
          case 9:
               fprintf(fout,""\n\nSeptember"" );
               days_in_month = 30;
               break;
          case 10:
               fprintf(fout,""\n\nOctober"" );
               days_in_month = 31;
               break;
          case 11:
               fprintf(fout,""\n\nNovember"" );
               days_in_month = 30;
               break;
          case 12:
               fprintf(fout,""\n\nDecember"" );
               days_in_month = 31;
               break;
          }
          fprintf(fout,""\n\nSun  Mon  Tue  Wed  Thu  Fri  Sat\n"" );
          for ( day = 1; day <= 1 + day_code * 5; day++ )
               fprintf(fout,"" "" );
          for ( day = 1; day <= days_in_month; day++ ) {
               fprintf(fout,""%2d"", day );
               if ( ( day + day_code ) % 7 > 0 )  
                    fprintf(fout,""   "" );
               else   
                    fprintf(fout, ""\n "" );
          }
          day_code = ( abs(day_code) + days_in_month ) % 7;
     }
}","<mb:mutant#b9873072c273d19c0f89a45f5dcaa644469803cf> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -135 +135 @@
-          day_code = ( day_code + days_in_month ) % 7;
+          day_code = ( abs(day_code) + days_in_month ) % 7;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Calendar.c> ."
1184,"{
	int  days_in_month,      
         day,        
         month;      
     fprintf (fout,""                   %d"", year);
     for ( month = 1; month <= 12; month++ ) {
          switch ( month ) {  
          case 1:
               fprintf(fout,""\n\nJanuary"" );
               days_in_month = 31;
               break;
          case 2:
               fprintf(fout,""\n\nFebruary"" );
               days_in_month = leap_year ? 29 : 28;
               break;
          case 3:
               fprintf(fout, ""\n\nMarch"" );
               days_in_month = 31;
               break;
          case 4:
               fprintf(fout,""\n\nApril"" );
               days_in_month = 30;
               break;
          case 5:
               fprintf(fout,""\n\nMay"" );
               days_in_month = 31;
               break;
          case 6:
               fprintf(fout,""\n\nJune"" );
               days_in_month = 30;
               break;
          case 7:
               fprintf(fout,""\n\nJuly"" );
               days_in_month = 31;
               break;
          case 8:
               fprintf(fout,""\n\nAugust"" );
               days_in_month = 31;
               break;
          case 9:
               fprintf(fout,""\n\nSeptember"" );
               days_in_month = 30;
               break;
          case 10:
               fprintf(fout,""\n\nOctober"" );
               days_in_month = 31;
               break;
          case 11:
               fprintf(fout,""\n\nNovember"" );
               days_in_month = 30;
               break;
          case 12:
               fprintf(fout,""\n\nDecember"" );
               days_in_month = 31;
               break;
          }
          fprintf(fout,""\n\nSun  Mon  Tue  Wed  Thu  Fri  Sat\n"" );
          for ( day = 1; day <= 1 + day_code * 5; day++ )
               fprintf(fout,"" "" );
          for ( day = 1; day <= days_in_month; day++ ) {
               fprintf(fout,""%2d"", day );
               if ( ( day + day_code ) % 7 > 0 )  
                    fprintf(fout,""   "" );
               else   
                    fprintf(fout, ""\n "" );
          }
          day_code = ( day_code + days_in_month ) % 7;
     }
}",
1185,"{
	int  days_in_month,      
         day,        
         month;      
     fprintf (fout,""                   %d"", year);
     for ( month = 1; month <= 12; month++ ) {
          switch ( month ) {  
          case 1:
               fprintf(fout,""\n\nJanuary"" );
               days_in_month = 31;
               break;
          case 2:
               fprintf(fout,""\n\nFebruary"" );
               days_in_month = leap_year ? 29 : 28;
               break;
          case 3:
               fprintf(fout, ""\n\nMarch"" );
               days_in_month = 31;
               break;
          case 4:
               fprintf(fout,""\n\nApril"" );
               days_in_month = 30;
               break;
          case 5:
               fprintf(fout,""\n\nMay"" );
               days_in_month = 31;
               break;
          case 6:
               fprintf(fout,""\n\nJune"" );
               days_in_month = 30;
               break;
          case 7:
               fprintf(fout,""\n\nJuly"" );
               days_in_month = 31;
               break;
          case 8:
               fprintf(fout,""\n\nAugust"" );
               days_in_month = 31;
               break;
          case 9:
               fprintf(fout,""\n\nSeptember"" );
               days_in_month = 30;
               break;
          case 10:
               fprintf(fout,""\n\nOctober"" );
               days_in_month = 31;
               break;
          case 11:
               fprintf(fout,""\n\nNovember"" );
               days_in_month = 30;
               break;
          case 12:
               fprintf(fout,""\n\nDecember"" );
               days_in_month = 31;
               break;
          }
          fprintf(fout,""\n\nSun  Mon  Tue  Wed  Thu  Fri  Sat\n"" );
          for ( day = 1; day <= 1 + day_code * 5; day++ )
               fprintf(fout,"" "" );
          for ( day = 1; day <= days_in_month; day++ ) {
               fprintf(fout,""%2d"", day );
               if ( ( day + day_code ) % 7 != 0 )  
                    fprintf(fout,""   "" );
               else   
                    fprintf(fout, ""\n "" );
          }
          day_code = ( day_code + days_in_month ) % 7;
     }
}","<mb:mutant#fcff4213b0324c065a26c458eaa6c659449ed9ce> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -128 +128 @@
-               if ( ( day + day_code ) % 7 > 0 ) /* before Sat? */
+               if ( ( day + day_code ) % 7 != 0 ) /* before Sat? */
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Calendar.c> ."
1186,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1187,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e <= 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#2a8dabab2928f9a8203c91b8302edc0145a109fa> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -203 +203 @@
-							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e <= 0 && confirmation_e > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1188,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1189,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e++ > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#1e4bfcbb911042a16f2d9938f0b084f17f7a79c9> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -181 +181 @@
-					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e++ > 0 && confirmation_e > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1190,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }",
1191,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }","<mb:mutant#a25ada50805dcc55324f3a45e1da78b0ef76b794> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -144 +144 @@
-								if ( ControlElement_DEF > 0)
+								if ( ControlElement_DEF-- > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1192,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1193,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) * ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#3db6a4e7eae09d199566ba97057e150460d7f54f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -223 +223 @@
-		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
+		if (( We1_BA_DEF_ev_ctr2 ) * ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Defroster.c> ."
1194,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1195,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e == 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#2f21e35173413b8e5a0bcd1091ef71ad36f2a84a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -181 +181 @@
-					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e == 0 && confirmation_e > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1196,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{",
1197,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( ++We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{","<mb:mutant#7fcec429189b14dab0858bfd22dab21930c3dcca> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -77 +77 @@
-		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
+		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( ++We1_BA_DEF_ev_ctr3 - 1000);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1198,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1199,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && --confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#dc9cbf4658892d9db34042c37e16356b280eb02f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -181 +181 @@
-					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && --confirmation_e > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1200,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1201,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e-- > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#9f6d0cdc61d91deb72ee69b556da78793ea3e1a7> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -203 +203 @@
-							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e-- > 0 && confirmation_e > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1202,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1203,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && ++confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#b814e26b8ac2a01861c9d0f480220644a91b841b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -203 +203 @@
-							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && ++confirmation_e > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1204,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{",
1205,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( ++We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{","<mb:mutant#1256e1dc8d4316951a52dcdffd50e8bf1e91793d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -78 +78 @@
-		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
+		if ( ! ( ++We1_BA_DEF == We1_BA_DEF_ev ))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1206,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1207,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && --confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#1605725875cab62a4a384ef5c7c381d304cd8c49> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -203 +203 @@
-							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && --confirmation_e > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1208,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1209,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e <= 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#c1f701af8387c1a74f82ffe927733bced265d30c> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -181 +181 @@
-					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e <= 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1210,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{",
1211,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( --We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{","<mb:mutant#883f26bf8ffaef9593961dd854d08092098eb9af> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -77 +77 @@
-		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
+		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( --We1_BA_DEF_ev_ctr3 - 1000);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1212,"            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{
					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 )) 
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( AU8.We6_BE_CONFIRM_ON ) 
						{
							if ( ControlElement_DEF == 0) 
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;",
1213,"            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{
					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e >= 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( AU8.We6_BE_CONFIRM_ON ) 
						{
							if ( ControlElement_DEF == 0) 
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;","<mb:mutant#dba23c6d7297fb1ed215226ec829a4fceaaf5c9b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -124 +124 @@
-					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
+					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e >= 0 ) && ( ControlElement_DEF == 0 ))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1214,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{",
1215,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 + ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{","<mb:mutant#fa6c10f9280f008bd6415263260ec34e456d47ea> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -77 +77 @@
-		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
+		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 + ( We1_BA_DEF_ev_ctr3 - 1000);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Defroster.c> ."
1216,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{",
1217,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * (-abs(We1_BA_DEF_ev_ctr2)) - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{","<mb:mutant#28abae1886b100ec18547bbdd0b11a4518d9a0a1> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -77 +77 @@
-		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
+		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * (-abs(We1_BA_DEF_ev_ctr2)) - ( We1_BA_DEF_ev_ctr3 - 1000);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Defroster.c> ."
1218,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1219,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && --error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#373052b9ce2cab842e68ccda832654672a547069> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -181 +181 @@
-					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && --error_e > 0 && confirmation_e > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1220,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{",
1221,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 - We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{","<mb:mutant#b05098a1d9ae7a2ae454271681a6194f396ac1b9> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -77 +77 @@
-		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
+		We1_BA_DEF = We1_BA_DEF_ev_ctr2 - We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Defroster.c> ."
1222,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{",
1223,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF < We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{","<mb:mutant#047cc9a6ddcc31d3f822043f90075eb2620cd6cb> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -78 +78 @@
-		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
+		if ( ! ( We1_BA_DEF < We1_BA_DEF_ev ))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1224,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1225,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e != 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#064fd644bcbdef48928e318a17d816cf9d3e0eea> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -203 +203 @@
-							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e != 0 && confirmation_e > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1226,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1227,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e++ > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#30e764e4626632841b09d3c3d6923f23cf10e002> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -181 +181 @@
-					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e++ > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1228,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1229,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e++ > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#8593be171044bb351fdf9c5ccc9338036d2e7eb1> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -203 +203 @@
-							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e++ > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1230,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1231,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 - We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#80b7151c751b00c14e3048a0b7200758298ef833> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -217 +217 @@
-	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
+	if ( We1_BA_DEF_ev_ctr2 - We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Defroster.c> ."
1232,"            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{
					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 )) 
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( AU8.We6_BE_CONFIRM_ON ) 
						{
							if ( ControlElement_DEF == 0) 
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;",
1233,"            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{
					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF-- == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( AU8.We6_BE_CONFIRM_ON ) 
						{
							if ( ControlElement_DEF == 0) 
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;","<mb:mutant#d1bf2287ddf1602cf243f6db91a8dfd17cc9ca02> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -124 +124 @@
-					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
+					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF-- == 0 ))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1234,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1235,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e <= 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#79b8abeced7b8ec1d191ab9d62adf591a279e04c> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -203 +203 @@
-							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e <= 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1236,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1237,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0-- >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#a390e5c48d56bc40b432b5fed8338c38639975bc> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -203 +203 @@
-							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+							if (( We1_BA_DEF_ev_ctr0-- >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1238,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1239,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e >= 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#e98ece5fb5d2d1cd1ec370cb8e99c4ff68938308> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -203 +203 @@
-							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e >= 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1240,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1241,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( ++We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#8a82134ea1f10d8cbb902d139a37d0987819a010> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -203 +203 @@
-							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+							if (( ++We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1242,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{",
1243,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15-- )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{","<mb:mutant#9e0beb866b4837ff0e93e08a6bab5b6c545921e0> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -65 +65 @@
-		if ( Clip_15 )
+		if ( Clip_15-- )
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1244,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1245,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) * ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#389c7733c48edbbc7ab0996d67d93abbf94254e4> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -223 +223 @@
-		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
+		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) * ( We1_BA_DEF_ev_ctr5 ) == 1024)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Defroster.c> ."
1246,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1247,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request-- > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#c462a78e87191c9b8b884022da4bd2902de833d3> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -187 +187 @@
-						if ( request > 0 && ( error_e == 0))
+						if ( request-- > 0 && ( error_e == 0))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1248,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1249,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 > (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#02ecd920a1345ce17706f917d2a3229aec1bfc99> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -181 +181 @@
-					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+					if (( We1_BA_DEF_ev_ctr0 > (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1250,"            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{
					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 )) 
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( AU8.We6_BE_CONFIRM_ON ) 
						{
							if ( ControlElement_DEF == 0) 
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;",
1251,"            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{
					if (( We1_BA_DEF_ev_ctr1 == (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( AU8.We6_BE_CONFIRM_ON ) 
						{
							if ( ControlElement_DEF == 0) 
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;","<mb:mutant#fa283f2a265b6e50411de7b71df3cbca6c0c295b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -124 +124 @@
-					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
+					if (( We1_BA_DEF_ev_ctr1 == (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1252,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{",
1253,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF++ == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{","<mb:mutant#5604f8eae84dbe4a5d350ce24a511055ceae75ef> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -78 +78 @@
-		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
+		if ( ! ( We1_BA_DEF++ == We1_BA_DEF_ev ))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1254,"            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{
					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 )) 
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( AU8.We6_BE_CONFIRM_ON ) 
						{
							if ( ControlElement_DEF == 0) 
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;",
1255,"            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{
					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( ++confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( AU8.We6_BE_CONFIRM_ON ) 
						{
							if ( ControlElement_DEF == 0) 
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;","<mb:mutant#cb7013fce2804fe2c2cb65cdfcfcee477c5d1396> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -124 +124 @@
-					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
+					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( ++confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1256,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1257,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && ++confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#810da63a4090f132a532c61635545faf569142f6> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -181 +181 @@
-					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && ++confirmation_e > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1258,"            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{
					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 )) 
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( AU8.We6_BE_CONFIRM_ON ) 
						{
							if ( ControlElement_DEF == 0) 
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;",
1259,"            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{
					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e < 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( AU8.We6_BE_CONFIRM_ON ) 
						{
							if ( ControlElement_DEF == 0) 
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;","<mb:mutant#1213e26d584e4eb317725ff358e5a5993b72c24a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -124 +124 @@
-					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
+					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e < 0 ) && ( ControlElement_DEF == 0 ))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1260,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{",
1261,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev-- ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{","<mb:mutant#1cd27660be5f1bcefec1d543be61b8ff83963a23> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -78 +78 @@
-		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
+		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev-- ))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1262,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1263,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0++ >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#610206707ee25403821c41cbc0343fc88389334b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -181 +181 @@
-					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+					if (( We1_BA_DEF_ev_ctr0++ >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1264,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1265,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e < 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#5dcee9ce7d3e49c42fa59724e70ffce206bf312e> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -203 +203 @@
-							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e < 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1266,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1267,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e <= 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#82ee7a4aa49c6b6559f1320c138e60da39d3f1a5> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -181 +181 @@
-					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e <= 0 && confirmation_e > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1268,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{",
1269,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * --We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{","<mb:mutant#07b92f21f36b8f3b3911442f50f1d738fa28a3f8> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -77 +77 @@
-		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
+		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * --We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1270,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1271,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e-- > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#911deb0ff34aae7d959401ab28ec901feb2c8d4a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -203 +203 @@
-							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e-- > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1272,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1273,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e == 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#838802a35b2781c5a2b958a5cfc3688f1cf5a82f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -203 +203 @@
-							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e == 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1274,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1275,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 > (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#dd3022bfa2f3a23f48282de5d1cb4cb07c601b1c> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -203 +203 @@
-							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+							if (( We1_BA_DEF_ev_ctr0 > (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1276,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1277,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 >= 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#540a78bcee739da3207679c221224cd35bae8e78> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -217 +217 @@
-	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
+	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 >= 1024)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1278,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1279,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e >= 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#14864836ac41b731d9f9a7499353d26201a40fb3> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -181 +181 @@
-					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e >= 0 && confirmation_e > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1280,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{",
1281,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( -abs(We1_BA_DEF_ev_ctr3) - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{","<mb:mutant#34832ddec9cec6ad1b688edff5cd52d31a983bcc> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -77 +77 @@
-		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
+		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( -abs(We1_BA_DEF_ev_ctr3) - 1000);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI>,
        <mb:operator#AOIU>,
        <mb:operator#AORB> ;
    mb:program <mb:program#Defroster.c> ."
1282,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1283,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e++ == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#9b1028930d735daaaa504832eb5ef2c9f28bcc80> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -197 +197 @@
-						if (( request == 0) && ( error_e == 0))
+						if (( request == 0) && ( error_e++ == 0))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1284,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{",
1285,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF <= We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{","<mb:mutant#65298b0ef53e6f829a90c1b01eca13b00f1dfada> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -78 +78 @@
-		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
+		if ( ! ( We1_BA_DEF <= We1_BA_DEF_ev ))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1286,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1287,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request <= 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#6d815199e72f19a26699ac4cacbe845eee36677f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -197 +197 @@
-						if (( request == 0) && ( error_e == 0))
+						if (( request <= 0) && ( error_e == 0))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1288,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{",
1289,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15++ )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{","<mb:mutant#e9bac19423ebc3dda816c6ac0fa3190670be830a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -65 +65 @@
-		if ( Clip_15 )
+		if ( Clip_15++ )
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1290,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1291,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e-- == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#cac64e186e817a362bb38be37e81a41454283748> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -187 +187 @@
-						if ( request > 0 && ( error_e == 0))
+						if ( request > 0 && ( error_e-- == 0))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1292,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{",
1293,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * abs(We1_BA_DEF_ev_ctr2) - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{","<mb:mutant#b5cca31fbc134154c804f4386e22e7ac1c4e3c61> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -77 +77 @@
-		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
+		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * abs(We1_BA_DEF_ev_ctr2) - ( We1_BA_DEF_ev_ctr3 - 1000);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Defroster.c> ."
1294,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{",
1295,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{","<mb:mutant#99e930ff13aee0d750e32d652e012dd2c33d9a5c> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -77 +77 @@
-		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
+		We1_BA_DEF = We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Defroster.c> ."
1296,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{",
1297,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 <= 0)
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{","<mb:mutant#8740703df80f6f2fa56e1b761cf0399aa2f349f0> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -84 +84 @@
-			if ( Clip_15 == 0)
+			if ( Clip_15 <= 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1298,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{",
1299,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev++ ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{","<mb:mutant#2984e70f38054e5a0cf935ef6d02a7d773eecb14> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -78 +78 @@
-		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
+		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev++ ))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1300,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1301,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) + ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#c2221d512ac1a7ea73f4d4fc22e19effe90d92a4> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -223 +223 @@
-		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
+		if (( We1_BA_DEF_ev_ctr2 ) + ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Defroster.c> ."
1302,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{",
1303,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF-- == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{","<mb:mutant#b727439ee67c5723d81c4bbe19279f78175e6b79> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -78 +78 @@
-		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
+		if ( ! ( We1_BA_DEF-- == We1_BA_DEF_ev ))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1304,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1305,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e < 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#822abab8d0db86faad00573499bcd1cd004de671> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -203 +203 @@
-							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e < 0 && confirmation_e > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1306,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1307,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e != 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#3a605933a41f17e4aa0a9aef5c1d38c0f5605d5a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -181 +181 @@
-					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e != 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1308,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1309,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 - We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#765759a50905ae316a4138885421001aa4b05c7b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -217 +217 @@
-	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
+	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 - We1_BA_DEF_ev_ctr5 == 1024)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Defroster.c> ."
1310,"            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{
					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 )) 
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( AU8.We6_BE_CONFIRM_ON ) 
						{
							if ( ControlElement_DEF == 0) 
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;",
1311,"            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{
					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ++ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( AU8.We6_BE_CONFIRM_ON ) 
						{
							if ( ControlElement_DEF == 0) 
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;","<mb:mutant#1bbf764675e24b7e20e0912355c01aa3a59bb071> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -124 +124 @@
-					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
+					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ++ControlElement_DEF == 0 ))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1312,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{",
1313,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3++ - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{","<mb:mutant#92f5ae0e64231c2e6a34fc311f032574768678e3> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -77 +77 @@
-		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
+		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3++ - 1000);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1314,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{",
1315,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = --We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{","<mb:mutant#bbe6949d3312cf21e35c0aacddf933ccaaa56a38> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -77 +77 @@
-		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
+		We1_BA_DEF = --We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1316,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{",
1317,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2-- - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{","<mb:mutant#874f79367348d3fcd3e8ce999337e9b39383a4af> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -77 +77 @@
-		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
+		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2-- - ( We1_BA_DEF_ev_ctr3 - 1000);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1318,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1319,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e != 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#2221b5eabe94626802466415bded6af17318fb72> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -203 +203 @@
-							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e != 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1320,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1321,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e-- == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#12594c54b3a3277446a8441b95e8c948ed7b2a4b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -197 +197 @@
-						if (( request == 0) && ( error_e == 0))
+						if (( request == 0) && ( error_e-- == 0))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1322,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1323,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) + ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#3c43dadc84789938aaf9aaec88653bf87f090a61> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -223 +223 @@
-		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
+		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) + ( We1_BA_DEF_ev_ctr5 ) == 1024)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Defroster.c> ."
1324,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{",
1325,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2++ * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{","<mb:mutant#0373d4a7c3f3720648b4c3d9e75c1f55fd636021> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -77 +77 @@
-		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
+		We1_BA_DEF = We1_BA_DEF_ev_ctr2++ * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1326,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1327,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( --We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#671897289cd80d3236447e481ce302482c1e8727> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -181 +181 @@
-					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+					if (( --We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1328,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1329,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && ++error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#0d4acc73e16494c6d2c97cf491a563f9ce20adbe> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -181 +181 @@
-					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && ++error_e > 0 && confirmation_e > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1330,"            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{
					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 )) 
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( AU8.We6_BE_CONFIRM_ON ) 
						{
							if ( ControlElement_DEF == 0) 
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;",
1331,"            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{
					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF++ == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( AU8.We6_BE_CONFIRM_ON ) 
						{
							if ( ControlElement_DEF == 0) 
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;","<mb:mutant#45072cadd6db7a33fe490a89dd2f80577609b308> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -124 +124 @@
-					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
+					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF++ == 0 ))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1332,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }",
1333,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }","<mb:mutant#9f689c72d076d44804f3c776ec5aa011ae51d18a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -144 +144 @@
-								if ( ControlElement_DEF > 0)
+								if ( ControlElement_DEF++ > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1334,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{",
1335,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( abs(We1_BA_DEF_ev_ctr3) - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{","<mb:mutant#4ababcd365df4058a9d4b2e26cb0bf7c8a43fd78> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -77 +77 @@
-		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
+		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( abs(We1_BA_DEF_ev_ctr3) - 1000);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Defroster.c> ."
1336,"            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{
					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 )) 
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( AU8.We6_BE_CONFIRM_ON ) 
						{
							if ( ControlElement_DEF == 0) 
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;",
1337,"            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{
					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF < 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( AU8.We6_BE_CONFIRM_ON ) 
						{
							if ( ControlElement_DEF == 0) 
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;","<mb:mutant#ab1ce08ee55f2f6a1f3bd60dd667219cfba25a60> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -124 +124 @@
-					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
+					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF < 0 ))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1338,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1339,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#b85f92d87d9c1d0253e1c13e55a53d667e0f5fe2> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -158 +158 @@
-						if ( ControlElement_DEF == 0)
+						if ( ControlElement_DEF++ == 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1340,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{",
1341,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 / ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{","<mb:mutant#f26e9d5168820bc770924b5a02b5981f2b4a47da> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -77 +77 @@
-		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
+		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 / ( We1_BA_DEF_ev_ctr3 - 1000);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Defroster.c> ."
1342,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1343,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e-- > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#5543c139ee9ebe6807a5155b8ee010274d2b258a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -181 +181 @@
-					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e-- > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1344,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1345,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request-- == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#93b97dd416248f9ccb2d9c2e31eefc9cb1cbb238> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -197 +197 @@
-						if (( request == 0) && ( error_e == 0))
+						if (( request-- == 0) && ( error_e == 0))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1346,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1347,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF-- > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#fae472816158ce77a8bf49b025be81454b3cb0bb> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -168 +168 @@
-							if ( ControlElement_DEF > 0)
+							if ( ControlElement_DEF-- > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1348,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{",
1349,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15++ == 0)
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{","<mb:mutant#9491de56bc5c427339e61adcf1d3f7b7e76a6df8> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -84 +84 @@
-			if ( Clip_15 == 0)
+			if ( Clip_15++ == 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1350,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }",
1351,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }","<mb:mutant#6c865035a3a785ea3a596b0d262eccfb706748c6> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -144 +144 @@
-								if ( ControlElement_DEF > 0)
+								if ( ControlElement_DEF != 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1352,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1353,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e >= 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#c98e0f11048a458a32008e6b66a6689d4f0c3669> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -181 +181 @@
-					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e >= 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1354,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{",
1355,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = ++We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{","<mb:mutant#d474bd8da172fd49523d81561764eca6a3a3a0dc> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -77 +77 @@
-		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
+		We1_BA_DEF = ++We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1356,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1357,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e >= 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#6ad9055028beb7b50a7eb4522f75b060b5bf1528> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -203 +203 @@
-							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e >= 0 && confirmation_e > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1358,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1359,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#715c16611c56391e1ef71e0b6ff7d5ea5179a843> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -158 +158 @@
-						if ( ControlElement_DEF == 0)
+						if ( ControlElement_DEF <= 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1360,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1361,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0++ >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#3f58d286423fa0cd974860b53acfea8449bddb61> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -203 +203 @@
-							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+							if (( We1_BA_DEF_ev_ctr0++ >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1362,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1363,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0-- >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#25468b1b8853d157f2e4f3b2abe727d42a4dacb8> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -181 +181 @@
-					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+					if (( We1_BA_DEF_ev_ctr0-- >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1364,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{",
1365,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15-- == 0)
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{","<mb:mutant#d09dff469d113640126d8d08f4b1e2e02daf8efb> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -84 +84 @@
-			if ( Clip_15 == 0)
+			if ( Clip_15-- == 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1366,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{",
1367,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3-- - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{","<mb:mutant#72241452688c0d3c106fb0daa9f052e964262b48> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -77 +77 @@
-		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
+		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3-- - 1000);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1368,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1369,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e <= 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#7920ed5e6f9fe011840b05566bf27e8a2eeda073> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -197 +197 @@
-						if (( request == 0) && ( error_e == 0))
+						if (( request == 0) && ( error_e <= 0))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1370,"            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{
					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 )) 
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( AU8.We6_BE_CONFIRM_ON ) 
						{
							if ( ControlElement_DEF == 0) 
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;",
1371,"            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{
					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF > 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( AU8.We6_BE_CONFIRM_ON ) 
						{
							if ( ControlElement_DEF == 0) 
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;","<mb:mutant#e3685dc0ac6b542230c1bc3ef449ab56a6da4b78> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -124 +124 @@
-					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
+					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF > 0 ))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1372,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{",
1373,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == --We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{","<mb:mutant#f0879ec30f7f1d20c34dd1d71c1465755ceb2f99> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -78 +78 @@
-		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
+		if ( ! ( We1_BA_DEF == --We1_BA_DEF_ev ))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1374,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1375,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) > 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#68ef45c755241e2134210769deba83bfb4c2523a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -223 +223 @@
-		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
+		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) > 1024)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1376,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{",
1377,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 % ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{","<mb:mutant#412b2802bc1538a365980894011cf9e143aeadb3> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -77 +77 @@
-		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
+		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 % ( We1_BA_DEF_ev_ctr3 - 1000);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Defroster.c> ."
1378,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1379,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e-- > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#8992be2dfc8f9ce8474d2967c1ce169eff5375b1> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -181 +181 @@
-					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e-- > 0 && confirmation_e > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1380,"            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{
					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 )) 
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( AU8.We6_BE_CONFIRM_ON ) 
						{
							if ( ControlElement_DEF == 0) 
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;",
1381,"            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{
					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e++ == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( AU8.We6_BE_CONFIRM_ON ) 
						{
							if ( ControlElement_DEF == 0) 
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;","<mb:mutant#190eb1ec3ee459c003d9be45d5f98a23b724d477> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -124 +124 @@
-					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
+					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e++ == 0 ) && ( ControlElement_DEF == 0 ))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1382,"            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{
					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 )) 
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( AU8.We6_BE_CONFIRM_ON ) 
						{
							if ( ControlElement_DEF == 0) 
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;",
1383,"            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{
					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF >= 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( AU8.We6_BE_CONFIRM_ON ) 
						{
							if ( ControlElement_DEF == 0) 
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;","<mb:mutant#91767b2f6eb42262307cd8b8b2ca8b277db84dd5> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -124 +124 @@
-					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
+					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF >= 0 ))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1384,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1385,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e < 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#00c11c0577437e2ed66724071294bfa2496dd952> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -181 +181 @@
-					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e < 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1386,"							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }",
1387,"							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }","<mb:mutant#ab05886a356068e57372bc91b6ea8dc498357d06> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -134 +134 @@
-							if ( ControlElement_DEF == 0)
+							if ( ControlElement_DEF <= 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1388,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{",
1389,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( --We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{","<mb:mutant#4d05f7bc4df4acf07503fbd0a5c20111bfe5e13a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -78 +78 @@
-		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
+		if ( ! ( --We1_BA_DEF == We1_BA_DEF_ev ))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1390,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1391,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 == (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#972cde71df8b52af2d06dbc67ab838554d81dd93> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -181 +181 @@
-					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+					if (( We1_BA_DEF_ev_ctr0 == (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1392,"							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }",
1393,"							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }","<mb:mutant#51a8f5e1c6e1e0d5ed4bbbf608d660e4169480db> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -134 +134 @@
-							if ( ControlElement_DEF == 0)
+							if ( ControlElement_DEF++ == 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1394,"            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{
					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 )) 
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( AU8.We6_BE_CONFIRM_ON ) 
						{
							if ( ControlElement_DEF == 0) 
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;",
1395,"            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{
					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF != 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( AU8.We6_BE_CONFIRM_ON ) 
						{
							if ( ControlElement_DEF == 0) 
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;","<mb:mutant#c9b8d641a4deecdf683d42516ebbcef24144425c> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -124 +124 @@
-					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
+					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF != 0 ))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1396,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{",
1397,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2++ - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{","<mb:mutant#46395cfed2048824ad62fd874e209afa9c4c72fa> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -77 +77 @@
-		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
+		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2++ - ( We1_BA_DEF_ev_ctr3 - 1000);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1398,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1399,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && --error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#f1fb24f51c364989371820a83446a9e1933d99d3> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -203 +203 @@
-							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && --error_e > 0 && confirmation_e > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1400,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{",
1401,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == ++We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{","<mb:mutant#3cbdd75767e6cb2fc732d8c89a93e97db52ea17b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -78 +78 @@
-		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
+		if ( ! ( We1_BA_DEF == ++We1_BA_DEF_ev ))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1402,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1403,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( ++We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#91ebd52573ad49a30b7c8709392ef4e6d46b6aab> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -181 +181 @@
-					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+					if (( ++We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1404,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1405,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request++ > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#bb11641005b06a4a4bd8a145cc08ed1c282c84d7> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -187 +187 @@
-						if ( request > 0 && ( error_e == 0))
+						if ( request++ > 0 && ( error_e == 0))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1406,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1407,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e++ > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#fafe4838bf041e86d5bad47c011e553062c50231> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -203 +203 @@
-							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e++ > 0 && confirmation_e > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1408,"            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{
					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 )) 
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( AU8.We6_BE_CONFIRM_ON ) 
						{
							if ( ControlElement_DEF == 0) 
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;",
1409,"            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{
					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e > 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( AU8.We6_BE_CONFIRM_ON ) 
						{
							if ( ControlElement_DEF == 0) 
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;","<mb:mutant#9eb06df5bc1b1571dee9031540d604697e4261d8> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -124 +124 @@
-					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
+					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e > 0 ) && ( ControlElement_DEF == 0 ))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1410,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1411,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#31f480b0e451456e3823ff12ee645e4c895d1f98> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -158 +158 @@
-						if ( ControlElement_DEF == 0)
+						if ( ControlElement_DEF-- == 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1412,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1413,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( --We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#0076071d69e9c6a81348141612ca19ae11242c0e> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -203 +203 @@
-							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+							if (( --We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1414,"							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }",
1415,"							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }","<mb:mutant#a8b153869dff054cccdb4e027cd50e2b8b206162> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -134 +134 @@
-							if ( ControlElement_DEF == 0)
+							if ( ControlElement_DEF-- == 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1416,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{",
1417,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = -abs(We1_BA_DEF_ev_ctr2) * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{","<mb:mutant#d0d61c17bfef1f3e190fc2ff8f2b4aca70fba8a1> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -77 +77 @@
-		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
+		We1_BA_DEF = -abs(We1_BA_DEF_ev_ctr2) * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Defroster.c> ."
1418,"            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{
					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 )) 
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( AU8.We6_BE_CONFIRM_ON ) 
						{
							if ( ControlElement_DEF == 0) 
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;",
1419,"            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{
					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e <= 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( AU8.We6_BE_CONFIRM_ON ) 
						{
							if ( ControlElement_DEF == 0) 
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;","<mb:mutant#965319028372e7639a1afd58b5cd503531d3a3c6> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -124 +124 @@
-					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
+					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e <= 0 ) && ( ControlElement_DEF == 0 ))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1420,"            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{
					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 )) 
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( AU8.We6_BE_CONFIRM_ON ) 
						{
							if ( ControlElement_DEF == 0) 
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;",
1421,"            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{
					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( --ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( AU8.We6_BE_CONFIRM_ON ) 
						{
							if ( ControlElement_DEF == 0) 
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;","<mb:mutant#a7b6781a56d6de53417a87b3665f6efb53048219> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -124 +124 @@
-					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
+					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( --ControlElement_DEF == 0 ))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1422,"            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{
					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 )) 
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( AU8.We6_BE_CONFIRM_ON ) 
						{
							if ( ControlElement_DEF == 0) 
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;",
1423,"            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{
					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e != 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( AU8.We6_BE_CONFIRM_ON ) 
						{
							if ( ControlElement_DEF == 0) 
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;","<mb:mutant#01fff259ca98ae60ac709d4c8a59007f1148abd9> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -124 +124 @@
-					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
+					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e != 0 ) && ( ControlElement_DEF == 0 ))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1424,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1425,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e == 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#236acfa0d79505c89906b50be73330f19495cf8f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -181 +181 @@
-					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e == 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1426,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1427,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e == 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#c298c69f19d67cc1a70a3f26659870bd922f42ac> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -203 +203 @@
-							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e == 0 && confirmation_e > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1428,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1429,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e < 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#c213209a6919bb31437798db8b18d52cfe71a7ce> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -181 +181 @@
-					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e < 0 && confirmation_e > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1430,"            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{
					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 )) 
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( AU8.We6_BE_CONFIRM_ON ) 
						{
							if ( ControlElement_DEF == 0) 
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;",
1431,"            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{
					if (( We1_BA_DEF_ev_ctr1 > (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( AU8.We6_BE_CONFIRM_ON ) 
						{
							if ( ControlElement_DEF == 0) 
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;","<mb:mutant#e5f6d4a99f5187ffc2d6967ce6a1a4396711f086> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -124 +124 @@
-					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
+					if (( We1_BA_DEF_ev_ctr1 > (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1432,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1433,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 > 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#3ea9159ec4fc9a7b7c94980de83af5e9c8abd46d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -217 +217 @@
-	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
+	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 > 1024)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1434,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1435,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF++ > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#ec8d38e33d4d1b471de3c453d74eb72ffeca5108> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -168 +168 @@
-							if ( ControlElement_DEF > 0)
+							if ( ControlElement_DEF++ > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1436,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{",
1437,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2-- * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{","<mb:mutant#f9b7326d3e0d345d2a3fe1cc6d901b0b10da92ff> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -77 +77 @@
-		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
+		We1_BA_DEF = We1_BA_DEF_ev_ctr2-- * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1438,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{",
1439,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 * ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{","<mb:mutant#40b269e52dd86278f55353071c3e14b0422bb822> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -77 +77 @@
-		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
+		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 * ( We1_BA_DEF_ev_ctr3 - 1000);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Defroster.c> ."
1440,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1441,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 == (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#68ea27f200fe6b4b106432306bd7b97273dd6bba> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -203 +203 @@
-							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+							if (( We1_BA_DEF_ev_ctr0 == (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1442,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1443,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e++ == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#d436530b6e170483e79d0dbe5ff014671d232dd4> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -187 +187 @@
-						if ( request > 0 && ( error_e == 0))
+						if ( request > 0 && ( error_e++ == 0))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1444,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1445,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e <= 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#588a655db435b5231acd1764bb9d076010d040c4> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -187 +187 @@
-						if ( request > 0 && ( error_e == 0))
+						if ( request > 0 && ( error_e <= 0))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1446,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1447,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) >= 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#ee49fa7c7869ac35ca242837438bf78b8ee6ef69> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -223 +223 @@
-		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
+		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) >= 1024)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1448,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1449,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request != 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#0933a6b7faa4902b4daff8844317321ecd1c7507> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -187 +187 @@
-						if ( request > 0 && ( error_e == 0))
+						if ( request != 0 && ( error_e == 0))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1450,"            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{
					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 )) 
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( AU8.We6_BE_CONFIRM_ON ) 
						{
							if ( ControlElement_DEF == 0) 
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;",
1451,"            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{
					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( --confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( AU8.We6_BE_CONFIRM_ON ) 
						{
							if ( ControlElement_DEF == 0) 
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;","<mb:mutant#02812284a32f84f50e28f269bb7c6590ac235a5d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -124 +124 @@
-					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
+					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( --confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1452,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{",
1453,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * ++We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{","<mb:mutant#da57df0a62495d4a307bde364fa3c9833425c505> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -77 +77 @@
-		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
+		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * ++We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1454,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1455,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#b84b2d49c50556bb571fdb2e1339ff48ec32a305> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -217 +217 @@
-	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
+	if ( We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AORB> ;
    mb:program <mb:program#Defroster.c> ."
1456,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1457,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && ++error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#6d2201e1b41a9efc509a8364c0230dc00d29d51e> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -203 +203 @@
-							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && ++error_e > 0 && confirmation_e > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1458,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1459,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF != 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#87e34666ca2ec517d96e5cbde6dec14a9a141bd6> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -168 +168 @@
-							if ( ControlElement_DEF > 0)
+							if ( ControlElement_DEF != 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1460,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1461,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e != 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#9646c390cabe9c9e60ac54613241454c9f18eae6> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -181 +181 @@
-					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0)
+					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e != 0 && confirmation_e > 0)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1462,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{",
1463,"void main ( void ) 
{
	signed short We1_BA_DEF_ev = 0;
	signed short We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( AU8.We2_Clip15_OUT ) 
	{
		if ( Clip_15 )  
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = abs(We1_BA_DEF_ev_ctr2) * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev )) 
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( AU8.We3_Clip15_ON ) 
		{
			if ( Clip_15 == 0) 
			{
				if ( AU8.We11_BLINK_OUT ) 
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else  
				{
					if ( AU8.We12_BLINK_ON )  
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( AU8.We5_BE_HANDLING ) 
				{
					Exception_handler ();
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{","<mb:mutant#a26ba654d21693d33c38d646c349a0373cc4e398> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -77 +77 @@
-		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
+		We1_BA_DEF = abs(We1_BA_DEF_ev_ctr2) * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Defroster.c> ."
1464,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request == 0) && ( error_e == 0)) 
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",
1465,"                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else 
				{                  
					if ( AU8.We12_BLINK_ON ) 
					{
						if (( request++ == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }      
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024) 
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024) 
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}","<mb:mutant#83926e2b970ef9ca2cfe452ca2b5960163fdca00> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -197 +197 @@
-						if (( request == 0) && ( error_e == 0))
+						if (( request++ == 0) && ( error_e == 0))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1466,"            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{
					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 )) 
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( AU8.We6_BE_CONFIRM_ON ) 
						{
							if ( ControlElement_DEF == 0) 
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;",
1467,"            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{
					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e-- == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( AU8.We6_BE_CONFIRM_ON ) 
						{
							if ( ControlElement_DEF == 0) 
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;","<mb:mutant#88f743b2a8166765598eb283234d5bc5fc47bd84> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -124 +124 @@
-					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
+					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e-- == 0 ) && ( ControlElement_DEF == 0 ))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Defroster.c> ."
1468,"            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{
					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 )) 
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( AU8.We6_BE_CONFIRM_ON ) 
						{
							if ( ControlElement_DEF == 0) 
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;",
1469,"            }
			else
			{
				if ( AU8.We5_BE_HANDLING ) 
				{
					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF <= 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( AU8.We6_BE_CONFIRM_ON ) 
						{
							if ( ControlElement_DEF == 0) 
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( AU8.We7_BE_LOSGELASSEN ) 
							{
								if ( ControlElement_DEF > 0) 
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else 
				{
					if ( AU8.We8_BE_CONFIRM_OUT ) 
					{
						if ( ControlElement_DEF == 0) 
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else 
					{
						if ( AU8.We9_DEF_OUT ) 
						{
							if ( ControlElement_DEF > 0) 
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;                              
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( AU8.We11_BLINK_OUT ) 
				{
					if (( We1_BA_DEF_ev_ctr0 >= (( signed short ) 3250 )) && error_e > 0 && confirmation_e > 0) 
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else 
					{
						if ( request > 0 && ( error_e == 0)) 
						{
							AU8.We11_BLINK_OUT = 0;","<mb:mutant#f8d14d625bdb4e4a34cce7aa1766a72057078caf> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -124 +124 @@
-					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
+					if (( We1_BA_DEF_ev_ctr1 >= (( signed short ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF <= 0 ))
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Defroster.c> ."
1470,"	*lastel = NULL;
	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) == NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c == EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c == CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p == NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c;
	p->LINE_NUM = line_num;
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = p;
	*lastel = p;
	printf(""\n"");
	c = (char) getc(f);
	while (c != EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c == CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
            p->info = c;
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
			c = (char) getc(f);
		};
	};
	fclose(f);
	return 0;
}",
1471,"	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) == NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c == EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c == CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p == NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c;
	p->LINE_NUM = line_num;
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = p;
	*lastel = p;
	printf(""\n"");
	c = (char) getc(f);
	while (c != EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c == CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = abs(line_num);
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
            p->info = c;
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
			c = (char) getc(f);
		};
	};
	fclose(f);
	return 0;
}","<mb:mutant#27096c7534dd38319e58782ff805c6478eb954f3> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -7167 +7167 @@
-			p->LINE_NUM = line_num;
+			p->LINE_NUM = abs(line_num);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Space.c> ."
1472,"int
groupdef(struct charac * p1, struct charac ** pp2,
	 struct Group ** group_ptr
)
{
	struct charac  *curr, **curr_ptr = &curr;
	int             error;
	char            groupname[UNLEN + 1];
	struct Grid    *grid = NULL, **grid_ptr = &grid;
	struct Elem    *elem = NULL, **elem_ptr = &elem;
	struct AddRem  *addrem = NULL, **addrem_ptr = &addrem;
	struct GrAmpExc *grampexc = NULL, **grampexc_ptr = &grampexc;
	struct GrPhaExc *grphaexc = NULL, **grphaexc_ptr = &grphaexc;
	struct Err     *err = NULL, **err_ptr = &err;
	struct Fail    *fail = NULL, **fail_ptr = &fail;
#ifdef DEBUG1
	printf(""\nFunzione groupdef()"");
#endif
	*curr_ptr = p1;
	error = 0;
	error = (GetKeyword(Keywords[47], curr_ptr));
	if (error != 0) {
		*group_ptr = NULL;
		return 1;
	};
	if (GetUName(groupname, curr_ptr) != 0) {
		parserro(*curr_ptr, 81, "" "");
		return 17;
	};
	if (InUNames(groupname)) {
		parserro(*curr_ptr, 3, groupname);
		return 17;
	};
	InserUN(groupname);
	error = greldef(*curr_ptr, curr_ptr, grid_ptr, elem_ptr);
	if (error == 17) {
		return 17;
	};
	if (error == 0) {
		(*grid_ptr)->LEVEL = INTERNAL;
		(*elem_ptr)->LEVEL = INTERNAL;
		strcpy((*elem_ptr)->NAME, ""ELEMENT"");
	};
	error = grgeodef(*curr_ptr, curr_ptr, addrem_ptr);
	if (error != 0) {
		parserro(*curr_ptr, 82, groupname);
		return 17;
	};
	error = grexcdef(*curr_ptr, curr_ptr, grampexc_ptr, grphaexc_ptr);
	if (error != 0) {
		parserro(*curr_ptr, 82, "" "");
		return 17;
	};
	error = (GetKeyword(Keywords[50], curr_ptr));
	if (error != 0) {",
1473,"int
groupdef(struct charac * p1, struct charac ** pp2,
	 struct Group ** group_ptr
)
{
	struct charac  *curr, **curr_ptr = &curr;
	int             error;
	char            groupname[UNLEN + 1];
	struct Grid    *grid = NULL, **grid_ptr = &grid;
	struct Elem    *elem = NULL, **elem_ptr = &elem;
	struct AddRem  *addrem = NULL, **addrem_ptr = &addrem;
	struct GrAmpExc *grampexc = NULL, **grampexc_ptr = &grampexc;
	struct GrPhaExc *grphaexc = NULL, **grphaexc_ptr = &grphaexc;
	struct Err     *err = NULL, **err_ptr = &err;
	struct Fail    *fail = NULL, **fail_ptr = &fail;
#ifdef DEBUG1
	printf(""\nFunzione groupdef()"");
#endif
	*curr_ptr = p1;
	error = 0;
	error = (GetKeyword(Keywords[47], curr_ptr));
	if (error != 0) {
		*group_ptr = NULL;
		return 1;
	};
	if (GetUName(groupname, abs(curr_ptr)) != 0) {
		parserro(*curr_ptr, 81, "" "");
		return 17;
	};
	if (InUNames(groupname)) {
		parserro(*curr_ptr, 3, groupname);
		return 17;
	};
	InserUN(groupname);
	error = greldef(*curr_ptr, curr_ptr, grid_ptr, elem_ptr);
	if (error == 17) {
		return 17;
	};
	if (error == 0) {
		(*grid_ptr)->LEVEL = INTERNAL;
		(*elem_ptr)->LEVEL = INTERNAL;
		strcpy((*elem_ptr)->NAME, ""ELEMENT"");
	};
	error = grgeodef(*curr_ptr, curr_ptr, addrem_ptr);
	if (error != 0) {
		parserro(*curr_ptr, 82, groupname);
		return 17;
	};
	error = grexcdef(*curr_ptr, curr_ptr, grampexc_ptr, grphaexc_ptr);
	if (error != 0) {
		parserro(*curr_ptr, 82, "" "");
		return 17;
	};
	error = (GetKeyword(Keywords[50], curr_ptr));
	if (error != 0) {","<mb:mutant#3ce501ca52b210d15f9d0720a1ade211a49da403> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -4564 +4564 @@
-	if (GetUName(groupname, curr_ptr) != 0) {
+	if (GetUName(groupname, abs(curr_ptr)) != 0) {
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Space.c> ."
1474,"	*lastel = NULL;
	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) == NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c == EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c == CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p == NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c;
	p->LINE_NUM = line_num;
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = p;
	*lastel = p;
	printf(""\n"");
	c = (char) getc(f);
	while (c != EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c == CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
            p->info = c;
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
			c = (char) getc(f);
		};
	};
	fclose(f);
	return 0;
}",
1475,"	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) == NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c == EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c == CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p == NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c;
	p->LINE_NUM = line_num;
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = p;
	*lastel = p;
	printf(""\n"");
	c = (char) getc(f);
	while (c != EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c == CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
            p->info = abs(c);
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
			c = (char) getc(f);
		};
	};
	fclose(f);
	return 0;
}","<mb:mutant#3d76d95c61c511ab1bfb2a2f0c36c3a034eb9ee7> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -7182 +7182 @@
-            p->info = c;
+            p->info = abs(c);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Space.c> ."
1476,")
{
	struct charac  *curr, **curr_ptr = &curr;
	int             error;
	char            groupname[UNLEN + 1];
	struct Grid    *grid = NULL, **grid_ptr = &grid;
	struct Elem    *elem = NULL, **elem_ptr = &elem;
	struct AddRem  *addrem = NULL, **addrem_ptr = &addrem;
	struct GrAmpExc *grampexc = NULL, **grampexc_ptr = &grampexc;
	struct GrPhaExc *grphaexc = NULL, **grphaexc_ptr = &grphaexc;
	struct Err     *err = NULL, **err_ptr = &err;
	struct Fail    *fail = NULL, **fail_ptr = &fail;
#ifdef DEBUG1
	printf(""\nFunzione groupdef()"");
#endif
	*curr_ptr = p1;
	error = 0;
	error = (GetKeyword(Keywords[47], curr_ptr));
	if (error != 0) {
		*group_ptr = NULL;
		return 1;
	};
	if (GetUName(groupname, curr_ptr) != 0) {
		parserro(*curr_ptr, 81, "" "");
		return 17;
	};
	if (InUNames(groupname)) {
		parserro(*curr_ptr, 3, groupname);
		return 17;
	};
	InserUN(groupname);
	error = greldef(*curr_ptr, curr_ptr, grid_ptr, elem_ptr);
	if (error == 17) {
		return 17;
	};
	if (error == 0) {
		(*grid_ptr)->LEVEL = INTERNAL;
		(*elem_ptr)->LEVEL = INTERNAL;
		strcpy((*elem_ptr)->NAME, ""ELEMENT"");
	};
	error = grgeodef(*curr_ptr, curr_ptr, addrem_ptr);
	if (error != 0) {
		parserro(*curr_ptr, 82, groupname);
		return 17;
	};
	error = grexcdef(*curr_ptr, curr_ptr, grampexc_ptr, grphaexc_ptr);
	if (error != 0) {
		parserro(*curr_ptr, 82, "" "");
		return 17;
	};
	error = (GetKeyword(Keywords[50], curr_ptr));
	if (error != 0) {
		parserro(*curr_ptr, 1, Keywords[50]);
		return 17;
	};
	*group_ptr = (struct Group *) malloc(sizeof(struct Group));",
1477,"{
	struct charac  *curr, **curr_ptr = &curr;
	int             error;
	char            groupname[UNLEN + 1];
	struct Grid    *grid = NULL, **grid_ptr = &grid;
	struct Elem    *elem = NULL, **elem_ptr = &elem;
	struct AddRem  *addrem = NULL, **addrem_ptr = &addrem;
	struct GrAmpExc *grampexc = NULL, **grampexc_ptr = &grampexc;
	struct GrPhaExc *grphaexc = NULL, **grphaexc_ptr = &grphaexc;
	struct Err     *err = NULL, **err_ptr = &err;
	struct Fail    *fail = NULL, **fail_ptr = &fail;
#ifdef DEBUG1
	printf(""\nFunzione groupdef()"");
#endif
	*curr_ptr = p1;
	error = 0;
	error = (GetKeyword(Keywords[47], curr_ptr));
	if (error != 0) {
		*group_ptr = NULL;
		return 1;
	};
	if (GetUName(groupname, curr_ptr) != 0) {
		parserro(*curr_ptr, 81, "" "");
		return 17;
	};
	if (InUNames(groupname)) {
		parserro(*curr_ptr, 3, abs(groupname));
		return 17;
	};
	InserUN(groupname);
	error = greldef(*curr_ptr, curr_ptr, grid_ptr, elem_ptr);
	if (error == 17) {
		return 17;
	};
	if (error == 0) {
		(*grid_ptr)->LEVEL = INTERNAL;
		(*elem_ptr)->LEVEL = INTERNAL;
		strcpy((*elem_ptr)->NAME, ""ELEMENT"");
	};
	error = grgeodef(*curr_ptr, curr_ptr, addrem_ptr);
	if (error != 0) {
		parserro(*curr_ptr, 82, groupname);
		return 17;
	};
	error = grexcdef(*curr_ptr, curr_ptr, grampexc_ptr, grphaexc_ptr);
	if (error != 0) {
		parserro(*curr_ptr, 82, "" "");
		return 17;
	};
	error = (GetKeyword(Keywords[50], curr_ptr));
	if (error != 0) {
		parserro(*curr_ptr, 1, Keywords[50]);
		return 17;
	};
	*group_ptr = (struct Group *) malloc(sizeof(struct Group));","<mb:mutant#1fb56bb0636beb81853962887c935434549f6b0e> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -4572 +4572 @@
-		parserro(*curr_ptr, 3, groupname);
+		parserro(*curr_ptr, 3, abs(groupname));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Space.c> ."
1478,"	*lastel = NULL;
	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) == NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c == EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c == CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p == NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c;
	p->LINE_NUM = line_num;
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = p;
	*lastel = p;
	printf(""\n"");
	c = (char) getc(f);
	while (c != EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c == CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
            p->info = c;
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
			c = (char) getc(f);
		};
	};
	fclose(f);
	return 0;
}",
1479,"	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) == NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c == EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c == CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p == NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c;
	p->LINE_NUM = line_num;
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = p;
	*lastel = p;
	printf(""\n"");
	c = (char) getc(f);
	while (c != EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c == CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = line_num;
			p->PREV = abs(*lastel);
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
            p->info = c;
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
			c = (char) getc(f);
		};
	};
	fclose(f);
	return 0;
}","<mb:mutant#a2a710c27bec7a8e8819ead213871e5bdae9468f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -7168 +7168 @@
-			p->PREV = *lastel;
+			p->PREV = abs(*lastel);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Space.c> ."
1480,"	*lastel = NULL;
	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) == NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c == EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c == CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p == NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c;
	p->LINE_NUM = line_num;
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = p;
	*lastel = p;
	printf(""\n"");
	c = (char) getc(f);
	while (c != EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c == CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
            p->info = c;
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
			c = (char) getc(f);
		};
	};
	fclose(f);
	return 0;
}",
1481,"	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) == NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c == EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c == CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p == NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c;
	p->LINE_NUM = line_num;
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = p;
	*lastel = p;
	printf(""\n"");
	c = (char) getc(f);
	while (c != EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c == CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
            p->info = c;
			p->LINE_NUM = line_num;
			p->PREV = abs(*lastel);
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
			c = (char) getc(f);
		};
	};
	fclose(f);
	return 0;
}","<mb:mutant#51cf8a45d28633ed664276a286d24cd382aeb50b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -7185 +7185 @@
-			p->PREV = *lastel;
+			p->PREV = abs(*lastel);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Space.c> ."
1482,"int readfil3(char filename[UNLEN + 1], struct charac ** firstel, struct charac ** lastel)
{
	FILE           *f;
	char            c;
	struct charac  *p;
	int             line_num = 1;
	char            CR = '\n';
	char            adlfilename[UNLEN + 1];
#ifdef DEBUG3
	printf(""\nreadfil3()"");
#endif
	*firstel = NULL;
	*lastel = NULL;
	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) == NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c == EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c == CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p == NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c;
	p->LINE_NUM = line_num;
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = p;
	*lastel = p;
	printf(""\n"");
	c = (char) getc(f);
	while (c != EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c == CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{",
1483,"int readfil3(char filename[UNLEN + 1], struct charac ** firstel, struct charac ** lastel)
{
	FILE           *f;
	char            c;
	struct charac  *p;
	int             line_num = 1;
	char            CR = '\n';
	char            adlfilename[UNLEN + 1];
#ifdef DEBUG3
	printf(""\nreadfil3()"");
#endif
	*firstel = NULL;
	*lastel = NULL;
	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) == NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c == EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c == CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p == NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c++;
	p->LINE_NUM = line_num;
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = p;
	*lastel = p;
	printf(""\n"");
	c = (char) getc(f);
	while (c != EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c == CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{","<mb:mutant#166562a57daee1ea3063748737d87034d62718ec> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -7137 +7137 @@
-	p->info = c;
+	p->info = c++;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Space.c> ."
1484,"	strcpy(Keywords[82], ""ORDER"");
	strcpy(Keywords[83], ""CENTRE"");
	strcpy(Keywords[84], ""P1_VAL"");
	strcpy(Keywords[85], ""P2_VAL"");
	strcpy(Keywords[86], ""Q1_VAL"");
	strcpy(Keywords[87], ""Q2_VAL"");
	strcpy(Keywords[88], ""UNIFORM"");
	strcpy(Keywords[89], ""P1_VAL"");
	strcpy(Keywords[90], ""P2_VAL"");
	strcpy(Keywords[91], ""Q1_VAL"");
	strcpy(Keywords[92], ""Q2_VAL"");
	strcpy(Keywords[93], ""CW"");
	strcpy(Keywords[94], ""CCW"");
	strcpy(Keywords[95], ""START"");
	strcpy(Keywords[96], ""POINTING"");
	strcpy(Keywords[97], ""U"");
	strcpy(Keywords[98], ""V"");
	strcpy(Keywords[99], ""ROTATION"");
	strcpy(Keywords[100], ""SEQUENTIAL"");
	strcpy(Keywords[101], ""GROUP_EXCITATION"");
	strcpy(Keywords[102], ""ADD_GROUP"");
	strcpy(Keywords[103], ""AT"");
	strcpy(Keywords[104], ""PLACE_GROUP"");
	strcpy(Keywords[105], ""DISPLACE"");
	strcpy(Keywords[106], ""MOVE"");
	strcpy(Keywords[107], ""TO"");
	strcpy(Keywords[108], """");
	strcpy(Keywords[109], """");
	strcpy(Keywords[110], """");
	strcpy(Keywords[111], """");
	strcpy(Keywords[112], """");
	strcpy(Keywords[113], """");
	strcpy(Keywords[114], """");
	strcpy(Keywords[115], """");
	strcpy(Keywords[116], """");
	strcpy(Keywords[117], """");
	strcpy(Keywords[118], """");
	strcpy(Keywords[119], """");
	strcpy(Keywords[120], """");
	strcpy(Keywords[121], """");
	strcpy(Keywords[122], """");
	strcpy(Keywords[123], """");
	strcpy(Keywords[124], """");
	strcpy(Keywords[125], """");
	for (i = 0; (i <= KWDSNUM); i++) {
		if (strlen(Keywords[i]) > KWDSLEN) {
			printf(""\n ******** ERROR: KEYWORD no.%d TOO LONG - CORRECT Keywords[] ASSIGNMENT\n"", i);
			interror(""kwdsinit()"");
		};
	};
#ifdef DEBUG4
	for (i = 0; ((i <= KWDSNUM) && (Keywords[i][0])); i++)
		printf(""%d - %s\n"", i, Keywords[i]);
	waitcont();
#endif
}",
1485,"	strcpy(Keywords[82], ""ORDER"");
	strcpy(Keywords[83], ""CENTRE"");
	strcpy(Keywords[84], ""P1_VAL"");
	strcpy(Keywords[85], ""P2_VAL"");
	strcpy(Keywords[86], ""Q1_VAL"");
	strcpy(Keywords[87], ""Q2_VAL"");
	strcpy(Keywords[88], ""UNIFORM"");
	strcpy(Keywords[89], ""P1_VAL"");
	strcpy(Keywords[90], ""P2_VAL"");
	strcpy(Keywords[91], ""Q1_VAL"");
	strcpy(Keywords[92], ""Q2_VAL"");
	strcpy(Keywords[93], ""CW"");
	strcpy(Keywords[94], ""CCW"");
	strcpy(Keywords[95], ""START"");
	strcpy(Keywords[96], ""POINTING"");
	strcpy(Keywords[97], ""U"");
	strcpy(Keywords[98], ""V"");
	strcpy(Keywords[99], ""ROTATION"");
	strcpy(Keywords[100], ""SEQUENTIAL"");
	strcpy(Keywords[101], ""GROUP_EXCITATION"");
	strcpy(Keywords[102], ""ADD_GROUP"");
	strcpy(Keywords[103], ""AT"");
	strcpy(Keywords[104], ""PLACE_GROUP"");
	strcpy(Keywords[105], ""DISPLACE"");
	strcpy(Keywords[106], ""MOVE"");
	strcpy(Keywords[107], ""TO"");
	strcpy(Keywords[108], """");
	strcpy(Keywords[109], """");
	strcpy(Keywords[110], """");
	strcpy(Keywords[111], """");
	strcpy(Keywords[112], """");
	strcpy(Keywords[113], """");
	strcpy(Keywords[114], """");
	strcpy(Keywords[115], """");
	strcpy(Keywords[116], """");
	strcpy(Keywords[117], """");
	strcpy(Keywords[118], """");
	strcpy(Keywords[119], """");
	strcpy(Keywords[120], """");
	strcpy(Keywords[121], """");
	strcpy(Keywords[122], """");
	strcpy(Keywords[123], """");
	strcpy(Keywords[124], """");
	strcpy(Keywords[125], """");
	for (i = 0; (i <= KWDSNUM); i++) {
		if (strlen(Keywords[i]) >= KWDSLEN) {
			printf(""\n ******** ERROR: KEYWORD no.%d TOO LONG - CORRECT Keywords[] ASSIGNMENT\n"", i);
			interror(""kwdsinit()"");
		};
	};
#ifdef DEBUG4
	for (i = 0; ((i <= KWDSNUM) && (Keywords[i][0])); i++)
		printf(""%d - %s\n"", i, Keywords[i]);
	waitcont();
#endif
}","<mb:mutant#e3ce3ba5def7dfc694c6e8e787c038d3a18415a3> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -5367 +5367 @@
-		if (strlen(Keywords[i]) > KWDSLEN) {
+		if (strlen(Keywords[i]) >= KWDSLEN) {
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Space.c> ."
1486,"int readfil3(char filename[UNLEN + 1], struct charac ** firstel, struct charac ** lastel)
{
	FILE           *f;
	char            c;
	struct charac  *p;
	int             line_num = 1;
	char            CR = '\n';
	char            adlfilename[UNLEN + 1];
#ifdef DEBUG3
	printf(""\nreadfil3()"");
#endif
	*firstel = NULL;
	*lastel = NULL;
	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) == NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c == EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c == CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p == NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c;
	p->LINE_NUM = line_num;
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = p;
	*lastel = p;
	printf(""\n"");
	c = (char) getc(f);
	while (c != EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c == CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{",
1487,"int readfil3(char filename[UNLEN + 1], struct charac ** firstel, struct charac ** lastel)
{
	FILE           *f;
	char            c;
	struct charac  *p;
	int             line_num = 1;
	char            CR = '\n';
	char            adlfilename[UNLEN + 1];
#ifdef DEBUG3
	printf(""\nreadfil3()"");
#endif
	*firstel = NULL;
	*lastel = NULL;
	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) == NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c == EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c == CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p == NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c--;
	p->LINE_NUM = line_num;
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = p;
	*lastel = p;
	printf(""\n"");
	c = (char) getc(f);
	while (c != EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c == CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{","<mb:mutant#53ddf9b35e78102404872667e5eb8ff96b2d3485> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -7137 +7137 @@
-	p->info = c;
+	p->info = c--;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIS> ;
    mb:program <mb:program#Space.c> ."
1488,"	*lastel = NULL;
	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) == NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c == EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c == CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p == NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c;
	p->LINE_NUM = line_num;
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = p;
	*lastel = p;
	printf(""\n"");
	c = (char) getc(f);
	while (c != EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c == CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
            p->info = c;
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
			c = (char) getc(f);
		};
	};
	fclose(f);
	return 0;
}",
1489,"	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) == NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c == EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c == CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p == NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c;
	p->LINE_NUM = line_num;
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = p;
	*lastel = p;
	printf(""\n"");
	c = (char) getc(f);
	while (c != EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c == CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = abs(p);
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
            p->info = c;
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
			c = (char) getc(f);
		};
	};
	fclose(f);
	return 0;
}","<mb:mutant#59a8fe2d5ed09a7ad913e647418c10e5d459ac61> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -7171 +7171 @@
-			*lastel = p;
+			*lastel = abs(p);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Space.c> ."
1490,"	*lastel = NULL;
	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) == NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c == EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c == CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p == NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c;
	p->LINE_NUM = line_num;
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = p;
	*lastel = p;
	printf(""\n"");
	c = (char) getc(f);
	while (c != EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c == CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
            p->info = c;
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
			c = (char) getc(f);
		};
	};
	fclose(f);
	return 0;
}",
1491,"	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) == NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c == EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c == CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p == NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c;
	p->LINE_NUM = line_num;
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = p;
	*lastel = p;
	printf(""\n"");
	c = (char) getc(f);
	while (c != EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c == CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
            p->info = c;
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = abs(p);
			*lastel = p;
			c = (char) getc(f);
		};
	};
	fclose(f);
	return 0;
}","<mb:mutant#19a3db8d4d5c08ace7bcbe5824256e9188cf364a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -7187 +7187 @@
-			(*lastel)->NEXT = p;
+			(*lastel)->NEXT = abs(p);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Space.c> ."
1492,"{
	FILE           *f;
	char            c;
	struct charac  *p;
	int             line_num = 1;
	char            CR = '\n';
	char            adlfilename[UNLEN + 1];
#ifdef DEBUG3
	printf(""\nreadfil3()"");
#endif
	*firstel = NULL;
	*lastel = NULL;
	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) == NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c == EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c == CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p == NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c;
	p->LINE_NUM = line_num;
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = p;
	*lastel = p;
	printf(""\n"");
	c = (char) getc(f);
	while (c != EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c == CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;",
1493,"{
	FILE           *f;
	char            c;
	struct charac  *p;
	int             line_num = 1;
	char            CR = '\n';
	char            adlfilename[UNLEN + 1];
#ifdef DEBUG3
	printf(""\nreadfil3()"");
#endif
	*firstel = NULL;
	*lastel = NULL;
	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) == NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c == EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c == CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p == NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c;
	p->LINE_NUM = abs(line_num);
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = p;
	*lastel = p;
	printf(""\n"");
	c = (char) getc(f);
	while (c != EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c == CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;","<mb:mutant#b9108915f229ecac1270c97a7adbc77e49866f59> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -7138 +7138 @@
-	p->LINE_NUM = line_num;
+	p->LINE_NUM = abs(line_num);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Space.c> ."
1494,"	*lastel = NULL;
	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) == NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c == EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c == CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p == NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c;
	p->LINE_NUM = line_num;
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = p;
	*lastel = p;
	printf(""\n"");
	c = (char) getc(f);
	while (c != EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c == CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
            p->info = c;
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
			c = (char) getc(f);
		};
	};
	fclose(f);
	return 0;
}",
1495,"	*lastel = NULL;
	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) == NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c == EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c == CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p == NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c;
	p->LINE_NUM = line_num;
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = p;
	*lastel = p;
	printf(""\n"");
	c = (char) getc(f);
	while (c != EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c <= CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
            p->info = c;
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
			c = (char) getc(f);
		};
	};
	fclose(f);
	return 0;
}","<mb:mutant#64702bdda57b01ec7ddc9886988b52b39f2454bf> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -7155 +7155 @@
-				if (c == CR)
+				if (c <= CR)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Space.c> ."
1496,"int
groupdef(struct charac * p1, struct charac ** pp2,
	 struct Group ** group_ptr
)
{
	struct charac  *curr, **curr_ptr = &curr;
	int             error;
	char            groupname[UNLEN + 1];
	struct Grid    *grid = NULL, **grid_ptr = &grid;
	struct Elem    *elem = NULL, **elem_ptr = &elem;
	struct AddRem  *addrem = NULL, **addrem_ptr = &addrem;
	struct GrAmpExc *grampexc = NULL, **grampexc_ptr = &grampexc;
	struct GrPhaExc *grphaexc = NULL, **grphaexc_ptr = &grphaexc;
	struct Err     *err = NULL, **err_ptr = &err;
	struct Fail    *fail = NULL, **fail_ptr = &fail;
#ifdef DEBUG1
	printf(""\nFunzione groupdef()"");
#endif
	*curr_ptr = p1;
	error = 0;
	error = (GetKeyword(Keywords[47], curr_ptr));
	if (error != 0) {
		*group_ptr = NULL;
		return 1;
	};
	if (GetUName(groupname, curr_ptr) != 0) {
		parserro(*curr_ptr, 81, "" "");
		return 17;
	};
	if (InUNames(groupname)) {
		parserro(*curr_ptr, 3, groupname);
		return 17;
	};
	InserUN(groupname);
	error = greldef(*curr_ptr, curr_ptr, grid_ptr, elem_ptr);
	if (error == 17) {
		return 17;
	};
	if (error == 0) {
		(*grid_ptr)->LEVEL = INTERNAL;
		(*elem_ptr)->LEVEL = INTERNAL;
		strcpy((*elem_ptr)->NAME, ""ELEMENT"");
	};
	error = grgeodef(*curr_ptr, curr_ptr, addrem_ptr);
	if (error != 0) {
		parserro(*curr_ptr, 82, groupname);
		return 17;
	};
	error = grexcdef(*curr_ptr, curr_ptr, grampexc_ptr, grphaexc_ptr);
	if (error != 0) {
		parserro(*curr_ptr, 82, "" "");
		return 17;
	};
	error = (GetKeyword(Keywords[50], curr_ptr));
	if (error != 0) {",
1497,"int
groupdef(struct charac * p1, struct charac ** pp2,
	 struct Group ** group_ptr
)
{
	struct charac  *curr, **curr_ptr = &curr;
	int             error;
	char            groupname[UNLEN + 1];
	struct Grid    *grid = NULL, **grid_ptr = &grid;
	struct Elem    *elem = NULL, **elem_ptr = &elem;
	struct AddRem  *addrem = NULL, **addrem_ptr = &addrem;
	struct GrAmpExc *grampexc = NULL, **grampexc_ptr = &grampexc;
	struct GrPhaExc *grphaexc = NULL, **grphaexc_ptr = &grphaexc;
	struct Err     *err = NULL, **err_ptr = &err;
	struct Fail    *fail = NULL, **fail_ptr = &fail;
#ifdef DEBUG1
	printf(""\nFunzione groupdef()"");
#endif
	*curr_ptr = p1;
	error = 0;
	error = (GetKeyword(Keywords[47], abs(curr_ptr)));
	if (error != 0) {
		*group_ptr = NULL;
		return 1;
	};
	if (GetUName(groupname, curr_ptr) != 0) {
		parserro(*curr_ptr, 81, "" "");
		return 17;
	};
	if (InUNames(groupname)) {
		parserro(*curr_ptr, 3, groupname);
		return 17;
	};
	InserUN(groupname);
	error = greldef(*curr_ptr, curr_ptr, grid_ptr, elem_ptr);
	if (error == 17) {
		return 17;
	};
	if (error == 0) {
		(*grid_ptr)->LEVEL = INTERNAL;
		(*elem_ptr)->LEVEL = INTERNAL;
		strcpy((*elem_ptr)->NAME, ""ELEMENT"");
	};
	error = grgeodef(*curr_ptr, curr_ptr, addrem_ptr);
	if (error != 0) {
		parserro(*curr_ptr, 82, groupname);
		return 17;
	};
	error = grexcdef(*curr_ptr, curr_ptr, grampexc_ptr, grphaexc_ptr);
	if (error != 0) {
		parserro(*curr_ptr, 82, "" "");
		return 17;
	};
	error = (GetKeyword(Keywords[50], curr_ptr));
	if (error != 0) {","<mb:mutant#4d04f5261f0ba786d7d41531812cd61ad35936e2> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -4557 +4557 @@
-	error = (GetKeyword(Keywords[47], curr_ptr));
+	error = (GetKeyword(Keywords[47], abs(curr_ptr)));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Space.c> ."
1498,"int readfil3(char filename[UNLEN + 1], struct charac ** firstel, struct charac ** lastel)
{
	FILE           *f;
	char            c;
	struct charac  *p;
	int             line_num = 1;
	char            CR = '\n';
	char            adlfilename[UNLEN + 1];
#ifdef DEBUG3
	printf(""\nreadfil3()"");
#endif
	*firstel = NULL;
	*lastel = NULL;
	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) == NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c == EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c == CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p == NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c;
	p->LINE_NUM = line_num;
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = p;
	*lastel = p;
	printf(""\n"");
	c = (char) getc(f);
	while (c != EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c == CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{",
1499,"int readfil3(char filename[UNLEN + 1], struct charac ** firstel, struct charac ** lastel)
{
	FILE           *f;
	char            c;
	struct charac  *p;
	int             line_num = 1;
	char            CR = '\n';
	char            adlfilename[UNLEN + 1];
#ifdef DEBUG3
	printf(""\nreadfil3()"");
#endif
	*firstel = NULL;
	*lastel = NULL;
	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) == NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c <= EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c == CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p == NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c;
	p->LINE_NUM = line_num;
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = p;
	*lastel = p;
	printf(""\n"");
	c = (char) getc(f);
	while (c != EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c == CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{","<mb:mutant#9d885f5c3a0c5e0cc4d6b49fb12578cd1d1bd5b8> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -7117 +7117 @@
-	if (c == EOF)
+	if (c <= EOF)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Space.c> ."
1500,"	*lastel = NULL;
	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) == NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c == EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c == CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p == NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c;
	p->LINE_NUM = line_num;
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = p;
	*lastel = p;
	printf(""\n"");
	c = (char) getc(f);
	while (c != EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c == CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
            p->info = c;
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
			c = (char) getc(f);
		};
	};
	fclose(f);
	return 0;
}",
1501,"	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) == NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c == EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c == CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p == NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c;
	p->LINE_NUM = line_num;
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = p;
	*lastel = p;
	printf(""\n"");
	c = (char) getc(f);
	while (c != EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c == CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
            p->info = c;
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = abs(p);
			c = (char) getc(f);
		};
	};
	fclose(f);
	return 0;
}","<mb:mutant#29448dab08702689f46138e62ffca8dfd1cb1c3d> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -7188 +7188 @@
-			*lastel = p;
+			*lastel = abs(p);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Space.c> ."
1502,"	*lastel = NULL;
	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) == NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c == EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c == CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p == NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c;
	p->LINE_NUM = line_num;
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = p;
	*lastel = p;
	printf(""\n"");
	c = (char) getc(f);
	while (c != EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c == CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
            p->info = c;
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
			c = (char) getc(f);
		};
	};
	fclose(f);
	return 0;
}",
1503,"	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) == NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c == EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c == CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p == NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c;
	p->LINE_NUM = line_num;
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = p;
	*lastel = p;
	printf(""\n"");
	c = (char) getc(f);
	while (c != EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c == CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
            p->info = c;
			p->LINE_NUM = abs(line_num);
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
			c = (char) getc(f);
		};
	};
	fclose(f);
	return 0;
}","<mb:mutant#53ef75ee9fb3e060b13201a49618c389903997b8> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -7183 +7183 @@
-			p->LINE_NUM = line_num;
+			p->LINE_NUM = abs(line_num);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Space.c> ."
1504,"int
groupdef(struct charac * p1, struct charac ** pp2,
	 struct Group ** group_ptr
)
{
	struct charac  *curr, **curr_ptr = &curr;
	int             error;
	char            groupname[UNLEN + 1];
	struct Grid    *grid = NULL, **grid_ptr = &grid;
	struct Elem    *elem = NULL, **elem_ptr = &elem;
	struct AddRem  *addrem = NULL, **addrem_ptr = &addrem;
	struct GrAmpExc *grampexc = NULL, **grampexc_ptr = &grampexc;
	struct GrPhaExc *grphaexc = NULL, **grphaexc_ptr = &grphaexc;
	struct Err     *err = NULL, **err_ptr = &err;
	struct Fail    *fail = NULL, **fail_ptr = &fail;
#ifdef DEBUG1
	printf(""\nFunzione groupdef()"");
#endif
	*curr_ptr = p1;
	error = 0;
	error = (GetKeyword(Keywords[47], curr_ptr));
	if (error != 0) {
		*group_ptr = NULL;
		return 1;
	};
	if (GetUName(groupname, curr_ptr) != 0) {
		parserro(*curr_ptr, 81, "" "");
		return 17;
	};
	if (InUNames(groupname)) {
		parserro(*curr_ptr, 3, groupname);
		return 17;
	};
	InserUN(groupname);
	error = greldef(*curr_ptr, curr_ptr, grid_ptr, elem_ptr);
	if (error == 17) {
		return 17;
	};
	if (error == 0) {
		(*grid_ptr)->LEVEL = INTERNAL;
		(*elem_ptr)->LEVEL = INTERNAL;
		strcpy((*elem_ptr)->NAME, ""ELEMENT"");
	};
	error = grgeodef(*curr_ptr, curr_ptr, addrem_ptr);
	if (error != 0) {
		parserro(*curr_ptr, 82, groupname);
		return 17;
	};
	error = grexcdef(*curr_ptr, curr_ptr, grampexc_ptr, grphaexc_ptr);
	if (error != 0) {
		parserro(*curr_ptr, 82, "" "");
		return 17;
	};
	error = (GetKeyword(Keywords[50], curr_ptr));
	if (error != 0) {",
1505,"int
groupdef(struct charac * p1, struct charac ** pp2,
	 struct Group ** group_ptr
)
{
	struct charac  *curr, **curr_ptr = &curr;
	int             error;
	char            groupname[UNLEN + 1];
	struct Grid    *grid = NULL, **grid_ptr = &grid;
	struct Elem    *elem = NULL, **elem_ptr = &elem;
	struct AddRem  *addrem = NULL, **addrem_ptr = &addrem;
	struct GrAmpExc *grampexc = NULL, **grampexc_ptr = &grampexc;
	struct GrPhaExc *grphaexc = NULL, **grphaexc_ptr = &grphaexc;
	struct Err     *err = NULL, **err_ptr = &err;
	struct Fail    *fail = NULL, **fail_ptr = &fail;
#ifdef DEBUG1
	printf(""\nFunzione groupdef()"");
#endif
	*curr_ptr = p1;
	error = 0;
	error = (GetKeyword(abs(Keywords[47]), curr_ptr));
	if (error != 0) {
		*group_ptr = NULL;
		return 1;
	};
	if (GetUName(groupname, curr_ptr) != 0) {
		parserro(*curr_ptr, 81, "" "");
		return 17;
	};
	if (InUNames(groupname)) {
		parserro(*curr_ptr, 3, groupname);
		return 17;
	};
	InserUN(groupname);
	error = greldef(*curr_ptr, curr_ptr, grid_ptr, elem_ptr);
	if (error == 17) {
		return 17;
	};
	if (error == 0) {
		(*grid_ptr)->LEVEL = INTERNAL;
		(*elem_ptr)->LEVEL = INTERNAL;
		strcpy((*elem_ptr)->NAME, ""ELEMENT"");
	};
	error = grgeodef(*curr_ptr, curr_ptr, addrem_ptr);
	if (error != 0) {
		parserro(*curr_ptr, 82, groupname);
		return 17;
	};
	error = grexcdef(*curr_ptr, curr_ptr, grampexc_ptr, grphaexc_ptr);
	if (error != 0) {
		parserro(*curr_ptr, 82, "" "");
		return 17;
	};
	error = (GetKeyword(Keywords[50], curr_ptr));
	if (error != 0) {","<mb:mutant#f2b0ec928addf4b2d077986c529a6b44d01e9458> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -4557 +4557 @@
-	error = (GetKeyword(Keywords[47], curr_ptr));
+	error = (GetKeyword(abs(Keywords[47]), curr_ptr));
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Space.c> ."
1506,"	*lastel = NULL;
	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) == NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c == EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c == CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p == NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c;
	p->LINE_NUM = line_num;
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = p;
	*lastel = p;
	printf(""\n"");
	c = (char) getc(f);
	while (c != EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c == CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
            p->info = c;
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
			c = (char) getc(f);
		};
	};
	fclose(f);
	return 0;
}",
1507,"	*lastel = NULL;
	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) == NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c == EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c == CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p == NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c;
	p->LINE_NUM = line_num;
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = p;
	*lastel = p;
	printf(""\n"");
	c = (char) getc(f);
	while (c != EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c == CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p <= NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
            p->info = c;
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
			c = (char) getc(f);
		};
	};
	fclose(f);
	return 0;
}","<mb:mutant#c3a8673fced55001179e4faa3f41c42e7831cbd4> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -7176 +7176 @@
-			if (p == NULL)
+			if (p <= NULL)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Space.c> ."
1508,"int readfil3(char filename[UNLEN + 1], struct charac ** firstel, struct charac ** lastel)
{
	FILE           *f;
	char            c;
	struct charac  *p;
	int             line_num = 1;
	char            CR = '\n';
	char            adlfilename[UNLEN + 1];
#ifdef DEBUG3
	printf(""\nreadfil3()"");
#endif
	*firstel = NULL;
	*lastel = NULL;
	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) == NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c == EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c == CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p == NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c;
	p->LINE_NUM = line_num;
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = p;
	*lastel = p;
	printf(""\n"");
	c = (char) getc(f);
	while (c != EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c == CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{",
1509,"int readfil3(char filename[UNLEN + 1], struct charac ** firstel, struct charac ** lastel)
{
	FILE           *f;
	char            c;
	struct charac  *p;
	int             line_num = 1;
	char            CR = '\n';
	char            adlfilename[UNLEN + 1];
#ifdef DEBUG3
	printf(""\nreadfil3()"");
#endif
	*firstel = NULL;
	*lastel = NULL;
	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) == NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c == EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c == CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p <= NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c;
	p->LINE_NUM = line_num;
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = p;
	*lastel = p;
	printf(""\n"");
	c = (char) getc(f);
	while (c != EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c == CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{","<mb:mutant#77355dbd95a47ca91ad82b03c19eb54ba99e7d5c> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -7132 +7132 @@
-	if (p == NULL) {
+	if (p <= NULL) {
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Space.c> ."
1510,"	*lastel = NULL;
	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) == NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c == EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c == CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p == NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c;
	p->LINE_NUM = line_num;
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = p;
	*lastel = p;
	printf(""\n"");
	c = (char) getc(f);
	while (c != EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c == CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
            p->info = c;
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
			c = (char) getc(f);
		};
	};
	fclose(f);
	return 0;
}",
1511,"	*lastel = NULL;
	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) == NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c == EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c == CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p == NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c;
	p->LINE_NUM = line_num;
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = p;
	*lastel = p;
	printf(""\n"");
	c = (char) getc(f);
	while (c != EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c == CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p <= NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
            p->info = c;
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
			c = (char) getc(f);
		};
	};
	fclose(f);
	return 0;
}","<mb:mutant#1098283a8a4eb7b8addaf19ab6ab145fd89bc0a2> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -7161 +7161 @@
-			if (p == NULL)
+			if (p <= NULL)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Space.c> ."
1512,")
{
	struct charac  *curr, **curr_ptr = &curr;
	int             error;
	char            groupname[UNLEN + 1];
	struct Grid    *grid = NULL, **grid_ptr = &grid;
	struct Elem    *elem = NULL, **elem_ptr = &elem;
	struct AddRem  *addrem = NULL, **addrem_ptr = &addrem;
	struct GrAmpExc *grampexc = NULL, **grampexc_ptr = &grampexc;
	struct GrPhaExc *grphaexc = NULL, **grphaexc_ptr = &grphaexc;
	struct Err     *err = NULL, **err_ptr = &err;
	struct Fail    *fail = NULL, **fail_ptr = &fail;
#ifdef DEBUG1
	printf(""\nFunzione groupdef()"");
#endif
	*curr_ptr = p1;
	error = 0;
	error = (GetKeyword(Keywords[47], curr_ptr));
	if (error != 0) {
		*group_ptr = NULL;
		return 1;
	};
	if (GetUName(groupname, curr_ptr) != 0) {
		parserro(*curr_ptr, 81, "" "");
		return 17;
	};
	if (InUNames(groupname)) {
		parserro(*curr_ptr, 3, groupname);
		return 17;
	};
	InserUN(groupname);
	error = greldef(*curr_ptr, curr_ptr, grid_ptr, elem_ptr);
	if (error == 17) {
		return 17;
	};
	if (error == 0) {
		(*grid_ptr)->LEVEL = INTERNAL;
		(*elem_ptr)->LEVEL = INTERNAL;
		strcpy((*elem_ptr)->NAME, ""ELEMENT"");
	};
	error = grgeodef(*curr_ptr, curr_ptr, addrem_ptr);
	if (error != 0) {
		parserro(*curr_ptr, 82, groupname);
		return 17;
	};
	error = grexcdef(*curr_ptr, curr_ptr, grampexc_ptr, grphaexc_ptr);
	if (error != 0) {
		parserro(*curr_ptr, 82, "" "");
		return 17;
	};
	error = (GetKeyword(Keywords[50], curr_ptr));
	if (error != 0) {
		parserro(*curr_ptr, 1, Keywords[50]);
		return 17;
	};
	*group_ptr = (struct Group *) malloc(sizeof(struct Group));",
1513,"{
	struct charac  *curr, **curr_ptr = &curr;
	int             error;
	char            groupname[UNLEN + 1];
	struct Grid    *grid = NULL, **grid_ptr = &grid;
	struct Elem    *elem = NULL, **elem_ptr = &elem;
	struct AddRem  *addrem = NULL, **addrem_ptr = &addrem;
	struct GrAmpExc *grampexc = NULL, **grampexc_ptr = &grampexc;
	struct GrPhaExc *grphaexc = NULL, **grphaexc_ptr = &grphaexc;
	struct Err     *err = NULL, **err_ptr = &err;
	struct Fail    *fail = NULL, **fail_ptr = &fail;
#ifdef DEBUG1
	printf(""\nFunzione groupdef()"");
#endif
	*curr_ptr = p1;
	error = 0;
	error = (GetKeyword(Keywords[47], curr_ptr));
	if (error != 0) {
		*group_ptr = NULL;
		return 1;
	};
	if (GetUName(groupname, curr_ptr) != 0) {
		parserro(*curr_ptr, 81, "" "");
		return 17;
	};
	if (InUNames(groupname)) {
		parserro(abs(*curr_ptr), 3, groupname);
		return 17;
	};
	InserUN(groupname);
	error = greldef(*curr_ptr, curr_ptr, grid_ptr, elem_ptr);
	if (error == 17) {
		return 17;
	};
	if (error == 0) {
		(*grid_ptr)->LEVEL = INTERNAL;
		(*elem_ptr)->LEVEL = INTERNAL;
		strcpy((*elem_ptr)->NAME, ""ELEMENT"");
	};
	error = grgeodef(*curr_ptr, curr_ptr, addrem_ptr);
	if (error != 0) {
		parserro(*curr_ptr, 82, groupname);
		return 17;
	};
	error = grexcdef(*curr_ptr, curr_ptr, grampexc_ptr, grphaexc_ptr);
	if (error != 0) {
		parserro(*curr_ptr, 82, "" "");
		return 17;
	};
	error = (GetKeyword(Keywords[50], curr_ptr));
	if (error != 0) {
		parserro(*curr_ptr, 1, Keywords[50]);
		return 17;
	};
	*group_ptr = (struct Group *) malloc(sizeof(struct Group));","<mb:mutant#cbc314875f74a6211ccaa415d76ca3aa483966e8> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -4572 +4572 @@
-		parserro(*curr_ptr, 3, groupname);
+		parserro(abs(*curr_ptr), 3, groupname);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Space.c> ."
1514,"int
groupdef(struct charac * p1, struct charac ** pp2,
	 struct Group ** group_ptr
)
{
	struct charac  *curr, **curr_ptr = &curr;
	int             error;
	char            groupname[UNLEN + 1];
	struct Grid    *grid = NULL, **grid_ptr = &grid;
	struct Elem    *elem = NULL, **elem_ptr = &elem;
	struct AddRem  *addrem = NULL, **addrem_ptr = &addrem;
	struct GrAmpExc *grampexc = NULL, **grampexc_ptr = &grampexc;
	struct GrPhaExc *grphaexc = NULL, **grphaexc_ptr = &grphaexc;
	struct Err     *err = NULL, **err_ptr = &err;
	struct Fail    *fail = NULL, **fail_ptr = &fail;
#ifdef DEBUG1
	printf(""\nFunzione groupdef()"");
#endif
	*curr_ptr = p1;
	error = 0;
	error = (GetKeyword(Keywords[47], curr_ptr));
	if (error != 0) {
		*group_ptr = NULL;
		return 1;
	};
	if (GetUName(groupname, curr_ptr) != 0) {
		parserro(*curr_ptr, 81, "" "");
		return 17;
	};
	if (InUNames(groupname)) {
		parserro(*curr_ptr, 3, groupname);
		return 17;
	};
	InserUN(groupname);
	error = greldef(*curr_ptr, curr_ptr, grid_ptr, elem_ptr);
	if (error == 17) {
		return 17;
	};
	if (error == 0) {
		(*grid_ptr)->LEVEL = INTERNAL;
		(*elem_ptr)->LEVEL = INTERNAL;
		strcpy((*elem_ptr)->NAME, ""ELEMENT"");
	};
	error = grgeodef(*curr_ptr, curr_ptr, addrem_ptr);
	if (error != 0) {
		parserro(*curr_ptr, 82, groupname);
		return 17;
	};
	error = grexcdef(*curr_ptr, curr_ptr, grampexc_ptr, grphaexc_ptr);
	if (error != 0) {
		parserro(*curr_ptr, 82, "" "");
		return 17;
	};
	error = (GetKeyword(Keywords[50], curr_ptr));
	if (error != 0) {",
1515,"int
groupdef(struct charac * p1, struct charac ** pp2,
	 struct Group ** group_ptr
)
{
	struct charac  *curr, **curr_ptr = &curr;
	int             error;
	char            groupname[UNLEN + 1];
	struct Grid    *grid = NULL, **grid_ptr = &grid;
	struct Elem    *elem = NULL, **elem_ptr = &elem;
	struct AddRem  *addrem = NULL, **addrem_ptr = &addrem;
	struct GrAmpExc *grampexc = NULL, **grampexc_ptr = &grampexc;
	struct GrPhaExc *grphaexc = NULL, **grphaexc_ptr = &grphaexc;
	struct Err     *err = NULL, **err_ptr = &err;
	struct Fail    *fail = NULL, **fail_ptr = &fail;
#ifdef DEBUG1
	printf(""\nFunzione groupdef()"");
#endif
	*curr_ptr = p1;
	error = 0;
	error = (GetKeyword(Keywords[47], curr_ptr));
	if (error > 0) {
		*group_ptr = NULL;
		return 1;
	};
	if (GetUName(groupname, curr_ptr) != 0) {
		parserro(*curr_ptr, 81, "" "");
		return 17;
	};
	if (InUNames(groupname)) {
		parserro(*curr_ptr, 3, groupname);
		return 17;
	};
	InserUN(groupname);
	error = greldef(*curr_ptr, curr_ptr, grid_ptr, elem_ptr);
	if (error == 17) {
		return 17;
	};
	if (error == 0) {
		(*grid_ptr)->LEVEL = INTERNAL;
		(*elem_ptr)->LEVEL = INTERNAL;
		strcpy((*elem_ptr)->NAME, ""ELEMENT"");
	};
	error = grgeodef(*curr_ptr, curr_ptr, addrem_ptr);
	if (error != 0) {
		parserro(*curr_ptr, 82, groupname);
		return 17;
	};
	error = grexcdef(*curr_ptr, curr_ptr, grampexc_ptr, grphaexc_ptr);
	if (error != 0) {
		parserro(*curr_ptr, 82, "" "");
		return 17;
	};
	error = (GetKeyword(Keywords[50], curr_ptr));
	if (error != 0) {","<mb:mutant#1ffd2b0cff32d53369d5cd240aa39420e21bcb05> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -4558 +4558 @@
-	if (error != 0) {
+	if (error > 0) {
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Space.c> ."
1516,"		parserro(*curr_ptr, 81, "" "");
		return 17;
	};
	if (InUNames(groupname)) {
		parserro(*curr_ptr, 3, groupname);
		return 17;
	};
	InserUN(groupname);
	error = greldef(*curr_ptr, curr_ptr, grid_ptr, elem_ptr);
	if (error == 17) {
		return 17;
	};
	if (error == 0) {
		(*grid_ptr)->LEVEL = INTERNAL;
		(*elem_ptr)->LEVEL = INTERNAL;
		strcpy((*elem_ptr)->NAME, ""ELEMENT"");
	};
	error = grgeodef(*curr_ptr, curr_ptr, addrem_ptr);
	if (error != 0) {
		parserro(*curr_ptr, 82, groupname);
		return 17;
	};
	error = grexcdef(*curr_ptr, curr_ptr, grampexc_ptr, grphaexc_ptr);
	if (error != 0) {
		parserro(*curr_ptr, 82, "" "");
		return 17;
	};
	error = (GetKeyword(Keywords[50], curr_ptr));
	if (error != 0) {
		parserro(*curr_ptr, 1, Keywords[50]);
		return 17;
	};
	*group_ptr = (struct Group *) malloc(sizeof(struct Group));
	if (*group_ptr == NULL) {
		parserro(*curr_ptr, 55, "" "");
		interror(""groupdef()"");
	};
	strcpy((*group_ptr)->NAME, groupname);
	(*group_ptr)->NUM_OF_NODES = 0;
	(*group_ptr)->SHAPE = NO_SHAPE;
	(*group_ptr)->PSIZE = 0;
	(*group_ptr)->QSIZE = 0;
	(*group_ptr)->GRID_PTR = *grid_ptr;
	(*group_ptr)->ELEM_PTR = *elem_ptr;
	(*group_ptr)->GRAMPEXC_PTR = *grampexc_ptr;
	(*group_ptr)->GRPHAEXC_PTR = *grphaexc_ptr;
	(*group_ptr)->ADDREM_PTR = *addrem_ptr;
	(*group_ptr)->ERR_PTR = *err_ptr;
	(*group_ptr)->FAIL_PTR = *fail_ptr;
	(*group_ptr)->GEOMNODE_PTR = NULL;
	(*group_ptr)->BUILT = NO;
	(*group_ptr)->SUPER_GROUP_PTR[0] = NULL;
	*pp2 = *curr_ptr;
	return 0;
}",
1517,"		parserro(*curr_ptr, 81, "" "");
		return 17;
	};
	if (InUNames(groupname)) {
		parserro(*curr_ptr, 3, groupname);
		return 17;
	};
	InserUN(groupname);
	error = greldef(*curr_ptr, curr_ptr, grid_ptr, elem_ptr);
	if (error == 17) {
		return 17;
	};
	if (error == 0) {
		(*grid_ptr)->LEVEL = INTERNAL;
		(*elem_ptr)->LEVEL = INTERNAL;
		strcpy((*elem_ptr)->NAME, ""ELEMENT"");
	};
	error = grgeodef(*curr_ptr, curr_ptr, addrem_ptr);
	if (error != 0) {
		parserro(*curr_ptr, 82, groupname);
		return 17;
	};
	error = grexcdef(*curr_ptr, curr_ptr, grampexc_ptr, grphaexc_ptr);
	if (error != 0) {
		parserro(*curr_ptr, 82, "" "");
		return 17;
	};
	error = (GetKeyword(Keywords[50], curr_ptr));
	if (error != 0) {
		parserro(*curr_ptr, 1, Keywords[50]);
		return 17;
	};
	*group_ptr = (struct Group *) malloc(sizeof(struct Group));
	if (*group_ptr == NULL) {
		parserro(*curr_ptr, 55, "" "");
		interror(""groupdef()"");
	};
	strcpy((*group_ptr)->NAME, groupname);
	(*group_ptr)->NUM_OF_NODES = 0;
	(*group_ptr)->SHAPE = NO_SHAPE;
	(*group_ptr)->PSIZE = 0;
	(*group_ptr)->QSIZE = 0;
	(*group_ptr)->GRID_PTR = *grid_ptr;
	(*group_ptr)->ELEM_PTR = *elem_ptr;
	(*group_ptr)->GRAMPEXC_PTR = *grampexc_ptr;
	(*group_ptr)->GRPHAEXC_PTR = *grphaexc_ptr;
	(*group_ptr)->ADDREM_PTR = *addrem_ptr;
	(*group_ptr)->ERR_PTR = *err_ptr;
	(*group_ptr)->FAIL_PTR = *fail_ptr;
	(*group_ptr)->GEOMNODE_PTR = NULL;
	(*group_ptr)->BUILT = NO;
	(*group_ptr)->SUPER_GROUP_PTR[0] = NULL;
	*pp2 = abs(*curr_ptr);
	return 0;
}","<mb:mutant#f76937ef4f58606098a3e9949b834daaa9fa74ba> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -4659 +4659 @@
-	*pp2 = *curr_ptr;
+	*pp2 = abs(*curr_ptr);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Space.c> ."
1518,"int
groupdef(struct charac * p1, struct charac ** pp2,
	 struct Group ** group_ptr
)
{
	struct charac  *curr, **curr_ptr = &curr;
	int             error;
	char            groupname[UNLEN + 1];
	struct Grid    *grid = NULL, **grid_ptr = &grid;
	struct Elem    *elem = NULL, **elem_ptr = &elem;
	struct AddRem  *addrem = NULL, **addrem_ptr = &addrem;
	struct GrAmpExc *grampexc = NULL, **grampexc_ptr = &grampexc;
	struct GrPhaExc *grphaexc = NULL, **grphaexc_ptr = &grphaexc;
	struct Err     *err = NULL, **err_ptr = &err;
	struct Fail    *fail = NULL, **fail_ptr = &fail;
#ifdef DEBUG1
	printf(""\nFunzione groupdef()"");
#endif
	*curr_ptr = p1;
	error = 0;
	error = (GetKeyword(Keywords[47], curr_ptr));
	if (error != 0) {
		*group_ptr = NULL;
		return 1;
	};
	if (GetUName(groupname, curr_ptr) != 0) {
		parserro(*curr_ptr, 81, "" "");
		return 17;
	};
	if (InUNames(groupname)) {
		parserro(*curr_ptr, 3, groupname);
		return 17;
	};
	InserUN(groupname);
	error = greldef(*curr_ptr, curr_ptr, grid_ptr, elem_ptr);
	if (error == 17) {
		return 17;
	};
	if (error == 0) {
		(*grid_ptr)->LEVEL = INTERNAL;
		(*elem_ptr)->LEVEL = INTERNAL;
		strcpy((*elem_ptr)->NAME, ""ELEMENT"");
	};
	error = grgeodef(*curr_ptr, curr_ptr, addrem_ptr);
	if (error != 0) {
		parserro(*curr_ptr, 82, groupname);
		return 17;
	};
	error = grexcdef(*curr_ptr, curr_ptr, grampexc_ptr, grphaexc_ptr);
	if (error != 0) {
		parserro(*curr_ptr, 82, "" "");
		return 17;
	};
	error = (GetKeyword(Keywords[50], curr_ptr));
	if (error != 0) {",
1519,"int
groupdef(struct charac * p1, struct charac ** pp2,
	 struct Group ** group_ptr
)
{
	struct charac  *curr, **curr_ptr = &curr;
	int             error;
	char            groupname[UNLEN + 1];
	struct Grid    *grid = NULL, **grid_ptr = &grid;
	struct Elem    *elem = NULL, **elem_ptr = &elem;
	struct AddRem  *addrem = NULL, **addrem_ptr = &addrem;
	struct GrAmpExc *grampexc = NULL, **grampexc_ptr = &grampexc;
	struct GrPhaExc *grphaexc = NULL, **grphaexc_ptr = &grphaexc;
	struct Err     *err = NULL, **err_ptr = &err;
	struct Fail    *fail = NULL, **fail_ptr = &fail;
#ifdef DEBUG1
	printf(""\nFunzione groupdef()"");
#endif
	*curr_ptr = abs(p1);
	error = 0;
	error = (GetKeyword(Keywords[47], curr_ptr));
	if (error != 0) {
		*group_ptr = NULL;
		return 1;
	};
	if (GetUName(groupname, curr_ptr) != 0) {
		parserro(*curr_ptr, 81, "" "");
		return 17;
	};
	if (InUNames(groupname)) {
		parserro(*curr_ptr, 3, groupname);
		return 17;
	};
	InserUN(groupname);
	error = greldef(*curr_ptr, curr_ptr, grid_ptr, elem_ptr);
	if (error == 17) {
		return 17;
	};
	if (error == 0) {
		(*grid_ptr)->LEVEL = INTERNAL;
		(*elem_ptr)->LEVEL = INTERNAL;
		strcpy((*elem_ptr)->NAME, ""ELEMENT"");
	};
	error = grgeodef(*curr_ptr, curr_ptr, addrem_ptr);
	if (error != 0) {
		parserro(*curr_ptr, 82, groupname);
		return 17;
	};
	error = grexcdef(*curr_ptr, curr_ptr, grampexc_ptr, grphaexc_ptr);
	if (error != 0) {
		parserro(*curr_ptr, 82, "" "");
		return 17;
	};
	error = (GetKeyword(Keywords[50], curr_ptr));
	if (error != 0) {","<mb:mutant#87663a8ac9d7f09d5390dad8cd60ac34a3bac009> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -4553 +4553 @@
-	*curr_ptr = p1;
+	*curr_ptr = abs(p1);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Space.c> ."
1520,"int
groupdef(struct charac * p1, struct charac ** pp2,
	 struct Group ** group_ptr
)
{
	struct charac  *curr, **curr_ptr = &curr;
	int             error;
	char            groupname[UNLEN + 1];
	struct Grid    *grid = NULL, **grid_ptr = &grid;
	struct Elem    *elem = NULL, **elem_ptr = &elem;
	struct AddRem  *addrem = NULL, **addrem_ptr = &addrem;
	struct GrAmpExc *grampexc = NULL, **grampexc_ptr = &grampexc;
	struct GrPhaExc *grphaexc = NULL, **grphaexc_ptr = &grphaexc;
	struct Err     *err = NULL, **err_ptr = &err;
	struct Fail    *fail = NULL, **fail_ptr = &fail;
#ifdef DEBUG1
	printf(""\nFunzione groupdef()"");
#endif
	*curr_ptr = p1;
	error = 0;
	error = (GetKeyword(Keywords[47], curr_ptr));
	if (error != 0) {
		*group_ptr = NULL;
		return 1;
	};
	if (GetUName(groupname, curr_ptr) != 0) {
		parserro(*curr_ptr, 81, "" "");
		return 17;
	};
	if (InUNames(groupname)) {
		parserro(*curr_ptr, 3, groupname);
		return 17;
	};
	InserUN(groupname);
	error = greldef(*curr_ptr, curr_ptr, grid_ptr, elem_ptr);
	if (error == 17) {
		return 17;
	};
	if (error == 0) {
		(*grid_ptr)->LEVEL = INTERNAL;
		(*elem_ptr)->LEVEL = INTERNAL;
		strcpy((*elem_ptr)->NAME, ""ELEMENT"");
	};
	error = grgeodef(*curr_ptr, curr_ptr, addrem_ptr);
	if (error != 0) {
		parserro(*curr_ptr, 82, groupname);
		return 17;
	};
	error = grexcdef(*curr_ptr, curr_ptr, grampexc_ptr, grphaexc_ptr);
	if (error != 0) {
		parserro(*curr_ptr, 82, "" "");
		return 17;
	};
	error = (GetKeyword(Keywords[50], curr_ptr));
	if (error != 0) {",
1521,"int
groupdef(struct charac * p1, struct charac ** pp2,
	 struct Group ** group_ptr
)
{
	struct charac  *curr, **curr_ptr = &curr;
	int             error;
	char            groupname[UNLEN + 1];
	struct Grid    *grid = NULL, **grid_ptr = &grid;
	struct Elem    *elem = NULL, **elem_ptr = &elem;
	struct AddRem  *addrem = NULL, **addrem_ptr = &addrem;
	struct GrAmpExc *grampexc = NULL, **grampexc_ptr = &grampexc;
	struct GrPhaExc *grphaexc = NULL, **grphaexc_ptr = &grphaexc;
	struct Err     *err = NULL, **err_ptr = &err;
	struct Fail    *fail = NULL, **fail_ptr = &fail;
#ifdef DEBUG1
	printf(""\nFunzione groupdef()"");
#endif
	*curr_ptr = p1;
	error = 0;
	error = (GetKeyword(Keywords[47], curr_ptr));
	if (error != 0) {
		*group_ptr = NULL;
		return 1;
	};
	if (GetUName(abs(groupname), curr_ptr) != 0) {
		parserro(*curr_ptr, 81, "" "");
		return 17;
	};
	if (InUNames(groupname)) {
		parserro(*curr_ptr, 3, groupname);
		return 17;
	};
	InserUN(groupname);
	error = greldef(*curr_ptr, curr_ptr, grid_ptr, elem_ptr);
	if (error == 17) {
		return 17;
	};
	if (error == 0) {
		(*grid_ptr)->LEVEL = INTERNAL;
		(*elem_ptr)->LEVEL = INTERNAL;
		strcpy((*elem_ptr)->NAME, ""ELEMENT"");
	};
	error = grgeodef(*curr_ptr, curr_ptr, addrem_ptr);
	if (error != 0) {
		parserro(*curr_ptr, 82, groupname);
		return 17;
	};
	error = grexcdef(*curr_ptr, curr_ptr, grampexc_ptr, grphaexc_ptr);
	if (error != 0) {
		parserro(*curr_ptr, 82, "" "");
		return 17;
	};
	error = (GetKeyword(Keywords[50], curr_ptr));
	if (error != 0) {","<mb:mutant#37cd277a76f22f6c10278871d87631b3c88b2e86> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -4564 +4564 @@
-	if (GetUName(groupname, curr_ptr) != 0) {
+	if (GetUName(abs(groupname), curr_ptr) != 0) {
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Space.c> ."
1522,"int readfil3(char filename[UNLEN + 1], struct charac ** firstel, struct charac ** lastel)
{
	FILE           *f;
	char            c;
	struct charac  *p;
	int             line_num = 1;
	char            CR = '\n';
	char            adlfilename[UNLEN + 1];
#ifdef DEBUG3
	printf(""\nreadfil3()"");
#endif
	*firstel = NULL;
	*lastel = NULL;
	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) == NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c == EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c == CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p == NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c;
	p->LINE_NUM = line_num;
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = p;
	*lastel = p;
	printf(""\n"");
	c = (char) getc(f);
	while (c != EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c == CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{",
1523,"int readfil3(char filename[UNLEN + 1], struct charac ** firstel, struct charac ** lastel)
{
	FILE           *f;
	char            c;
	struct charac  *p;
	int             line_num = 1;
	char            CR = '\n';
	char            adlfilename[UNLEN + 1];
#ifdef DEBUG3
	printf(""\nreadfil3()"");
#endif
	*firstel = NULL;
	*lastel = NULL;
	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) == NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c == EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c <= CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p == NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c;
	p->LINE_NUM = line_num;
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = p;
	*lastel = p;
	printf(""\n"");
	c = (char) getc(f);
	while (c != EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c == CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{","<mb:mutant#173c987683af12204320a7377622aded3d46b33f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -7126 +7126 @@
-		if (c == CR)
+		if (c <= CR)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Space.c> ."
1524,"	*lastel = NULL;
	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) == NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c == EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c == CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p == NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c;
	p->LINE_NUM = line_num;
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = p;
	*lastel = p;
	printf(""\n"");
	c = (char) getc(f);
	while (c != EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c == CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
            p->info = c;
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
			c = (char) getc(f);
		};
	};
	fclose(f);
	return 0;
}",
1525,"	*lastel = NULL;
	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) == NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c == EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c == CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p == NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c;
	p->LINE_NUM = line_num;
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = p;
	*lastel = p;
	printf(""\n"");
	c = (char) getc(f);
	while (c > EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c == CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
            p->info = c;
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
			c = (char) getc(f);
		};
	};
	fclose(f);
	return 0;
}","<mb:mutant#1cc7f04e96b913d9c3e894e977f1699c07b0f362> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -7149 +7149 @@
-	while (c != EOF)
+	while (c > EOF)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Space.c> ."
1526,"int
groupdef(struct charac * p1, struct charac ** pp2,
	 struct Group ** group_ptr
)
{
	struct charac  *curr, **curr_ptr = &curr;
	int             error;
	char            groupname[UNLEN + 1];
	struct Grid    *grid = NULL, **grid_ptr = &grid;
	struct Elem    *elem = NULL, **elem_ptr = &elem;
	struct AddRem  *addrem = NULL, **addrem_ptr = &addrem;
	struct GrAmpExc *grampexc = NULL, **grampexc_ptr = &grampexc;
	struct GrPhaExc *grphaexc = NULL, **grphaexc_ptr = &grphaexc;
	struct Err     *err = NULL, **err_ptr = &err;
	struct Fail    *fail = NULL, **fail_ptr = &fail;
#ifdef DEBUG1
	printf(""\nFunzione groupdef()"");
#endif
	*curr_ptr = p1;
	error = 0;
	error = (GetKeyword(Keywords[47], curr_ptr));
	if (error != 0) {
		*group_ptr = NULL;
		return 1;
	};
	if (GetUName(groupname, curr_ptr) != 0) {
		parserro(*curr_ptr, 81, "" "");
		return 17;
	};
	if (InUNames(groupname)) {
		parserro(*curr_ptr, 3, groupname);
		return 17;
	};
	InserUN(groupname);
	error = greldef(*curr_ptr, curr_ptr, grid_ptr, elem_ptr);
	if (error == 17) {
		return 17;
	};
	if (error == 0) {
		(*grid_ptr)->LEVEL = INTERNAL;
		(*elem_ptr)->LEVEL = INTERNAL;
		strcpy((*elem_ptr)->NAME, ""ELEMENT"");
	};
	error = grgeodef(*curr_ptr, curr_ptr, addrem_ptr);
	if (error != 0) {
		parserro(*curr_ptr, 82, groupname);
		return 17;
	};
	error = grexcdef(*curr_ptr, curr_ptr, grampexc_ptr, grphaexc_ptr);
	if (error != 0) {
		parserro(*curr_ptr, 82, "" "");
		return 17;
	};
	error = (GetKeyword(Keywords[50], curr_ptr));
	if (error != 0) {",
1527,"int
groupdef(struct charac * p1, struct charac ** pp2,
	 struct Group ** group_ptr
)
{
	struct charac  *curr, **curr_ptr = &curr;
	int             error;
	char            groupname[UNLEN + 1];
	struct Grid    *grid = NULL, **grid_ptr = &grid;
	struct Elem    *elem = NULL, **elem_ptr = &elem;
	struct AddRem  *addrem = NULL, **addrem_ptr = &addrem;
	struct GrAmpExc *grampexc = NULL, **grampexc_ptr = &grampexc;
	struct GrPhaExc *grphaexc = NULL, **grphaexc_ptr = &grphaexc;
	struct Err     *err = NULL, **err_ptr = &err;
	struct Fail    *fail = NULL, **fail_ptr = &fail;
#ifdef DEBUG1
	printf(""\nFunzione groupdef()"");
#endif
	*curr_ptr = p1;
	error = 0;
	error = (GetKeyword(Keywords[47], curr_ptr));
	if (error != 0) {
		*group_ptr = NULL;
		return 1;
	};
	if (GetUName(groupname, curr_ptr) > 0) {
		parserro(*curr_ptr, 81, "" "");
		return 17;
	};
	if (InUNames(groupname)) {
		parserro(*curr_ptr, 3, groupname);
		return 17;
	};
	InserUN(groupname);
	error = greldef(*curr_ptr, curr_ptr, grid_ptr, elem_ptr);
	if (error == 17) {
		return 17;
	};
	if (error == 0) {
		(*grid_ptr)->LEVEL = INTERNAL;
		(*elem_ptr)->LEVEL = INTERNAL;
		strcpy((*elem_ptr)->NAME, ""ELEMENT"");
	};
	error = grgeodef(*curr_ptr, curr_ptr, addrem_ptr);
	if (error != 0) {
		parserro(*curr_ptr, 82, groupname);
		return 17;
	};
	error = grexcdef(*curr_ptr, curr_ptr, grampexc_ptr, grphaexc_ptr);
	if (error != 0) {
		parserro(*curr_ptr, 82, "" "");
		return 17;
	};
	error = (GetKeyword(Keywords[50], curr_ptr));
	if (error != 0) {","<mb:mutant#774ca8a4d06ffba524f0ca52feb62f1cbfc5e2d7> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -4564 +4564 @@
-	if (GetUName(groupname, curr_ptr) != 0) {
+	if (GetUName(groupname, curr_ptr) > 0) {
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Space.c> ."
1528,"	*lastel = NULL;
	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) == NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c == EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c == CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p == NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c;
	p->LINE_NUM = line_num;
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = p;
	*lastel = p;
	printf(""\n"");
	c = (char) getc(f);
	while (c != EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c == CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
            p->info = c;
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
			c = (char) getc(f);
		};
	};
	fclose(f);
	return 0;
}",
1529,"	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) == NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c == EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c == CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p == NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c;
	p->LINE_NUM = line_num;
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = p;
	*lastel = p;
	printf(""\n"");
	c = (char) getc(f);
	while (c != EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c == CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = abs(p);
			*lastel = p;
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
            p->info = c;
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
			c = (char) getc(f);
		};
	};
	fclose(f);
	return 0;
}","<mb:mutant#bb221a6e4a278985a2ff96d2bd80d382f0cb837c> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -7170 +7170 @@
-			(*lastel)->NEXT = p;
+			(*lastel)->NEXT = abs(p);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Space.c> ."
1530,"#ifdef DEBUG3
	printf(""\nreadfil3()"");
#endif
	*firstel = NULL;
	*lastel = NULL;
	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) == NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c == EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c == CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p == NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c;
	p->LINE_NUM = line_num;
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = p;
	*lastel = p;
	printf(""\n"");
	c = (char) getc(f);
	while (c != EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c == CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
            p->info = c;
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;",
1531,"#ifdef DEBUG3
	printf(""\nreadfil3()"");
#endif
	*firstel = NULL;
	*lastel = NULL;
	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) == NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c == EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c == CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p == NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c;
	p->LINE_NUM = line_num;
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = abs(p);
	*lastel = p;
	printf(""\n"");
	c = (char) getc(f);
	while (c != EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c == CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
            p->info = c;
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;","<mb:mutant#907e73d84eff667003659655fb078a4f76bdc667> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -7142 +7142 @@
-	*firstel = p;
+	*firstel = abs(p);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Space.c> ."
1532,"	strcpy(Keywords[82], ""ORDER"");
	strcpy(Keywords[83], ""CENTRE"");
	strcpy(Keywords[84], ""P1_VAL"");
	strcpy(Keywords[85], ""P2_VAL"");
	strcpy(Keywords[86], ""Q1_VAL"");
	strcpy(Keywords[87], ""Q2_VAL"");
	strcpy(Keywords[88], ""UNIFORM"");
	strcpy(Keywords[89], ""P1_VAL"");
	strcpy(Keywords[90], ""P2_VAL"");
	strcpy(Keywords[91], ""Q1_VAL"");
	strcpy(Keywords[92], ""Q2_VAL"");
	strcpy(Keywords[93], ""CW"");
	strcpy(Keywords[94], ""CCW"");
	strcpy(Keywords[95], ""START"");
	strcpy(Keywords[96], ""POINTING"");
	strcpy(Keywords[97], ""U"");
	strcpy(Keywords[98], ""V"");
	strcpy(Keywords[99], ""ROTATION"");
	strcpy(Keywords[100], ""SEQUENTIAL"");
	strcpy(Keywords[101], ""GROUP_EXCITATION"");
	strcpy(Keywords[102], ""ADD_GROUP"");
	strcpy(Keywords[103], ""AT"");
	strcpy(Keywords[104], ""PLACE_GROUP"");
	strcpy(Keywords[105], ""DISPLACE"");
	strcpy(Keywords[106], ""MOVE"");
	strcpy(Keywords[107], ""TO"");
	strcpy(Keywords[108], """");
	strcpy(Keywords[109], """");
	strcpy(Keywords[110], """");
	strcpy(Keywords[111], """");
	strcpy(Keywords[112], """");
	strcpy(Keywords[113], """");
	strcpy(Keywords[114], """");
	strcpy(Keywords[115], """");
	strcpy(Keywords[116], """");
	strcpy(Keywords[117], """");
	strcpy(Keywords[118], """");
	strcpy(Keywords[119], """");
	strcpy(Keywords[120], """");
	strcpy(Keywords[121], """");
	strcpy(Keywords[122], """");
	strcpy(Keywords[123], """");
	strcpy(Keywords[124], """");
	strcpy(Keywords[125], """");
	for (i = 0; (i <= KWDSNUM); i++) {
		if (strlen(Keywords[i]) > KWDSLEN) {
			printf(""\n ******** ERROR: KEYWORD no.%d TOO LONG - CORRECT Keywords[] ASSIGNMENT\n"", i);
			interror(""kwdsinit()"");
		};
	};
#ifdef DEBUG4
	for (i = 0; ((i <= KWDSNUM) && (Keywords[i][0])); i++)
		printf(""%d - %s\n"", i, Keywords[i]);
	waitcont();
#endif
}",
1533,"	strcpy(Keywords[82], ""ORDER"");
	strcpy(Keywords[83], ""CENTRE"");
	strcpy(Keywords[84], ""P1_VAL"");
	strcpy(Keywords[85], ""P2_VAL"");
	strcpy(Keywords[86], ""Q1_VAL"");
	strcpy(Keywords[87], ""Q2_VAL"");
	strcpy(Keywords[88], ""UNIFORM"");
	strcpy(Keywords[89], ""P1_VAL"");
	strcpy(Keywords[90], ""P2_VAL"");
	strcpy(Keywords[91], ""Q1_VAL"");
	strcpy(Keywords[92], ""Q2_VAL"");
	strcpy(Keywords[93], ""CW"");
	strcpy(Keywords[94], ""CCW"");
	strcpy(Keywords[95], ""START"");
	strcpy(Keywords[96], ""POINTING"");
	strcpy(Keywords[97], ""U"");
	strcpy(Keywords[98], ""V"");
	strcpy(Keywords[99], ""ROTATION"");
	strcpy(Keywords[100], ""SEQUENTIAL"");
	strcpy(Keywords[101], ""GROUP_EXCITATION"");
	strcpy(Keywords[102], ""ADD_GROUP"");
	strcpy(Keywords[103], ""AT"");
	strcpy(Keywords[104], ""PLACE_GROUP"");
	strcpy(Keywords[105], ""DISPLACE"");
	strcpy(Keywords[106], ""MOVE"");
	strcpy(Keywords[107], ""TO"");
	strcpy(Keywords[108], """");
	strcpy(Keywords[109], """");
	strcpy(Keywords[110], """");
	strcpy(Keywords[111], """");
	strcpy(Keywords[112], """");
	strcpy(Keywords[113], """");
	strcpy(Keywords[114], """");
	strcpy(Keywords[115], """");
	strcpy(Keywords[116], """");
	strcpy(Keywords[117], """");
	strcpy(Keywords[118], """");
	strcpy(Keywords[119], """");
	strcpy(Keywords[120], """");
	strcpy(Keywords[121], """");
	strcpy(Keywords[122], """");
	strcpy(Keywords[123], """");
	strcpy(Keywords[124], """");
	strcpy(Keywords[125], """");
	for (i = 0; (i <= KWDSNUM); i++) {
		if (strlen(Keywords[i]) == KWDSLEN) {
			printf(""\n ******** ERROR: KEYWORD no.%d TOO LONG - CORRECT Keywords[] ASSIGNMENT\n"", i);
			interror(""kwdsinit()"");
		};
	};
#ifdef DEBUG4
	for (i = 0; ((i <= KWDSNUM) && (Keywords[i][0])); i++)
		printf(""%d - %s\n"", i, Keywords[i]);
	waitcont();
#endif
}","<mb:mutant#01569eade5bd33e99bb822fefed21fd275a24d2f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -5367 +5367 @@
-		if (strlen(Keywords[i]) > KWDSLEN) {
+		if (strlen(Keywords[i]) == KWDSLEN) {
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Space.c> ."
1534,"#endif
	*firstel = NULL;
	*lastel = NULL;
	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) == NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c == EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c == CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p == NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c;
	p->LINE_NUM = line_num;
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = p;
	*lastel = p;
	printf(""\n"");
	c = (char) getc(f);
	while (c != EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c == CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
            p->info = c;
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
			c = (char) getc(f);",
1535,"#endif
	*firstel = NULL;
	*lastel = NULL;
	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) == NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c == EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c == CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p == NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c;
	p->LINE_NUM = line_num;
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = p;
	*lastel = abs(p);
	printf(""\n"");
	c = (char) getc(f);
	while (c != EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c == CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
            p->info = c;
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
			c = (char) getc(f);","<mb:mutant#12f6f85f622e677730bce1960bfc6cf80c84e86e> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -7143 +7143 @@
-	*lastel = p;
+	*lastel = abs(p);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Space.c> ."
1536,"int readfil3(char filename[UNLEN + 1], struct charac ** firstel, struct charac ** lastel)
{
	FILE           *f;
	char            c;
	struct charac  *p;
	int             line_num = 1;
	char            CR = '\n';
	char            adlfilename[UNLEN + 1];
#ifdef DEBUG3
	printf(""\nreadfil3()"");
#endif
	*firstel = NULL;
	*lastel = NULL;
	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) == NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c == EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c == CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p == NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c;
	p->LINE_NUM = line_num;
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = p;
	*lastel = p;
	printf(""\n"");
	c = (char) getc(f);
	while (c != EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c == CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{",
1537,"int readfil3(char filename[UNLEN + 1], struct charac ** firstel, struct charac ** lastel)
{
	FILE           *f;
	char            c;
	struct charac  *p;
	int             line_num = 1;
	char            CR = '\n';
	char            adlfilename[UNLEN + 1];
#ifdef DEBUG3
	printf(""\nreadfil3()"");
#endif
	*firstel = NULL;
	*lastel = NULL;
	strcpy(adlfilename, filename);
	strcat(adlfilename, "".adl"");
	if ((f = fopen(adlfilename, ""r"")) <= NULL)
	{
		printf(""%s %s"", ErrorMessages[21], adlfilename);
		return 21;
	};
	c = (char) getc(f);
	if (c == EOF)
	{
		printf(""%s %s"", ErrorMessages[23], adlfilename);
		return 23;
	};
	while (isspace(c) || (c == ','))
	{
		if (c == CR)
			line_num++;
		c = (char) getc(f);
	};
	p = (struct charac *) malloc(sizeof(struct charac));
	if (p == NULL) {
		printf(""%s"", ErrorMessages[22]);
		return 22;
	};
	p->info = c;
	p->LINE_NUM = line_num;
	p->PREV = NULL;
	p->NEXT = NULL;
	*firstel = p;
	*lastel = p;
	printf(""\n"");
	c = (char) getc(f);
	while (c != EOF)
	{
		if (isspace(c) || (c == ','))
		{
			do
			{
				if (c == CR)
					line_num++;
				c = (char) getc(f);
			} while (isspace(c) || (c == ','));
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{
				printf(""%s"", ErrorMessages[22]);
				return 22;
			};
			p->info = ' ';
			p->LINE_NUM = line_num;
			p->PREV = *lastel;
			p->NEXT = NULL;
			(*lastel)->NEXT = p;
			*lastel = p;
		}
		else
		{
			p = (struct charac *) malloc(sizeof(struct charac));
			if (p == NULL)
			{","<mb:mutant#279cf6790ca8b7c338185231859cacac2baf3643> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -7108 +7108 @@
-	if ((f = fopen(adlfilename, ""r"")) == NULL)
+	if ((f = fopen(adlfilename, ""r"")) <= NULL)
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Space.c> ."
1538,"		fprintf( err, ""  %d state/nextstate pairs created\n"",
			numsnpairs );
		fprintf( err, ""  %d/%d unique/duplicate transitions\n"",
			numuniq, numdup );
		if ( fulltbl )
			{
			tblsiz = lastdfa * numecs;
			fprintf( err, ""  %d table entries\n"", tblsiz );
			}
		else
			{
			tblsiz = 2 * (lastdfa + numtemps) + 2 * tblend;
			fprintf( err, ""  %d/%d base-def entries created\n"",
				lastdfa + numtemps, current_max_dfas );
			fprintf( err,
				""  %d/%d (peak %d) nxt-chk entries created\n"",
				tblend, current_max_xpairs, peakpairs );
			fprintf( err,
			""  %d/%d (peak %d) template nxt-chk entries created\n"",
				numtemps * nummecs, current_max_template_xpairs,
				numtemps * numecs );
			fprintf( err, ""  %d empty table entries\n"", nummt );
			fprintf( err, ""  %d protos created\n"", numprots );
			fprintf( err, ""  %d templates created, %d uses\n"",
				numtemps, tmpuses );
			}
		if ( useecs )
			{
			tblsiz = tblsiz + csize;
			fprintf( err,
				""  %d/%d equivalence classes created\n"",
				numecs, csize );
			}
		if ( usemecs )
			{
			tblsiz = tblsiz + numecs;
			fprintf( err,
				""  %d/%d meta-equivalence classes created\n"",
				nummecs, csize );
			}
		fprintf( err,
			""  %d (%d saved) hash collisions, %d DFAs equal\n"",
			hshcol, hshsave, dfaeql );
		fprintf( err, ""  %d sets of reallocations needed\n"",
			num_reallocs );
		fprintf( err, ""  %d total table entries needed\n"", tblsiz );
		}
#ifndef VMS
	exit( exit_status );
#else
	exit( exit_status + 1 );
#endif
	}",
1539,"		fprintf( err, ""  %d state/nextstate pairs created\n"",
			numsnpairs );
		fprintf( err, ""  %d/%d unique/duplicate transitions\n"",
			numuniq, numdup );
		if ( fulltbl )
			{
			tblsiz = lastdfa * numecs;
			fprintf( err, ""  %d table entries\n"", tblsiz );
			}
		else
			{
			tblsiz = 2 * (lastdfa + numtemps) + 2 * tblend;
			fprintf( err, ""  %d/%d base-def entries created\n"",
				lastdfa + numtemps, current_max_dfas );
			fprintf( err,
				""  %d/%d (peak %d) nxt-chk entries created\n"",
				tblend, current_max_xpairs, peakpairs );
			fprintf( err,
			""  %d/%d (peak %d) template nxt-chk entries created\n"",
				numtemps * nummecs, current_max_template_xpairs,
				numtemps * numecs );
			fprintf( err, ""  %d empty table entries\n"", nummt );
			fprintf( err, ""  %d protos created\n"", numprots );
			fprintf( err, ""  %d templates created, %d uses\n"",
				numtemps, tmpuses );
			}
		if ( useecs )
			{
			tblsiz = tblsiz + csize;
			fprintf( err,
				""  %d/%d equivalence classes created\n"",
				numecs, csize );
			}
		if ( usemecs )
			{
			tblsiz = tblsiz + numecs;
			fprintf( err,
				""  %d/%d meta-equivalence classes created\n"",
				nummecs, csize );
			}
		fprintf( err,
			""  %d (%d saved) hash collisions, %d DFAs equal\n"",
			hshcol, hshsave, dfaeql );
		fprintf( err, ""  %d sets of reallocations needed\n"",
			num_reallocs );
		fprintf( err, ""  %d total table entries needed\n"", tblsiz );
		}
#ifndef VMS
	exit( exit_status );
#else
	exit( exit_status + 1 );
#endif
	}","<mb:mutant#a7d49d8cba57ffd5cfc05f651401f62da79fc30e> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -1709 +1709 @@
-		if ( num_backing_up == 0 )
+		if ( num_backing_up <= 0 )
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Flex.c> ."
1540,"	lastccl = 0;
	lastsc = 0;
	if ( skelname && (skelfile = fopen( skelname, ""r"" )) == NULL )
		lerrsf( ""can't open skeleton file %s"", skelname );
	if ( strcmp( prefix, ""yy"" ) )
		{
#define GEN_PREFIX(name) printf( ""#define yy%s %s%s\n"", name, prefix, name );
		GEN_PREFIX( ""FlexLexer"" );
		GEN_PREFIX( ""_create_buffer"" );
		GEN_PREFIX( ""_delete_buffer"" );
		GEN_PREFIX( ""_flex_debug"" );
		GEN_PREFIX( ""_init_buffer"" );
		GEN_PREFIX( ""_load_buffer_state"" );
		GEN_PREFIX( ""_switch_to_buffer"" );
		GEN_PREFIX( ""in"" );
		GEN_PREFIX( ""leng"" );
		GEN_PREFIX( ""lex"" );
		GEN_PREFIX( ""out"" );
		GEN_PREFIX( ""restart"" );
		GEN_PREFIX( ""text"" );
		GEN_PREFIX( ""wrap"" );
		printf( ""\n"" );
		}
	lastdfa = lastnfa = 0;
	num_rules = num_eof_rules = default_rule = 0;
	numas = numsnpairs = tmpuses = 0;
	numecs = numeps = eps2 = num_reallocs = hshcol = dfaeql = totnst = 0;
	numuniq = numdup = hshsave = eofseen = datapos = dataline = 0;
	num_backing_up = onesp = numprots = 0;
	variable_trailing_context_rules = bol_needed = false;
	linenum = sectnum = 1;
	firstprot = NIL;
	lastprot = 1;
	if ( useecs )
		{
		ecgroup[1] = NIL;
		for ( i = 2; i <= csize; ++i )
			{
			ecgroup[i] = i - 1;
			nextecm[i - 1] = i;
			}
		nextecm[csize] = NIL;
		}
	else
		{
		for ( i = 1; i <= csize; ++i )
			{
			ecgroup[i] = i;
			nextecm[i] = BAD_SUBSCRIPT;	 
			}
		}
	set_up_initial_allocations();
	}",
1541,"	lastccl = 0;
	lastsc = 0;
	if ( skelname && (skelfile = fopen( skelname, ""r"" )) <= NULL )
		lerrsf( ""can't open skeleton file %s"", skelname );
	if ( strcmp( prefix, ""yy"" ) )
		{
#define GEN_PREFIX(name) printf( ""#define yy%s %s%s\n"", name, prefix, name );
		GEN_PREFIX( ""FlexLexer"" );
		GEN_PREFIX( ""_create_buffer"" );
		GEN_PREFIX( ""_delete_buffer"" );
		GEN_PREFIX( ""_flex_debug"" );
		GEN_PREFIX( ""_init_buffer"" );
		GEN_PREFIX( ""_load_buffer_state"" );
		GEN_PREFIX( ""_switch_to_buffer"" );
		GEN_PREFIX( ""in"" );
		GEN_PREFIX( ""leng"" );
		GEN_PREFIX( ""lex"" );
		GEN_PREFIX( ""out"" );
		GEN_PREFIX( ""restart"" );
		GEN_PREFIX( ""text"" );
		GEN_PREFIX( ""wrap"" );
		printf( ""\n"" );
		}
	lastdfa = lastnfa = 0;
	num_rules = num_eof_rules = default_rule = 0;
	numas = numsnpairs = tmpuses = 0;
	numecs = numeps = eps2 = num_reallocs = hshcol = dfaeql = totnst = 0;
	numuniq = numdup = hshsave = eofseen = datapos = dataline = 0;
	num_backing_up = onesp = numprots = 0;
	variable_trailing_context_rules = bol_needed = false;
	linenum = sectnum = 1;
	firstprot = NIL;
	lastprot = 1;
	if ( useecs )
		{
		ecgroup[1] = NIL;
		for ( i = 2; i <= csize; ++i )
			{
			ecgroup[i] = i - 1;
			nextecm[i - 1] = i;
			}
		nextecm[csize] = NIL;
		}
	else
		{
		for ( i = 1; i <= csize; ++i )
			{
			ecgroup[i] = i;
			nextecm[i] = BAD_SUBSCRIPT;	 
			}
		}
	set_up_initial_allocations();
	}","<mb:mutant#5b85a3dd5117e2cbdf6797f2f265f80feff3b677> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -1399 +1399 @@
-	if ( skelname && (skelfile = fopen( skelname, ""r"" )) == NULL )
+	if ( skelname && (skelfile = fopen( skelname, ""r"" )) <= NULL )
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Flex.c> ."
1542,"	if ( C_plus_plus && fullspd )
		flexerror( ""Can't use -+ with -CF option"" );
	if ( ! use_stdout )
	{
		FILE *prev_stdout;
		char *suffix;
		if ( C_plus_plus )
			suffix = ""cc"";
		else
			suffix = ""c"";
		sprintf( outfile_path, outfile_template, prefix, suffix );
		prev_stdout = freopen( outfile_path, ""w"", stdout );
		if ( prev_stdout == NULL )
			lerrsf( ""could not create %s"", outfile_path );
		outfile_created = 1;
	}
	num_input_files = argc;
	input_files = argv;
	set_input_file( num_input_files > 0 ? input_files[0] : NULL );
	if ( backing_up_report )
		{
#ifndef SHORT_FILE_NAMES
		backing_up_file = fopen( ""lex.backup"", ""w"" );
#else
		backing_up_file = fopen( ""lex.bck"", ""w"" );
#endif
		if ( backing_up_file == NULL )
			flexerror( ""could not create lex.backup"" );
		}
	else
		backing_up_file = NULL;
	lastccl = 0;
	lastsc = 0;
	if ( skelname && (skelfile = fopen( skelname, ""r"" )) == NULL )
		lerrsf( ""can't open skeleton file %s"", skelname );
	if ( strcmp( prefix, ""yy"" ) )
		{
#define GEN_PREFIX(name) printf( ""#define yy%s %s%s\n"", name, prefix, name );
		GEN_PREFIX( ""FlexLexer"" );
		GEN_PREFIX( ""_create_buffer"" );
		GEN_PREFIX( ""_delete_buffer"" );
		GEN_PREFIX( ""_flex_debug"" );
		GEN_PREFIX( ""_init_buffer"" );
		GEN_PREFIX( ""_load_buffer_state"" );
		GEN_PREFIX( ""_switch_to_buffer"" );
		GEN_PREFIX( ""in"" );
		GEN_PREFIX( ""leng"" );
		GEN_PREFIX( ""lex"" );
		GEN_PREFIX( ""out"" );
		GEN_PREFIX( ""restart"" );
		GEN_PREFIX( ""text"" );
		GEN_PREFIX( ""wrap"" );
		printf( ""\n"" );
		}
	lastdfa = lastnfa = 0;
	num_rules = num_eof_rules = default_rule = 0;",
1543,"	if ( C_plus_plus && fullspd )
		flexerror( ""Can't use -+ with -CF option"" );
	if ( ! use_stdout )
	{
		FILE *prev_stdout;
		char *suffix;
		if ( C_plus_plus )
			suffix = ""cc"";
		else
			suffix = ""c"";
		sprintf( outfile_path, outfile_template, prefix, suffix );
		prev_stdout = freopen( outfile_path, ""w"", stdout );
		if ( prev_stdout == NULL )
			lerrsf( ""could not create %s"", outfile_path );
		outfile_created = 1;
	}
	num_input_files = argc;
	input_files = argv;
	set_input_file( num_input_files > 0 ? input_files[0] : NULL );
	if ( backing_up_report )
		{
#ifndef SHORT_FILE_NAMES
		backing_up_file = fopen( ""lex.backup"", ""w"" );
#else
		backing_up_file = fopen( ""lex.bck"", ""w"" );
#endif
		if ( backing_up_file == NULL )
			flexerror( ""could not create lex.backup"" );
		}
	else
		backing_up_file = NULL;
	lastccl = 0;
	lastsc = 0;
	if ( skelname && (skelfile = fopen( skelname, ""r"" )) == NULL )
		lerrsf( ""can't open skeleton file %s"", skelname );
	if ( strcmp( prefix, ""yy"" ) )
		{
#define GEN_PREFIX(name) printf( ""#define yy%s %s%s\n"", name, prefix, name );
		GEN_PREFIX( ""FlexLexer"" );
		GEN_PREFIX( ""_create_buffer"" );
		GEN_PREFIX( ""_delete_buffer"" );
		GEN_PREFIX( ""_flex_debug"" );
		GEN_PREFIX( ""_init_buffer"" );
		GEN_PREFIX( ""_load_buffer_state"" );
		GEN_PREFIX( ""_switch_to_buffer"" );
		GEN_PREFIX( ""in"" );
		GEN_PREFIX( ""leng"" );
		GEN_PREFIX( ""lex"" );
		GEN_PREFIX( ""out"" );
		GEN_PREFIX( ""restart"" );
		GEN_PREFIX( ""text"" );
		GEN_PREFIX( ""wrap"" );
		printf( ""\n"" );
		}
	lastdfa = lastnfa = 0;
	num_rules = num_eof_rules = default_rule = 0;","<mb:mutant#fce9e7258edaae0835f964ee5eeb2ae7de165607> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -1259 +1259 @@
-					skelname = arg + i + 1;
+					skelname = abs(arg) + i + 1;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Flex.c> ."
1544,"	lastccl = 0;
	lastsc = 0;
	if ( skelname && (skelfile = fopen( skelname, ""r"" )) == NULL )
		lerrsf( ""can't open skeleton file %s"", skelname );
	if ( strcmp( prefix, ""yy"" ) )
		{
#define GEN_PREFIX(name) printf( ""#define yy%s %s%s\n"", name, prefix, name );
		GEN_PREFIX( ""FlexLexer"" );
		GEN_PREFIX( ""_create_buffer"" );
		GEN_PREFIX( ""_delete_buffer"" );
		GEN_PREFIX( ""_flex_debug"" );
		GEN_PREFIX( ""_init_buffer"" );
		GEN_PREFIX( ""_load_buffer_state"" );
		GEN_PREFIX( ""_switch_to_buffer"" );
		GEN_PREFIX( ""in"" );
		GEN_PREFIX( ""leng"" );
		GEN_PREFIX( ""lex"" );
		GEN_PREFIX( ""out"" );
		GEN_PREFIX( ""restart"" );
		GEN_PREFIX( ""text"" );
		GEN_PREFIX( ""wrap"" );
		printf( ""\n"" );
		}
	lastdfa = lastnfa = 0;
	num_rules = num_eof_rules = default_rule = 0;
	numas = numsnpairs = tmpuses = 0;
	numecs = numeps = eps2 = num_reallocs = hshcol = dfaeql = totnst = 0;
	numuniq = numdup = hshsave = eofseen = datapos = dataline = 0;
	num_backing_up = onesp = numprots = 0;
	variable_trailing_context_rules = bol_needed = false;
	linenum = sectnum = 1;
	firstprot = NIL;
	lastprot = 1;
	if ( useecs )
		{
		ecgroup[1] = NIL;
		for ( i = 2; i <= csize; ++i )
			{
			ecgroup[i] = i - 1;
			nextecm[i - 1] = i;
			}
		nextecm[csize] = NIL;
		}
	else
		{
		for ( i = 1; i <= csize; ++i )
			{
			ecgroup[i] = i;
			nextecm[i] = BAD_SUBSCRIPT;	 
			}
		}
	set_up_initial_allocations();
	}",
1545,"	lastccl = 0;
	lastsc = 0;
	if ( skelname && (skelfile = fopen( skelname, ""r"" )) == NULL )
		lerrsf( ""can't open skeleton file %s"", skelname );
	if ( strcmp( prefix, ""yy"" ) )
		{
#define GEN_PREFIX(name) printf( ""#define yy%s %s%s\n"", name, prefix, name );
		GEN_PREFIX( ""FlexLexer"" );
		GEN_PREFIX( ""_create_buffer"" );
		GEN_PREFIX( ""_delete_buffer"" );
		GEN_PREFIX( ""_flex_debug"" );
		GEN_PREFIX( ""_init_buffer"" );
		GEN_PREFIX( ""_load_buffer_state"" );
		GEN_PREFIX( ""_switch_to_buffer"" );
		GEN_PREFIX( ""in"" );
		GEN_PREFIX( ""leng"" );
		GEN_PREFIX( ""lex"" );
		GEN_PREFIX( ""out"" );
		GEN_PREFIX( ""restart"" );
		GEN_PREFIX( ""text"" );
		GEN_PREFIX( ""wrap"" );
		printf( ""\n"" );
		}
	lastdfa = lastnfa = 0;
	num_rules = num_eof_rules = default_rule = 0;
	numas = numsnpairs = tmpuses = 0;
	numecs = numeps = eps2 = num_reallocs = hshcol = dfaeql = totnst = 0;
	numuniq = numdup = hshsave = eofseen = datapos = dataline = 0;
	num_backing_up = onesp = numprots = 0;
	variable_trailing_context_rules = bol_needed = false;
	linenum = sectnum = 1;
	firstprot = NIL;
	lastprot = 1;
	if ( useecs )
		{
		ecgroup[1] = NIL;
		for ( i = 2; i <= csize; ++i )
			{
			ecgroup[i] = i - 1;
			nextecm[i - 1] = i;
			}
		nextecm[csize] = NIL;
		}
	else
		{
		for ( i = 1; i <= csize; ++i )
			{
			ecgroup[i] = i;
			nextecm[i] = BAD_SUBSCRIPT;	 
			}
		}
	set_up_initial_allocations();
	}","<mb:mutant#d54c5ac4f5e7ad0bf79e9099de5b269d82e8c0de> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -1377 +1377 @@
-	input_files = argv;
+	input_files = abs(argv);
@@ -1770 +1769 @@
-			tblsiz = tblsiz + csize;
+			tblsiz = tblsiz + abs(csize);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Flex.c> ."
1546,"	lastccl = 0;
	lastsc = 0;
	if ( skelname && (skelfile = fopen( skelname, ""r"" )) == NULL )
		lerrsf( ""can't open skeleton file %s"", skelname );
	if ( strcmp( prefix, ""yy"" ) )
		{
#define GEN_PREFIX(name) printf( ""#define yy%s %s%s\n"", name, prefix, name );
		GEN_PREFIX( ""FlexLexer"" );
		GEN_PREFIX( ""_create_buffer"" );
		GEN_PREFIX( ""_delete_buffer"" );
		GEN_PREFIX( ""_flex_debug"" );
		GEN_PREFIX( ""_init_buffer"" );
		GEN_PREFIX( ""_load_buffer_state"" );
		GEN_PREFIX( ""_switch_to_buffer"" );
		GEN_PREFIX( ""in"" );
		GEN_PREFIX( ""leng"" );
		GEN_PREFIX( ""lex"" );
		GEN_PREFIX( ""out"" );
		GEN_PREFIX( ""restart"" );
		GEN_PREFIX( ""text"" );
		GEN_PREFIX( ""wrap"" );
		printf( ""\n"" );
		}
	lastdfa = lastnfa = 0;
	num_rules = num_eof_rules = default_rule = 0;
	numas = numsnpairs = tmpuses = 0;
	numecs = numeps = eps2 = num_reallocs = hshcol = dfaeql = totnst = 0;
	numuniq = numdup = hshsave = eofseen = datapos = dataline = 0;
	num_backing_up = onesp = numprots = 0;
	variable_trailing_context_rules = bol_needed = false;
	linenum = sectnum = 1;
	firstprot = NIL;
	lastprot = 1;
	if ( useecs )
		{
		ecgroup[1] = NIL;
		for ( i = 2; i <= csize; ++i )
			{
			ecgroup[i] = i - 1;
			nextecm[i - 1] = i;
			}
		nextecm[csize] = NIL;
		}
	else
		{
		for ( i = 1; i <= csize; ++i )
			{
			ecgroup[i] = i;
			nextecm[i] = BAD_SUBSCRIPT;	 
			}
		}
	set_up_initial_allocations();
	}",
1547,"	lastccl = 0;
	lastsc = 0;
	if ( skelname && (skelfile = fopen( skelname, ""r"" )) == NULL )
		lerrsf( ""can't open skeleton file %s"", skelname );
	if ( strcmp( prefix, ""yy"" ) )
		{
#define GEN_PREFIX(name) printf( ""#define yy%s %s%s\n"", name, prefix, name );
		GEN_PREFIX( ""FlexLexer"" );
		GEN_PREFIX( ""_create_buffer"" );
		GEN_PREFIX( ""_delete_buffer"" );
		GEN_PREFIX( ""_flex_debug"" );
		GEN_PREFIX( ""_init_buffer"" );
		GEN_PREFIX( ""_load_buffer_state"" );
		GEN_PREFIX( ""_switch_to_buffer"" );
		GEN_PREFIX( ""in"" );
		GEN_PREFIX( ""leng"" );
		GEN_PREFIX( ""lex"" );
		GEN_PREFIX( ""out"" );
		GEN_PREFIX( ""restart"" );
		GEN_PREFIX( ""text"" );
		GEN_PREFIX( ""wrap"" );
		printf( ""\n"" );
		}
	lastdfa = lastnfa = 0;
	num_rules = num_eof_rules = default_rule = 0;
	numas = numsnpairs = tmpuses = 0;
	numecs = numeps = eps2 = num_reallocs = hshcol = dfaeql = totnst = 0;
	numuniq = numdup = hshsave = eofseen = datapos = dataline = 0;
	num_backing_up = onesp = numprots = 0;
	variable_trailing_context_rules = bol_needed = false;
	linenum = sectnum = 1;
	firstprot = NIL;
	lastprot = 1;
	if ( useecs )
		{
		ecgroup[1] = NIL;
		for ( i = 2; i <= csize; ++i )
			{
			ecgroup[i] = i - 1;
			nextecm[i - 1] = i;
			}
		nextecm[csize] = NIL;
		}
	else
		{
		for ( i = 1; i <= csize; ++i )
			{
			ecgroup[i] = i;
			nextecm[i] = BAD_SUBSCRIPT;	 
			}
		}
	set_up_initial_allocations();
	}","<mb:mutant#af5e7bd5a2ed4f734a514e975571ac5f0c9d374f> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -1378 +1378 @@
-	set_input_file( num_input_files > 0 ? input_files[0] : NULL );
+	set_input_file( num_input_files != 0 ? input_files[0] : NULL );
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Flex.c> ."
1548,"		fprintf( err, ""  %d state/nextstate pairs created\n"",
			numsnpairs );
		fprintf( err, ""  %d/%d unique/duplicate transitions\n"",
			numuniq, numdup );
		if ( fulltbl )
			{
			tblsiz = lastdfa * numecs;
			fprintf( err, ""  %d table entries\n"", tblsiz );
			}
		else
			{
			tblsiz = 2 * (lastdfa + numtemps) + 2 * tblend;
			fprintf( err, ""  %d/%d base-def entries created\n"",
				lastdfa + numtemps, current_max_dfas );
			fprintf( err,
				""  %d/%d (peak %d) nxt-chk entries created\n"",
				tblend, current_max_xpairs, peakpairs );
			fprintf( err,
			""  %d/%d (peak %d) template nxt-chk entries created\n"",
				numtemps * nummecs, current_max_template_xpairs,
				numtemps * numecs );
			fprintf( err, ""  %d empty table entries\n"", nummt );
			fprintf( err, ""  %d protos created\n"", numprots );
			fprintf( err, ""  %d templates created, %d uses\n"",
				numtemps, tmpuses );
			}
		if ( useecs )
			{
			tblsiz = tblsiz + csize;
			fprintf( err,
				""  %d/%d equivalence classes created\n"",
				numecs, csize );
			}
		if ( usemecs )
			{
			tblsiz = tblsiz + numecs;
			fprintf( err,
				""  %d/%d meta-equivalence classes created\n"",
				nummecs, csize );
			}
		fprintf( err,
			""  %d (%d saved) hash collisions, %d DFAs equal\n"",
			hshcol, hshsave, dfaeql );
		fprintf( err, ""  %d sets of reallocations needed\n"",
			num_reallocs );
		fprintf( err, ""  %d total table entries needed\n"", tblsiz );
		}
#ifndef VMS
	exit( exit_status );
#else
	exit( exit_status + 1 );
#endif
	}",
1549,"		fprintf( err, ""  %d state/nextstate pairs created\n"",
			numsnpairs );
		fprintf( err, ""  %d/%d unique/duplicate transitions\n"",
			numuniq, numdup );
		if ( fulltbl )
			{
			tblsiz = lastdfa * numecs;
			fprintf( err, ""  %d table entries\n"", tblsiz );
			}
		else
			{
			tblsiz = 2 * (lastdfa + numtemps) + 2 * tblend;
			fprintf( err, ""  %d/%d base-def entries created\n"",
				lastdfa + numtemps, current_max_dfas );
			fprintf( err,
				""  %d/%d (peak %d) nxt-chk entries created\n"",
				tblend, current_max_xpairs, peakpairs );
			fprintf( err,
			""  %d/%d (peak %d) template nxt-chk entries created\n"",
				numtemps * nummecs, current_max_template_xpairs,
				numtemps * numecs );
			fprintf( err, ""  %d empty table entries\n"", nummt );
			fprintf( err, ""  %d protos created\n"", numprots );
			fprintf( err, ""  %d templates created, %d uses\n"",
				numtemps, tmpuses );
			}
		if ( useecs )
			{
			tblsiz = tblsiz + csize;
			fprintf( err,
				""  %d/%d equivalence classes created\n"",
				numecs, csize );
			}
		if ( usemecs )
			{
			tblsiz = tblsiz + numecs;
			fprintf( err,
				""  %d/%d meta-equivalence classes created\n"",
				nummecs, csize );
			}
		fprintf( err,
			""  %d (%d saved) hash collisions, %d DFAs equal\n"",
			hshcol, hshsave, dfaeql );
		fprintf( err, ""  %d sets of reallocations needed\n"",
			num_reallocs );
		fprintf( err, ""  %d total table entries needed\n"", tblsiz );
		}
#ifndef VMS
	exit( exit_status );
#else
	exit( exit_status + 1 );
#endif
	}","<mb:mutant#488a499f005d87f360bb1067b24ec297fac5b684> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -1729 +1729 @@
-		if ( lastccl == 0 )
+		if ( lastccl <= 0 )
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Flex.c> ."
1550,"	if ( C_plus_plus && fullspd )
		flexerror( ""Can't use -+ with -CF option"" );
	if ( ! use_stdout )
	{
		FILE *prev_stdout;
		char *suffix;
		if ( C_plus_plus )
			suffix = ""cc"";
		else
			suffix = ""c"";
		sprintf( outfile_path, outfile_template, prefix, suffix );
		prev_stdout = freopen( outfile_path, ""w"", stdout );
		if ( prev_stdout == NULL )
			lerrsf( ""could not create %s"", outfile_path );
		outfile_created = 1;
	}
	num_input_files = argc;
	input_files = argv;
	set_input_file( num_input_files > 0 ? input_files[0] : NULL );
	if ( backing_up_report )
		{
#ifndef SHORT_FILE_NAMES
		backing_up_file = fopen( ""lex.backup"", ""w"" );
#else
		backing_up_file = fopen( ""lex.bck"", ""w"" );
#endif
		if ( backing_up_file == NULL )
			flexerror( ""could not create lex.backup"" );
		}
	else
		backing_up_file = NULL;
	lastccl = 0;
	lastsc = 0;
	if ( skelname && (skelfile = fopen( skelname, ""r"" )) == NULL )
		lerrsf( ""can't open skeleton file %s"", skelname );
	if ( strcmp( prefix, ""yy"" ) )
		{
#define GEN_PREFIX(name) printf( ""#define yy%s %s%s\n"", name, prefix, name );
		GEN_PREFIX( ""FlexLexer"" );
		GEN_PREFIX( ""_create_buffer"" );
		GEN_PREFIX( ""_delete_buffer"" );
		GEN_PREFIX( ""_flex_debug"" );
		GEN_PREFIX( ""_init_buffer"" );
		GEN_PREFIX( ""_load_buffer_state"" );
		GEN_PREFIX( ""_switch_to_buffer"" );
		GEN_PREFIX( ""in"" );
		GEN_PREFIX( ""leng"" );
		GEN_PREFIX( ""lex"" );
		GEN_PREFIX( ""out"" );
		GEN_PREFIX( ""restart"" );
		GEN_PREFIX( ""text"" );
		GEN_PREFIX( ""wrap"" );
		printf( ""\n"" );
		}
	lastdfa = lastnfa = 0;
	num_rules = num_eof_rules = default_rule = 0;",
1551,"	if ( C_plus_plus && fullspd )
		flexerror( ""Can't use -+ with -CF option"" );
	if ( ! use_stdout )
	{
		FILE *prev_stdout;
		char *suffix;
		if ( C_plus_plus )
			suffix = ""cc"";
		else
			suffix = ""c"";
		sprintf( outfile_path, outfile_template, prefix, suffix );
		prev_stdout = freopen( outfile_path, ""w"", stdout );
		if ( prev_stdout == NULL )
			lerrsf( ""could not create %s"", outfile_path );
		outfile_created = 1;
	}
	num_input_files = argc;
	input_files = argv;
	set_input_file( num_input_files > 0 ? input_files[0] : NULL );
	if ( backing_up_report )
		{
#ifndef SHORT_FILE_NAMES
		backing_up_file = fopen( ""lex.backup"", ""w"" );
#else
		backing_up_file = fopen( ""lex.bck"", ""w"" );
#endif
		if ( backing_up_file == NULL )
			flexerror( ""could not create lex.backup"" );
		}
	else
		backing_up_file = NULL;
	lastccl = 0;
	lastsc = 0;
	if ( skelname && (skelfile = fopen( skelname, ""r"" )) == NULL )
		lerrsf( ""can't open skeleton file %s"", skelname );
	if ( strcmp( prefix, ""yy"" ) )
		{
#define GEN_PREFIX(name) printf( ""#define yy%s %s%s\n"", name, prefix, name );
		GEN_PREFIX( ""FlexLexer"" );
		GEN_PREFIX( ""_create_buffer"" );
		GEN_PREFIX( ""_delete_buffer"" );
		GEN_PREFIX( ""_flex_debug"" );
		GEN_PREFIX( ""_init_buffer"" );
		GEN_PREFIX( ""_load_buffer_state"" );
		GEN_PREFIX( ""_switch_to_buffer"" );
		GEN_PREFIX( ""in"" );
		GEN_PREFIX( ""leng"" );
		GEN_PREFIX( ""lex"" );
		GEN_PREFIX( ""out"" );
		GEN_PREFIX( ""restart"" );
		GEN_PREFIX( ""text"" );
		GEN_PREFIX( ""wrap"" );
		printf( ""\n"" );
		}
	lastdfa = lastnfa = 0;
	num_rules = num_eof_rules = default_rule = 0;","<mb:mutant#3077a0dfe332daf3ab575576f01d7225d2aa5b3c> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -1259 +1259 @@
-					skelname = arg + i + 1;
+					skelname = arg + abs(i) + 1;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Flex.c> ."
1552,"	lastccl = 0;
	lastsc = 0;
	if ( skelname && (skelfile = fopen( skelname, ""r"" )) == NULL )
		lerrsf( ""can't open skeleton file %s"", skelname );
	if ( strcmp( prefix, ""yy"" ) )
		{
#define GEN_PREFIX(name) printf( ""#define yy%s %s%s\n"", name, prefix, name );
		GEN_PREFIX( ""FlexLexer"" );
		GEN_PREFIX( ""_create_buffer"" );
		GEN_PREFIX( ""_delete_buffer"" );
		GEN_PREFIX( ""_flex_debug"" );
		GEN_PREFIX( ""_init_buffer"" );
		GEN_PREFIX( ""_load_buffer_state"" );
		GEN_PREFIX( ""_switch_to_buffer"" );
		GEN_PREFIX( ""in"" );
		GEN_PREFIX( ""leng"" );
		GEN_PREFIX( ""lex"" );
		GEN_PREFIX( ""out"" );
		GEN_PREFIX( ""restart"" );
		GEN_PREFIX( ""text"" );
		GEN_PREFIX( ""wrap"" );
		printf( ""\n"" );
		}
	lastdfa = lastnfa = 0;
	num_rules = num_eof_rules = default_rule = 0;
	numas = numsnpairs = tmpuses = 0;
	numecs = numeps = eps2 = num_reallocs = hshcol = dfaeql = totnst = 0;
	numuniq = numdup = hshsave = eofseen = datapos = dataline = 0;
	num_backing_up = onesp = numprots = 0;
	variable_trailing_context_rules = bol_needed = false;
	linenum = sectnum = 1;
	firstprot = NIL;
	lastprot = 1;
	if ( useecs )
		{
		ecgroup[1] = NIL;
		for ( i = 2; i <= csize; ++i )
			{
			ecgroup[i] = i - 1;
			nextecm[i - 1] = i;
			}
		nextecm[csize] = NIL;
		}
	else
		{
		for ( i = 1; i <= csize; ++i )
			{
			ecgroup[i] = i;
			nextecm[i] = BAD_SUBSCRIPT;	 
			}
		}
	set_up_initial_allocations();
	}",
1553,"	lastccl = 0;
	lastsc = 0;
	if ( skelname && (skelfile = fopen( skelname, ""r"" )) == NULL )
		lerrsf( ""can't open skeleton file %s"", skelname );
	if ( strcmp( prefix, ""yy"" ) )
		{
#define GEN_PREFIX(name) printf( ""#define yy%s %s%s\n"", name, prefix, name );
		GEN_PREFIX( ""FlexLexer"" );
		GEN_PREFIX( ""_create_buffer"" );
		GEN_PREFIX( ""_delete_buffer"" );
		GEN_PREFIX( ""_flex_debug"" );
		GEN_PREFIX( ""_init_buffer"" );
		GEN_PREFIX( ""_load_buffer_state"" );
		GEN_PREFIX( ""_switch_to_buffer"" );
		GEN_PREFIX( ""in"" );
		GEN_PREFIX( ""leng"" );
		GEN_PREFIX( ""lex"" );
		GEN_PREFIX( ""out"" );
		GEN_PREFIX( ""restart"" );
		GEN_PREFIX( ""text"" );
		GEN_PREFIX( ""wrap"" );
		printf( ""\n"" );
		}
	lastdfa = lastnfa = 0;
	num_rules = num_eof_rules = default_rule = 0;
	numas = numsnpairs = tmpuses = 0;
	numecs = numeps = eps2 = num_reallocs = hshcol = dfaeql = totnst = 0;
	numuniq = numdup = hshsave = eofseen = datapos = dataline = 0;
	num_backing_up = onesp = numprots = 0;
	variable_trailing_context_rules = bol_needed = false;
	linenum = sectnum = 1;
	firstprot = NIL;
	lastprot = 1;
	if ( useecs )
		{
		ecgroup[1] = NIL;
		for ( i = 2; i <= csize; ++i )
			{
			ecgroup[i] = i - 1;
			nextecm[i - 1] = i;
			}
		nextecm[csize] = NIL;
		}
	else
		{
		for ( i = 1; i <= csize; ++i )
			{
			ecgroup[i] = i;
			nextecm[i] = BAD_SUBSCRIPT;	 
			}
		}
	set_up_initial_allocations();
	}","<mb:mutant#d54c5ac4f5e7ad0bf79e9099de5b269d82e8c0de> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -1377 +1377 @@
-	input_files = argv;
+	input_files = abs(argv);
@@ -1770 +1769 @@
-			tblsiz = tblsiz + csize;
+			tblsiz = tblsiz + abs(csize);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Flex.c> ."
1554,"	lastccl = 0;
	lastsc = 0;
	if ( skelname && (skelfile = fopen( skelname, ""r"" )) == NULL )
		lerrsf( ""can't open skeleton file %s"", skelname );
	if ( strcmp( prefix, ""yy"" ) )
		{
#define GEN_PREFIX(name) printf( ""#define yy%s %s%s\n"", name, prefix, name );
		GEN_PREFIX( ""FlexLexer"" );
		GEN_PREFIX( ""_create_buffer"" );
		GEN_PREFIX( ""_delete_buffer"" );
		GEN_PREFIX( ""_flex_debug"" );
		GEN_PREFIX( ""_init_buffer"" );
		GEN_PREFIX( ""_load_buffer_state"" );
		GEN_PREFIX( ""_switch_to_buffer"" );
		GEN_PREFIX( ""in"" );
		GEN_PREFIX( ""leng"" );
		GEN_PREFIX( ""lex"" );
		GEN_PREFIX( ""out"" );
		GEN_PREFIX( ""restart"" );
		GEN_PREFIX( ""text"" );
		GEN_PREFIX( ""wrap"" );
		printf( ""\n"" );
		}
	lastdfa = lastnfa = 0;
	num_rules = num_eof_rules = default_rule = 0;
	numas = numsnpairs = tmpuses = 0;
	numecs = numeps = eps2 = num_reallocs = hshcol = dfaeql = totnst = 0;
	numuniq = numdup = hshsave = eofseen = datapos = dataline = 0;
	num_backing_up = onesp = numprots = 0;
	variable_trailing_context_rules = bol_needed = false;
	linenum = sectnum = 1;
	firstprot = NIL;
	lastprot = 1;
	if ( useecs )
		{
		ecgroup[1] = NIL;
		for ( i = 2; i <= csize; ++i )
			{
			ecgroup[i] = i - 1;
			nextecm[i - 1] = i;
			}
		nextecm[csize] = NIL;
		}
	else
		{
		for ( i = 1; i <= csize; ++i )
			{
			ecgroup[i] = i;
			nextecm[i] = BAD_SUBSCRIPT;	 
			}
		}
	set_up_initial_allocations();
	}",
1555,"	lastccl = 0;
	lastsc = 0;
	if ( skelname && (skelfile = fopen( skelname, ""r"" )) == NULL )
		lerrsf( ""can't open skeleton file %s"", skelname );
	if ( strcmp( prefix, ""yy"" ) )
		{
#define GEN_PREFIX(name) printf( ""#define yy%s %s%s\n"", name, prefix, name );
		GEN_PREFIX( ""FlexLexer"" );
		GEN_PREFIX( ""_create_buffer"" );
		GEN_PREFIX( ""_delete_buffer"" );
		GEN_PREFIX( ""_flex_debug"" );
		GEN_PREFIX( ""_init_buffer"" );
		GEN_PREFIX( ""_load_buffer_state"" );
		GEN_PREFIX( ""_switch_to_buffer"" );
		GEN_PREFIX( ""in"" );
		GEN_PREFIX( ""leng"" );
		GEN_PREFIX( ""lex"" );
		GEN_PREFIX( ""out"" );
		GEN_PREFIX( ""restart"" );
		GEN_PREFIX( ""text"" );
		GEN_PREFIX( ""wrap"" );
		printf( ""\n"" );
		}
	lastdfa = lastnfa = 0;
	num_rules = num_eof_rules = default_rule = 0;
	numas = numsnpairs = tmpuses = 0;
	numecs = numeps = eps2 = num_reallocs = hshcol = dfaeql = totnst = 0;
	numuniq = numdup = hshsave = eofseen = datapos = dataline = 0;
	num_backing_up = onesp = numprots = 0;
	variable_trailing_context_rules = bol_needed = false;
	linenum = sectnum = 1;
	firstprot = NIL;
	lastprot = 1;
	if ( useecs )
		{
		ecgroup[1] = NIL;
		for ( i = 2; i <= csize; ++i )
			{
			ecgroup[i] = i - 1;
			nextecm[i - 1] = i;
			}
		nextecm[csize] = NIL;
		}
	else
		{
		for ( i = 1; i <= csize; ++i )
			{
			ecgroup[i] = i;
			nextecm[i] = BAD_SUBSCRIPT;	 
			}
		}
	set_up_initial_allocations();
	}","<mb:mutant#644401200f40824c819f267ac6c16e3b00f2df2b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -1316 +1316 @@
-			csize = CSIZE;
+			csize = abs(CSIZE);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Flex.c> ."
1556,"	action_array[0] = '\0';
        program_name = ""Executable"";
	if ( program_name[0] != '\0' && program_name[strlen( program_name ) - 1] == '+' )
		C_plus_plus = true;
        ++argv;--argc;
	for ( --argc, ++argv; argc ; --argc, ++argv )
	{
		if ( argv[0][0] != '-' || argv[0][1] == '\0' )
			break;
		arg = argv[0];
		for ( i = 1; arg[i] != '\0'; ++i )
			switch ( arg[i] )
				{
				case '+':
					C_plus_plus = true;
					break;
				case 'B':
					interactive = false;
					interactive_given = true;
					break;
				case 'b':
					backing_up_report = true;
					break;
				case 'c':
					fprintf( err,""%s: Assuming use of deprecated -c flag is really intended to be -C\n"",
					program_name );
				case 'C':
					if ( i != 1 )
						flexerror(""-C flag must be given separately"" );
					if ( ! sawcmpflag )
						{
						useecs = false;
						usemecs = false;
						fulltbl = false;
						sawcmpflag = true;
						}
					for ( ++i; arg[i] != '\0'; ++i )
						switch ( arg[i] )
							{
							case 'a':
								long_align =true;
								break;
							case 'e':
								useecs = true;
								break;
							case 'F':
								fullspd = true;
								break;
							case 'f':
								fulltbl = true;
								break;
							case 'm':
								usemecs = true;
								break;
							case 'r':
								use_read = true;
								break;
							default:
								lerrif(""unknown -C option '%c'"",(int) arg[i]);   
								break;
							}
					goto get_next_arg;
				case 'd':
					ddebug = true;
					break;
				case 'f':
					useecs = usemecs = false;
					use_read = fulltbl = true;
					break;
				case 'F':
					useecs = usemecs = false;
					use_read = fullspd = true;
					break;
				case 'h':",
1557,"	action_array[0] = '\0';
        program_name = ""Executable"";
	if ( program_name[0] != '\0' && program_name[strlen( program_name ) - 1] == '+' )
		C_plus_plus = true;
        ++argv;--argc;
	for ( --argc, ++argv; argc ; --argc, ++argv )
	{
		if ( argv[0][0] != '-' || argv[0][1] == '\0' )
			break;
		arg = argv[0];
		for ( i = 1; arg[i] != '\0'; ++i )
			switch ( arg[i] )
				{
				case '+':
					C_plus_plus = true;
					break;
				case 'B':
					interactive = false;
					interactive_given = true;
					break;
				case 'b':
					backing_up_report = true;
					break;
				case 'c':
					fprintf( err,""%s: Assuming use of deprecated -c flag is really intended to be -C\n"",
					program_name );
				case 'C':
					if ( i > 1 )
						flexerror(""-C flag must be given separately"" );
					if ( ! sawcmpflag )
						{
						useecs = false;
						usemecs = false;
						fulltbl = false;
						sawcmpflag = true;
						}
					for ( ++i; arg[i] != '\0'; ++i )
						switch ( arg[i] )
							{
							case 'a':
								long_align =true;
								break;
							case 'e':
								useecs = true;
								break;
							case 'F':
								fullspd = true;
								break;
							case 'f':
								fulltbl = true;
								break;
							case 'm':
								usemecs = true;
								break;
							case 'r':
								use_read = true;
								break;
							default:
								lerrif(""unknown -C option '%c'"",(int) arg[i]);   
								break;
							}
					goto get_next_arg;
				case 'd':
					ddebug = true;
					break;
				case 'f':
					useecs = usemecs = false;
					use_read = fulltbl = true;
					break;
				case 'F':
					useecs = usemecs = false;
					use_read = fullspd = true;
					break;
				case 'h':","<mb:mutant#7a5420dc95a893405174cac84d6933ab9c7d2975> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -1156 +1156 @@
-					if ( i != 1 )
+					if ( i > 1 )
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Flex.c> ."
1558,"void flexend( exit_status )
int exit_status;
	{
	int tblsiz;
	int unlink();
	if ( skelfile != NULL )
		{
		if ( ferror( skelfile ) )
			flexfatal(
				""error occurred when reading skeleton file"" );
		else if ( fclose( skelfile ) )
			flexfatal(
				""error occurred when closing skeleton file"" );
		}
	if ( exit_status != 0 && outfile_created )
		{
		if ( ferror( stdout ) )
			flexfatal( ""error occurred when writing output file"" );
		else if ( fclose( stdout ) )
			flexfatal( ""error occurred when closing output file"" );
		else if ( unlink( outfile_path ) )
			flexfatal( ""error occurred when deleting output file"" );
		}
	if ( backing_up_report && backing_up_file )
		{
		if ( num_backing_up == 0 )
			fprintf( backing_up_file, ""No backing up.\n"" );
		else if ( fullspd || fulltbl )
			fprintf( backing_up_file,
				""%d backing up (non-accepting) states.\n"",
				num_backing_up );
		else
			fprintf( backing_up_file,
				""Compressed tables always back up.\n"" );
		if ( ferror( backing_up_file ) )
			flexfatal( ""error occurred when writing backup file"" );
		else if ( fclose( backing_up_file ) )
			flexfatal( ""error occurred when closing backup file"" );
		}
	if ( printstats )
		{
		fprintf( err, ""%s version %s usage statistics:\n"",
			program_name, flex_version );
		fprintf( err, ""  scanner options: -"" );
		if ( C_plus_plus )
			putc( '+', err );
		if ( backing_up_report )
			putc( 'b', err );
		if ( ddebug )
			putc( 'd', err );
		if ( caseins )
			putc( 'i', err );
		if ( lex_compat )
			putc( 'l', err );
		if ( performance_report > 0 )
			putc( 'p', err );
		if ( performance_report > 1 )
			putc( 'p', err );
		if ( spprdflt )
			putc( 's', err );
		if ( use_stdout )
			putc( 't', err );",
1559,"void flexend( exit_status )
int exit_status;
	{
	int tblsiz;
	int unlink();
	if ( skelfile > NULL )
		{
		if ( ferror( skelfile ) )
			flexfatal(
				""error occurred when reading skeleton file"" );
		else if ( fclose( skelfile ) )
			flexfatal(
				""error occurred when closing skeleton file"" );
		}
	if ( exit_status != 0 && outfile_created )
		{
		if ( ferror( stdout ) )
			flexfatal( ""error occurred when writing output file"" );
		else if ( fclose( stdout ) )
			flexfatal( ""error occurred when closing output file"" );
		else if ( unlink( outfile_path ) )
			flexfatal( ""error occurred when deleting output file"" );
		}
	if ( backing_up_report && backing_up_file )
		{
		if ( num_backing_up == 0 )
			fprintf( backing_up_file, ""No backing up.\n"" );
		else if ( fullspd || fulltbl )
			fprintf( backing_up_file,
				""%d backing up (non-accepting) states.\n"",
				num_backing_up );
		else
			fprintf( backing_up_file,
				""Compressed tables always back up.\n"" );
		if ( ferror( backing_up_file ) )
			flexfatal( ""error occurred when writing backup file"" );
		else if ( fclose( backing_up_file ) )
			flexfatal( ""error occurred when closing backup file"" );
		}
	if ( printstats )
		{
		fprintf( err, ""%s version %s usage statistics:\n"",
			program_name, flex_version );
		fprintf( err, ""  scanner options: -"" );
		if ( C_plus_plus )
			putc( '+', err );
		if ( backing_up_report )
			putc( 'b', err );
		if ( ddebug )
			putc( 'd', err );
		if ( caseins )
			putc( 'i', err );
		if ( lex_compat )
			putc( 'l', err );
		if ( performance_report > 0 )
			putc( 'p', err );
		if ( performance_report > 1 )
			putc( 'p', err );
		if ( spprdflt )
			putc( 's', err );
		if ( use_stdout )
			putc( 't', err );","<mb:mutant#ff95eae15cec6f60f495d2b94a4a77f8817785ed> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -1596 +1596 @@
-	if ( skelfile != NULL )
+	if ( skelfile > NULL )
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#AOIU>,
        <mb:operator#AORB>,
        <mb:operator#AORS>,
        <mb:operator#ROD>,
        <mb:operator#ROR>,
        <mb:operator#SEOD>,
        <mb:operator#SEOI> ;
    mb:program <mb:program#Flex.c> ."
1560,"	lastccl = 0;
	lastsc = 0;
	if ( skelname && (skelfile = fopen( skelname, ""r"" )) == NULL )
		lerrsf( ""can't open skeleton file %s"", skelname );
	if ( strcmp( prefix, ""yy"" ) )
		{
#define GEN_PREFIX(name) printf( ""#define yy%s %s%s\n"", name, prefix, name );
		GEN_PREFIX( ""FlexLexer"" );
		GEN_PREFIX( ""_create_buffer"" );
		GEN_PREFIX( ""_delete_buffer"" );
		GEN_PREFIX( ""_flex_debug"" );
		GEN_PREFIX( ""_init_buffer"" );
		GEN_PREFIX( ""_load_buffer_state"" );
		GEN_PREFIX( ""_switch_to_buffer"" );
		GEN_PREFIX( ""in"" );
		GEN_PREFIX( ""leng"" );
		GEN_PREFIX( ""lex"" );
		GEN_PREFIX( ""out"" );
		GEN_PREFIX( ""restart"" );
		GEN_PREFIX( ""text"" );
		GEN_PREFIX( ""wrap"" );
		printf( ""\n"" );
		}
	lastdfa = lastnfa = 0;
	num_rules = num_eof_rules = default_rule = 0;
	numas = numsnpairs = tmpuses = 0;
	numecs = numeps = eps2 = num_reallocs = hshcol = dfaeql = totnst = 0;
	numuniq = numdup = hshsave = eofseen = datapos = dataline = 0;
	num_backing_up = onesp = numprots = 0;
	variable_trailing_context_rules = bol_needed = false;
	linenum = sectnum = 1;
	firstprot = NIL;
	lastprot = 1;
	if ( useecs )
		{
		ecgroup[1] = NIL;
		for ( i = 2; i <= csize; ++i )
			{
			ecgroup[i] = i - 1;
			nextecm[i - 1] = i;
			}
		nextecm[csize] = NIL;
		}
	else
		{
		for ( i = 1; i <= csize; ++i )
			{
			ecgroup[i] = i;
			nextecm[i] = BAD_SUBSCRIPT;	 
			}
		}
	set_up_initial_allocations();
	}",
1561,"	lastccl = 0;
	lastsc = 0;
	if ( skelname && (skelfile = fopen( skelname, ""r"" )) == NULL )
		lerrsf( ""can't open skeleton file %s"", skelname );
	if ( strcmp( prefix, ""yy"" ) )
		{
#define GEN_PREFIX(name) printf( ""#define yy%s %s%s\n"", name, prefix, name );
		GEN_PREFIX( ""FlexLexer"" );
		GEN_PREFIX( ""_create_buffer"" );
		GEN_PREFIX( ""_delete_buffer"" );
		GEN_PREFIX( ""_flex_debug"" );
		GEN_PREFIX( ""_init_buffer"" );
		GEN_PREFIX( ""_load_buffer_state"" );
		GEN_PREFIX( ""_switch_to_buffer"" );
		GEN_PREFIX( ""in"" );
		GEN_PREFIX( ""leng"" );
		GEN_PREFIX( ""lex"" );
		GEN_PREFIX( ""out"" );
		GEN_PREFIX( ""restart"" );
		GEN_PREFIX( ""text"" );
		GEN_PREFIX( ""wrap"" );
		printf( ""\n"" );
		}
	lastdfa = lastnfa = 0;
	num_rules = num_eof_rules = default_rule = 0;
	numas = numsnpairs = tmpuses = 0;
	numecs = numeps = eps2 = num_reallocs = hshcol = dfaeql = totnst = 0;
	numuniq = numdup = hshsave = eofseen = datapos = dataline = 0;
	num_backing_up = onesp = numprots = 0;
	variable_trailing_context_rules = bol_needed = false;
	linenum = sectnum = 1;
	firstprot = NIL;
	lastprot = 1;
	if ( useecs )
		{
		ecgroup[1] = NIL;
		for ( i = 2; i <= csize; ++i )
			{
			ecgroup[i] = i - 1;
			nextecm[i - 1] = i;
			}
		nextecm[csize] = NIL;
		}
	else
		{
		for ( i = 1; i <= csize; ++i )
			{
			ecgroup[i] = i;
			nextecm[i] = BAD_SUBSCRIPT;	 
			}
		}
	set_up_initial_allocations();
	}","<mb:mutant#d54c5ac4f5e7ad0bf79e9099de5b269d82e8c0de> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -1377 +1377 @@
-	input_files = argv;
+	input_files = abs(argv);
@@ -1770 +1769 @@
-			tblsiz = tblsiz + csize;
+			tblsiz = tblsiz + abs(csize);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Flex.c> ."
1562,"void flexend( exit_status )
int exit_status;
	{
	int tblsiz;
	int unlink();
	if ( skelfile != NULL )
		{
		if ( ferror( skelfile ) )
			flexfatal(
				""error occurred when reading skeleton file"" );
		else if ( fclose( skelfile ) )
			flexfatal(
				""error occurred when closing skeleton file"" );
		}
	if ( exit_status != 0 && outfile_created )
		{
		if ( ferror( stdout ) )
			flexfatal( ""error occurred when writing output file"" );
		else if ( fclose( stdout ) )
			flexfatal( ""error occurred when closing output file"" );
		else if ( unlink( outfile_path ) )
			flexfatal( ""error occurred when deleting output file"" );
		}
	if ( backing_up_report && backing_up_file )
		{
		if ( num_backing_up == 0 )
			fprintf( backing_up_file, ""No backing up.\n"" );
		else if ( fullspd || fulltbl )
			fprintf( backing_up_file,
				""%d backing up (non-accepting) states.\n"",
				num_backing_up );
		else
			fprintf( backing_up_file,
				""Compressed tables always back up.\n"" );
		if ( ferror( backing_up_file ) )
			flexfatal( ""error occurred when writing backup file"" );
		else if ( fclose( backing_up_file ) )
			flexfatal( ""error occurred when closing backup file"" );
		}
	if ( printstats )
		{
		fprintf( err, ""%s version %s usage statistics:\n"",
			program_name, flex_version );
		fprintf( err, ""  scanner options: -"" );
		if ( C_plus_plus )
			putc( '+', err );
		if ( backing_up_report )
			putc( 'b', err );
		if ( ddebug )
			putc( 'd', err );
		if ( caseins )
			putc( 'i', err );
		if ( lex_compat )
			putc( 'l', err );
		if ( performance_report > 0 )
			putc( 'p', err );
		if ( performance_report > 1 )
			putc( 'p', err );
		if ( spprdflt )
			putc( 's', err );
		if ( use_stdout )
			putc( 't', err );",
1563,"void flexend( exit_status )
int exit_status;
	{
	int tblsiz;
	int unlink();
	if ( skelfile != NULL )
		{
		if ( ferror( skelfile ) )
			flexfatal(
				""error occurred when reading skeleton file"" );
		else if ( fclose( skelfile ) )
			flexfatal(
				""error occurred when closing skeleton file"" );
		}
	if ( exit_status != 0 && outfile_created )
		{
		if ( ferror( stdout ) )
			flexfatal( ""error occurred when writing output file"" );
		else if ( fclose( stdout ) )
			flexfatal( ""error occurred when closing output file"" );
		else if ( unlink( outfile_path ) )
			flexfatal( ""error occurred when deleting output file"" );
		}
	if ( backing_up_report && backing_up_file )
		{
		if ( num_backing_up <= 0 )
			fprintf( backing_up_file, ""No backing up.\n"" );
		else if ( fullspd || fulltbl )
			fprintf( backing_up_file,
				""%d backing up (non-accepting) states.\n"",
				num_backing_up );
		else
			fprintf( backing_up_file,
				""Compressed tables always back up.\n"" );
		if ( ferror( backing_up_file ) )
			flexfatal( ""error occurred when writing backup file"" );
		else if ( fclose( backing_up_file ) )
			flexfatal( ""error occurred when closing backup file"" );
		}
	if ( printstats )
		{
		fprintf( err, ""%s version %s usage statistics:\n"",
			program_name, flex_version );
		fprintf( err, ""  scanner options: -"" );
		if ( C_plus_plus )
			putc( '+', err );
		if ( backing_up_report )
			putc( 'b', err );
		if ( ddebug )
			putc( 'd', err );
		if ( caseins )
			putc( 'i', err );
		if ( lex_compat )
			putc( 'l', err );
		if ( performance_report > 0 )
			putc( 'p', err );
		if ( performance_report > 1 )
			putc( 'p', err );
		if ( spprdflt )
			putc( 's', err );
		if ( use_stdout )
			putc( 't', err );","<mb:mutant#0eabfdc2dc1639b1d2ffaffc92eb456cdbf5df51> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -1621 +1621 @@
-		if ( num_backing_up == 0 )
+		if ( num_backing_up <= 0 )
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Flex.c> ."
1564,"void flexend( exit_status )
int exit_status;
	{
	int tblsiz;
	int unlink();
	if ( skelfile != NULL )
		{
		if ( ferror( skelfile ) )
			flexfatal(
				""error occurred when reading skeleton file"" );
		else if ( fclose( skelfile ) )
			flexfatal(
				""error occurred when closing skeleton file"" );
		}
	if ( exit_status != 0 && outfile_created )
		{
		if ( ferror( stdout ) )
			flexfatal( ""error occurred when writing output file"" );
		else if ( fclose( stdout ) )
			flexfatal( ""error occurred when closing output file"" );
		else if ( unlink( outfile_path ) )
			flexfatal( ""error occurred when deleting output file"" );
		}
	if ( backing_up_report && backing_up_file )
		{
		if ( num_backing_up == 0 )
			fprintf( backing_up_file, ""No backing up.\n"" );
		else if ( fullspd || fulltbl )
			fprintf( backing_up_file,
				""%d backing up (non-accepting) states.\n"",
				num_backing_up );
		else
			fprintf( backing_up_file,
				""Compressed tables always back up.\n"" );
		if ( ferror( backing_up_file ) )
			flexfatal( ""error occurred when writing backup file"" );
		else if ( fclose( backing_up_file ) )
			flexfatal( ""error occurred when closing backup file"" );
		}
	if ( printstats )
		{
		fprintf( err, ""%s version %s usage statistics:\n"",
			program_name, flex_version );
		fprintf( err, ""  scanner options: -"" );
		if ( C_plus_plus )
			putc( '+', err );
		if ( backing_up_report )
			putc( 'b', err );
		if ( ddebug )
			putc( 'd', err );
		if ( caseins )
			putc( 'i', err );
		if ( lex_compat )
			putc( 'l', err );
		if ( performance_report > 0 )
			putc( 'p', err );
		if ( performance_report > 1 )
			putc( 'p', err );
		if ( spprdflt )
			putc( 's', err );
		if ( use_stdout )
			putc( 't', err );",
1565,"void flexend( exit_status )
int exit_status;
	{
	int tblsiz;
	int unlink();
	if ( skelfile != NULL )
		{
		if ( ferror( skelfile ) )
			flexfatal(
				""error occurred when reading skeleton file"" );
		else if ( fclose( skelfile ) )
			flexfatal(
				""error occurred when closing skeleton file"" );
		}
	if ( exit_status > 0 && outfile_created )
		{
		if ( ferror( stdout ) )
			flexfatal( ""error occurred when writing output file"" );
		else if ( fclose( stdout ) )
			flexfatal( ""error occurred when closing output file"" );
		else if ( unlink( outfile_path ) )
			flexfatal( ""error occurred when deleting output file"" );
		}
	if ( backing_up_report && backing_up_file )
		{
		if ( num_backing_up == 0 )
			fprintf( backing_up_file, ""No backing up.\n"" );
		else if ( fullspd || fulltbl )
			fprintf( backing_up_file,
				""%d backing up (non-accepting) states.\n"",
				num_backing_up );
		else
			fprintf( backing_up_file,
				""Compressed tables always back up.\n"" );
		if ( ferror( backing_up_file ) )
			flexfatal( ""error occurred when writing backup file"" );
		else if ( fclose( backing_up_file ) )
			flexfatal( ""error occurred when closing backup file"" );
		}
	if ( printstats )
		{
		fprintf( err, ""%s version %s usage statistics:\n"",
			program_name, flex_version );
		fprintf( err, ""  scanner options: -"" );
		if ( C_plus_plus )
			putc( '+', err );
		if ( backing_up_report )
			putc( 'b', err );
		if ( ddebug )
			putc( 'd', err );
		if ( caseins )
			putc( 'i', err );
		if ( lex_compat )
			putc( 'l', err );
		if ( performance_report > 0 )
			putc( 'p', err );
		if ( performance_report > 1 )
			putc( 'p', err );
		if ( spprdflt )
			putc( 's', err );
		if ( use_stdout )
			putc( 't', err );","<mb:mutant#8ba3855098feb0bb240d5acabd6bf20c27ddc701> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -1607 +1607 @@
-	if ( exit_status != 0 && outfile_created )
+	if ( exit_status > 0 && outfile_created )
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Flex.c> ."
1566,"void flexinit( argc, argv )
int argc;
char **argv;
	{
	int i, sawcmpflag;
	int csize_given, interactive_given;
	char *arg, *mktemp();
	printstats = syntaxerror = trace = spprdflt = caseins = false;
	lex_compat = false;
	C_plus_plus = backing_up_report = ddebug = fulltbl = fullspd = false;
	long_align = nowarn = yymore_used = continued_action = reject = false;
	yytext_is_array = yymore_really_used = reject_really_used = false;
	gen_line_dirs = usemecs = useecs = true;
	performance_report = 0;
	sawcmpflag = false;
	use_read = use_stdout = false;
	csize_given = false;
	interactive_given = false;
	action_size = 2048;	 
	action_array = allocate_character_array( action_size );
	defs1_offset = prolog_offset = action_offset = action_index = 0;
	action_array[0] = '\0';
        program_name = ""Executable"";
	if ( program_name[0] != '\0' && program_name[strlen( program_name ) - 1] == '+' )
		C_plus_plus = true;
        ++argv;--argc;
	for ( --argc, ++argv; argc ; --argc, ++argv )
	{
		if ( argv[0][0] != '-' || argv[0][1] == '\0' )
			break;
		arg = argv[0];
		for ( i = 1; arg[i] != '\0'; ++i )
			switch ( arg[i] )
				{
				case '+':
					C_plus_plus = true;
					break;
				case 'B':
					interactive = false;
					interactive_given = true;
					break;
				case 'b':
					backing_up_report = true;
					break;
				case 'c':
					fprintf( err,""%s: Assuming use of deprecated -c flag is really intended to be -C\n"",
					program_name );
				case 'C':
					if ( i != 1 )
						flexerror(""-C flag must be given separately"" );
					if ( ! sawcmpflag )
						{
						useecs = false;
						usemecs = false;
						fulltbl = false;
						sawcmpflag = true;
						}
					for ( ++i; arg[i] != '\0'; ++i )
						switch ( arg[i] )",
1567,"void flexinit( argc, argv )
int argc;
char **argv;
	{
	int i, sawcmpflag;
	int csize_given, interactive_given;
	char *arg, *mktemp();
	printstats = syntaxerror = trace = spprdflt = caseins = false;
	lex_compat = false;
	C_plus_plus = backing_up_report = ddebug = fulltbl = fullspd = false;
	long_align = nowarn = yymore_used = continued_action = reject = false;
	yytext_is_array = yymore_really_used = reject_really_used = false;
	gen_line_dirs = usemecs = useecs = true;
	performance_report = 0;
	sawcmpflag = false;
	use_read = use_stdout = false;
	csize_given = false;
	interactive_given = false;
	action_size = 2048;	 
	action_array = allocate_character_array( action_size );
	defs1_offset = prolog_offset = action_offset = action_index = 0;
	action_array[0] = '\0';
        program_name = ""Executable"";
	if ( program_name[0] > '\0' && program_name[strlen( program_name ) - 1] == '+' )
		C_plus_plus = true;
        ++argv;--argc;
	for ( --argc, ++argv; argc ; --argc, ++argv )
	{
		if ( argv[0][0] != '-' || argv[0][1] == '\0' )
			break;
		arg = argv[0];
		for ( i = 1; arg[i] != '\0'; ++i )
			switch ( arg[i] )
				{
				case '+':
					C_plus_plus = true;
					break;
				case 'B':
					interactive = false;
					interactive_given = true;
					break;
				case 'b':
					backing_up_report = true;
					break;
				case 'c':
					fprintf( err,""%s: Assuming use of deprecated -c flag is really intended to be -C\n"",
					program_name );
				case 'C':
					if ( i != 1 )
						flexerror(""-C flag must be given separately"" );
					if ( ! sawcmpflag )
						{
						useecs = false;
						usemecs = false;
						fulltbl = false;
						sawcmpflag = true;
						}
					for ( ++i; arg[i] != '\0'; ++i )
						switch ( arg[i] )","<mb:mutant#a3571c6ecdf300133837966385213c33e598ad56> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -1113 +1113 @@
-	if ( program_name[0] != '\\0' && program_name[strlen( program_name ) - 1] == '+' )
+	if ( program_name[0] > '\\0' && program_name[strlen( program_name ) - 1] == '+' )
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Flex.c> ."
1568,"	if ( (fulltbl || fullspd) && interactive )
		flexerror( ""-Cf/-CF and -I are incompatible"" );
	if ( fulltbl && fullspd )
		flexerror( ""-Cf and -CF are mutually exclusive"" );
	if ( C_plus_plus && fullspd )
		flexerror( ""Can't use -+ with -CF option"" );
	if ( ! use_stdout )
	{
		FILE *prev_stdout;
		char *suffix;
		if ( C_plus_plus )
			suffix = ""cc"";
		else
			suffix = ""c"";
		sprintf( outfile_path, outfile_template, prefix, suffix );
		prev_stdout = freopen( outfile_path, ""w"", stdout );
		if ( prev_stdout == NULL )
			lerrsf( ""could not create %s"", outfile_path );
		outfile_created = 1;
	}
	num_input_files = argc;
	input_files = argv;
	set_input_file( num_input_files > 0 ? input_files[0] : NULL );
	if ( backing_up_report )
		{
#ifndef SHORT_FILE_NAMES
		backing_up_file = fopen( ""lex.backup"", ""w"" );
#else
		backing_up_file = fopen( ""lex.bck"", ""w"" );
#endif
		if ( backing_up_file == NULL )
			flexerror( ""could not create lex.backup"" );
		}
	else
		backing_up_file = NULL;
	lastccl = 0;
	lastsc = 0;
	if ( skelname && (skelfile = fopen( skelname, ""r"" )) == NULL )
		lerrsf( ""can't open skeleton file %s"", skelname );
	if ( strcmp( prefix, ""yy"" ) )
		{
#define GEN_PREFIX(name) printf( ""#define yy%s %s%s\n"", name, prefix, name );
		GEN_PREFIX( ""FlexLexer"" );
		GEN_PREFIX( ""_create_buffer"" );
		GEN_PREFIX( ""_delete_buffer"" );
		GEN_PREFIX( ""_flex_debug"" );
		GEN_PREFIX( ""_init_buffer"" );
		GEN_PREFIX( ""_load_buffer_state"" );
		GEN_PREFIX( ""_switch_to_buffer"" );
		GEN_PREFIX( ""in"" );
		GEN_PREFIX( ""leng"" );
		GEN_PREFIX( ""lex"" );
		GEN_PREFIX( ""out"" );
		GEN_PREFIX( ""restart"" );",
1569,"	if ( (fulltbl || fullspd) && interactive )
		flexerror( ""-Cf/-CF and -I are incompatible"" );
	if ( fulltbl && fullspd )
		flexerror( ""-Cf and -CF are mutually exclusive"" );
	if ( C_plus_plus && fullspd )
		flexerror( ""Can't use -+ with -CF option"" );
	if ( ! use_stdout )
	{
		FILE *prev_stdout;
		char *suffix;
		if ( C_plus_plus )
			suffix = ""cc"";
		else
			suffix = ""c"";
		sprintf( outfile_path, outfile_template, prefix, suffix );
		prev_stdout = freopen( outfile_path, ""w"", stdout );
		if ( prev_stdout == NULL )
			lerrsf( ""could not create %s"", outfile_path );
		outfile_created = 1;
	}
	num_input_files = argc;
	input_files = argv;
	set_input_file( num_input_files > 0 ? input_files[0] : NULL );
	if ( backing_up_report )
		{
#ifndef SHORT_FILE_NAMES
		backing_up_file = fopen( ""lex.backup"", ""w"" );
#else
		backing_up_file = fopen( ""lex.bck"", ""w"" );
#endif
		if ( backing_up_file == NULL )
			flexerror( ""could not create lex.backup"" );
		}
	else
		backing_up_file = NULL;
	lastccl = 0;
	lastsc = 0;
	if ( skelname && (skelfile = fopen( skelname, ""r"" )) == NULL )
		lerrsf( ""can't open skeleton file %s"", skelname );
	if ( strcmp( prefix, ""yy"" ) )
		{
#define GEN_PREFIX(name) printf( ""#define yy%s %s%s\n"", name, prefix, name );
		GEN_PREFIX( ""FlexLexer"" );
		GEN_PREFIX( ""_create_buffer"" );
		GEN_PREFIX( ""_delete_buffer"" );
		GEN_PREFIX( ""_flex_debug"" );
		GEN_PREFIX( ""_init_buffer"" );
		GEN_PREFIX( ""_load_buffer_state"" );
		GEN_PREFIX( ""_switch_to_buffer"" );
		GEN_PREFIX( ""in"" );
		GEN_PREFIX( ""leng"" );
		GEN_PREFIX( ""lex"" );
		GEN_PREFIX( ""out"" );
		GEN_PREFIX( ""restart"" );","<mb:mutant#425462e5e2735e6ea6b0e422e41dd97765c962a9> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -1255 +1255 @@
-					if ( i != 1 )
+					if ( i > 1 )
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Flex.c> ."
1570,"	lastccl = 0;
	lastsc = 0;
	if ( skelname && (skelfile = fopen( skelname, ""r"" )) == NULL )
		lerrsf( ""can't open skeleton file %s"", skelname );
	if ( strcmp( prefix, ""yy"" ) )
		{
#define GEN_PREFIX(name) printf( ""#define yy%s %s%s\n"", name, prefix, name );
		GEN_PREFIX( ""FlexLexer"" );
		GEN_PREFIX( ""_create_buffer"" );
		GEN_PREFIX( ""_delete_buffer"" );
		GEN_PREFIX( ""_flex_debug"" );
		GEN_PREFIX( ""_init_buffer"" );
		GEN_PREFIX( ""_load_buffer_state"" );
		GEN_PREFIX( ""_switch_to_buffer"" );
		GEN_PREFIX( ""in"" );
		GEN_PREFIX( ""leng"" );
		GEN_PREFIX( ""lex"" );
		GEN_PREFIX( ""out"" );
		GEN_PREFIX( ""restart"" );
		GEN_PREFIX( ""text"" );
		GEN_PREFIX( ""wrap"" );
		printf( ""\n"" );
		}
	lastdfa = lastnfa = 0;
	num_rules = num_eof_rules = default_rule = 0;
	numas = numsnpairs = tmpuses = 0;
	numecs = numeps = eps2 = num_reallocs = hshcol = dfaeql = totnst = 0;
	numuniq = numdup = hshsave = eofseen = datapos = dataline = 0;
	num_backing_up = onesp = numprots = 0;
	variable_trailing_context_rules = bol_needed = false;
	linenum = sectnum = 1;
	firstprot = NIL;
	lastprot = 1;
	if ( useecs )
		{
		ecgroup[1] = NIL;
		for ( i = 2; i <= csize; ++i )
			{
			ecgroup[i] = i - 1;
			nextecm[i - 1] = i;
			}
		nextecm[csize] = NIL;
		}
	else
		{
		for ( i = 1; i <= csize; ++i )
			{
			ecgroup[i] = i;
			nextecm[i] = BAD_SUBSCRIPT;	 
			}
		}
	set_up_initial_allocations();
	}",
1571,"	lastccl = 0;
	lastsc = 0;
	if ( skelname && (skelfile = fopen( skelname, ""r"" )) == NULL )
		lerrsf( ""can't open skeleton file %s"", skelname );
	if ( strcmp( prefix, ""yy"" ) )
		{
#define GEN_PREFIX(name) printf( ""#define yy%s %s%s\n"", name, prefix, name );
		GEN_PREFIX( ""FlexLexer"" );
		GEN_PREFIX( ""_create_buffer"" );
		GEN_PREFIX( ""_delete_buffer"" );
		GEN_PREFIX( ""_flex_debug"" );
		GEN_PREFIX( ""_init_buffer"" );
		GEN_PREFIX( ""_load_buffer_state"" );
		GEN_PREFIX( ""_switch_to_buffer"" );
		GEN_PREFIX( ""in"" );
		GEN_PREFIX( ""leng"" );
		GEN_PREFIX( ""lex"" );
		GEN_PREFIX( ""out"" );
		GEN_PREFIX( ""restart"" );
		GEN_PREFIX( ""text"" );
		GEN_PREFIX( ""wrap"" );
		printf( ""\n"" );
		}
	lastdfa = lastnfa = 0;
	num_rules = num_eof_rules = default_rule = 0;
	numas = numsnpairs = tmpuses = 0;
	numecs = numeps = eps2 = num_reallocs = hshcol = dfaeql = totnst = 0;
	numuniq = numdup = hshsave = eofseen = datapos = dataline = 0;
	num_backing_up = onesp = numprots = 0;
	variable_trailing_context_rules = bol_needed = false;
	linenum = sectnum = 1;
	firstprot = NIL;
	lastprot = 1;
	if ( useecs )
		{
		ecgroup[1] = NIL;
		for ( i = 2; i <= csize; ++i )
			{
			ecgroup[i] = i - 1;
			nextecm[i - 1] = i;
			}
		nextecm[csize] = NIL;
		}
	else
		{
		for ( i = 1; i <= csize; ++i )
			{
			ecgroup[i] = i;
			nextecm[i] = BAD_SUBSCRIPT;	 
			}
		}
	set_up_initial_allocations();
	}","<mb:mutant#7a7e49e9192baadcdc88879102f9503b42dc7fba> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -1314 +1314 @@
-			csize = DEFAULT_CSIZE;
+			csize = abs(DEFAULT_CSIZE);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Flex.c> ."
1572,"	lastccl = 0;
	lastsc = 0;
	if ( skelname && (skelfile = fopen( skelname, ""r"" )) == NULL )
		lerrsf( ""can't open skeleton file %s"", skelname );
	if ( strcmp( prefix, ""yy"" ) )
		{
#define GEN_PREFIX(name) printf( ""#define yy%s %s%s\n"", name, prefix, name );
		GEN_PREFIX( ""FlexLexer"" );
		GEN_PREFIX( ""_create_buffer"" );
		GEN_PREFIX( ""_delete_buffer"" );
		GEN_PREFIX( ""_flex_debug"" );
		GEN_PREFIX( ""_init_buffer"" );
		GEN_PREFIX( ""_load_buffer_state"" );
		GEN_PREFIX( ""_switch_to_buffer"" );
		GEN_PREFIX( ""in"" );
		GEN_PREFIX( ""leng"" );
		GEN_PREFIX( ""lex"" );
		GEN_PREFIX( ""out"" );
		GEN_PREFIX( ""restart"" );
		GEN_PREFIX( ""text"" );
		GEN_PREFIX( ""wrap"" );
		printf( ""\n"" );
		}
	lastdfa = lastnfa = 0;
	num_rules = num_eof_rules = default_rule = 0;
	numas = numsnpairs = tmpuses = 0;
	numecs = numeps = eps2 = num_reallocs = hshcol = dfaeql = totnst = 0;
	numuniq = numdup = hshsave = eofseen = datapos = dataline = 0;
	num_backing_up = onesp = numprots = 0;
	variable_trailing_context_rules = bol_needed = false;
	linenum = sectnum = 1;
	firstprot = NIL;
	lastprot = 1;
	if ( useecs )
		{
		ecgroup[1] = NIL;
		for ( i = 2; i <= csize; ++i )
			{
			ecgroup[i] = i - 1;
			nextecm[i - 1] = i;
			}
		nextecm[csize] = NIL;
		}
	else
		{
		for ( i = 1; i <= csize; ++i )
			{
			ecgroup[i] = i;
			nextecm[i] = BAD_SUBSCRIPT;	 
			}
		}
	set_up_initial_allocations();
	}",
1573,"	lastccl = 0;
	lastsc = 0;
	if ( skelname && (skelfile = fopen( skelname, ""r"" )) == NULL )
		lerrsf( ""can't open skeleton file %s"", skelname );
	if ( strcmp( prefix, ""yy"" ) )
		{
#define GEN_PREFIX(name) printf( ""#define yy%s %s%s\n"", name, prefix, name );
		GEN_PREFIX( ""FlexLexer"" );
		GEN_PREFIX( ""_create_buffer"" );
		GEN_PREFIX( ""_delete_buffer"" );
		GEN_PREFIX( ""_flex_debug"" );
		GEN_PREFIX( ""_init_buffer"" );
		GEN_PREFIX( ""_load_buffer_state"" );
		GEN_PREFIX( ""_switch_to_buffer"" );
		GEN_PREFIX( ""in"" );
		GEN_PREFIX( ""leng"" );
		GEN_PREFIX( ""lex"" );
		GEN_PREFIX( ""out"" );
		GEN_PREFIX( ""restart"" );
		GEN_PREFIX( ""text"" );
		GEN_PREFIX( ""wrap"" );
		printf( ""\n"" );
		}
	lastdfa = lastnfa = 0;
	num_rules = num_eof_rules = default_rule = 0;
	numas = numsnpairs = tmpuses = 0;
	numecs = numeps = eps2 = num_reallocs = hshcol = dfaeql = totnst = 0;
	numuniq = numdup = hshsave = eofseen = datapos = dataline = 0;
	num_backing_up = onesp = numprots = 0;
	variable_trailing_context_rules = bol_needed = false;
	linenum = sectnum = 1;
	firstprot = NIL;
	lastprot = 1;
	if ( useecs )
		{
		ecgroup[1] = NIL;
		for ( i = 2; i <= csize; ++i )
			{
			ecgroup[i] = i - 1;
			nextecm[i - 1] = i;
			}
		nextecm[csize] = NIL;
		}
	else
		{
		for ( i = 1; i <= csize; ++i )
			{
			ecgroup[i] = i;
			nextecm[i] = BAD_SUBSCRIPT;	 
			}
		}
	set_up_initial_allocations();
	}","<mb:mutant#6ed89b06c514c2bf066c236671f1f5e8401dc79b> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -1376 +1376 @@
-	num_input_files = argc;
+	num_input_files = abs(argc);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Flex.c> ."
1574,"	lastccl = 0;
	lastsc = 0;
	if ( skelname && (skelfile = fopen( skelname, ""r"" )) == NULL )
		lerrsf( ""can't open skeleton file %s"", skelname );
	if ( strcmp( prefix, ""yy"" ) )
		{
#define GEN_PREFIX(name) printf( ""#define yy%s %s%s\n"", name, prefix, name );
		GEN_PREFIX( ""FlexLexer"" );
		GEN_PREFIX( ""_create_buffer"" );
		GEN_PREFIX( ""_delete_buffer"" );
		GEN_PREFIX( ""_flex_debug"" );
		GEN_PREFIX( ""_init_buffer"" );
		GEN_PREFIX( ""_load_buffer_state"" );
		GEN_PREFIX( ""_switch_to_buffer"" );
		GEN_PREFIX( ""in"" );
		GEN_PREFIX( ""leng"" );
		GEN_PREFIX( ""lex"" );
		GEN_PREFIX( ""out"" );
		GEN_PREFIX( ""restart"" );
		GEN_PREFIX( ""text"" );
		GEN_PREFIX( ""wrap"" );
		printf( ""\n"" );
		}
	lastdfa = lastnfa = 0;
	num_rules = num_eof_rules = default_rule = 0;
	numas = numsnpairs = tmpuses = 0;
	numecs = numeps = eps2 = num_reallocs = hshcol = dfaeql = totnst = 0;
	numuniq = numdup = hshsave = eofseen = datapos = dataline = 0;
	num_backing_up = onesp = numprots = 0;
	variable_trailing_context_rules = bol_needed = false;
	linenum = sectnum = 1;
	firstprot = NIL;
	lastprot = 1;
	if ( useecs )
		{
		ecgroup[1] = NIL;
		for ( i = 2; i <= csize; ++i )
			{
			ecgroup[i] = i - 1;
			nextecm[i - 1] = i;
			}
		nextecm[csize] = NIL;
		}
	else
		{
		for ( i = 1; i <= csize; ++i )
			{
			ecgroup[i] = i;
			nextecm[i] = BAD_SUBSCRIPT;	 
			}
		}
	set_up_initial_allocations();
	}",
1575,"	lastccl = 0;
	lastsc = 0;
	if ( skelname && (skelfile = fopen( skelname, ""r"" )) == NULL )
		lerrsf( ""can't open skeleton file %s"", skelname );
	if ( strcmp( prefix, ""yy"" ) )
		{
#define GEN_PREFIX(name) printf( ""#define yy%s %s%s\n"", name, prefix, name );
		GEN_PREFIX( ""FlexLexer"" );
		GEN_PREFIX( ""_create_buffer"" );
		GEN_PREFIX( ""_delete_buffer"" );
		GEN_PREFIX( ""_flex_debug"" );
		GEN_PREFIX( ""_init_buffer"" );
		GEN_PREFIX( ""_load_buffer_state"" );
		GEN_PREFIX( ""_switch_to_buffer"" );
		GEN_PREFIX( ""in"" );
		GEN_PREFIX( ""leng"" );
		GEN_PREFIX( ""lex"" );
		GEN_PREFIX( ""out"" );
		GEN_PREFIX( ""restart"" );
		GEN_PREFIX( ""text"" );
		GEN_PREFIX( ""wrap"" );
		printf( ""\n"" );
		}
	lastdfa = lastnfa = 0;
	num_rules = num_eof_rules = default_rule = 0;
	numas = numsnpairs = tmpuses = 0;
	numecs = numeps = eps2 = num_reallocs = hshcol = dfaeql = totnst = 0;
	numuniq = numdup = hshsave = eofseen = datapos = dataline = 0;
	num_backing_up = onesp = numprots = 0;
	variable_trailing_context_rules = bol_needed = false;
	linenum = sectnum = 1;
	firstprot = NIL;
	lastprot = 1;
	if ( useecs )
		{
		ecgroup[1] = NIL;
		for ( i = 2; i <= csize; ++i )
			{
			ecgroup[i] = i - 1;
			nextecm[i - 1] = i;
			}
		nextecm[csize] = NIL;
		}
	else
		{
		for ( i = 1; i <= csize; ++i )
			{
			ecgroup[i] = i;
			nextecm[i] = BAD_SUBSCRIPT;	 
			}
		}
	set_up_initial_allocations();
	}","<mb:mutant#05ad75a5296757e92ee4e6a972a6e33c73b8f89a> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -1388 +1388 @@
-		if ( backing_up_file == NULL )
+		if ( backing_up_file <= NULL )
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Flex.c> ."
1576,"	lastccl = 0;
	lastsc = 0;
	if ( skelname && (skelfile = fopen( skelname, ""r"" )) == NULL )
		lerrsf( ""can't open skeleton file %s"", skelname );
	if ( strcmp( prefix, ""yy"" ) )
		{
#define GEN_PREFIX(name) printf( ""#define yy%s %s%s\n"", name, prefix, name );
		GEN_PREFIX( ""FlexLexer"" );
		GEN_PREFIX( ""_create_buffer"" );
		GEN_PREFIX( ""_delete_buffer"" );
		GEN_PREFIX( ""_flex_debug"" );
		GEN_PREFIX( ""_init_buffer"" );
		GEN_PREFIX( ""_load_buffer_state"" );
		GEN_PREFIX( ""_switch_to_buffer"" );
		GEN_PREFIX( ""in"" );
		GEN_PREFIX( ""leng"" );
		GEN_PREFIX( ""lex"" );
		GEN_PREFIX( ""out"" );
		GEN_PREFIX( ""restart"" );
		GEN_PREFIX( ""text"" );
		GEN_PREFIX( ""wrap"" );
		printf( ""\n"" );
		}
	lastdfa = lastnfa = 0;
	num_rules = num_eof_rules = default_rule = 0;
	numas = numsnpairs = tmpuses = 0;
	numecs = numeps = eps2 = num_reallocs = hshcol = dfaeql = totnst = 0;
	numuniq = numdup = hshsave = eofseen = datapos = dataline = 0;
	num_backing_up = onesp = numprots = 0;
	variable_trailing_context_rules = bol_needed = false;
	linenum = sectnum = 1;
	firstprot = NIL;
	lastprot = 1;
	if ( useecs )
		{
		ecgroup[1] = NIL;
		for ( i = 2; i <= csize; ++i )
			{
			ecgroup[i] = i - 1;
			nextecm[i - 1] = i;
			}
		nextecm[csize] = NIL;
		}
	else
		{
		for ( i = 1; i <= csize; ++i )
			{
			ecgroup[i] = i;
			nextecm[i] = BAD_SUBSCRIPT;	 
			}
		}
	set_up_initial_allocations();
	}",
1577,"	lastccl = 0;
	lastsc = 0;
	if ( skelname && (skelfile = fopen( skelname, ""r"" )) == NULL )
		lerrsf( ""can't open skeleton file %s"", skelname );
	if ( strcmp( prefix, ""yy"" ) )
		{
#define GEN_PREFIX(name) printf( ""#define yy%s %s%s\n"", name, prefix, name );
		GEN_PREFIX( ""FlexLexer"" );
		GEN_PREFIX( ""_create_buffer"" );
		GEN_PREFIX( ""_delete_buffer"" );
		GEN_PREFIX( ""_flex_debug"" );
		GEN_PREFIX( ""_init_buffer"" );
		GEN_PREFIX( ""_load_buffer_state"" );
		GEN_PREFIX( ""_switch_to_buffer"" );
		GEN_PREFIX( ""in"" );
		GEN_PREFIX( ""leng"" );
		GEN_PREFIX( ""lex"" );
		GEN_PREFIX( ""out"" );
		GEN_PREFIX( ""restart"" );
		GEN_PREFIX( ""text"" );
		GEN_PREFIX( ""wrap"" );
		printf( ""\n"" );
		}
	lastdfa = lastnfa = 0;
	num_rules = num_eof_rules = default_rule = 0;
	numas = numsnpairs = tmpuses = 0;
	numecs = numeps = eps2 = num_reallocs = hshcol = dfaeql = totnst = 0;
	numuniq = numdup = hshsave = eofseen = datapos = dataline = 0;
	num_backing_up = onesp = numprots = 0;
	variable_trailing_context_rules = bol_needed = false;
	linenum = sectnum = 1;
	firstprot = NIL;
	lastprot = 1;
	if ( useecs )
		{
		ecgroup[1] = NIL;
		for ( i = 2; i <= csize; ++i )
			{
			ecgroup[i] = i - 1;
			nextecm[i - 1] = i;
			}
		nextecm[csize] = NIL;
		}
	else
		{
		for ( i = 1; i <= csize; ++i )
			{
			ecgroup[i] = i;
			nextecm[i] = BAD_SUBSCRIPT;	 
			}
		}
	set_up_initial_allocations();
	}","<mb:mutant#d54c5ac4f5e7ad0bf79e9099de5b269d82e8c0de> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -1377 +1377 @@
-	input_files = argv;
+	input_files = abs(argv);
@@ -1770 +1769 @@
-			tblsiz = tblsiz + csize;
+			tblsiz = tblsiz + abs(csize);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Flex.c> ."
1578,"	lastccl = 0;
	lastsc = 0;
	if ( skelname && (skelfile = fopen( skelname, ""r"" )) == NULL )
		lerrsf( ""can't open skeleton file %s"", skelname );
	if ( strcmp( prefix, ""yy"" ) )
		{
#define GEN_PREFIX(name) printf( ""#define yy%s %s%s\n"", name, prefix, name );
		GEN_PREFIX( ""FlexLexer"" );
		GEN_PREFIX( ""_create_buffer"" );
		GEN_PREFIX( ""_delete_buffer"" );
		GEN_PREFIX( ""_flex_debug"" );
		GEN_PREFIX( ""_init_buffer"" );
		GEN_PREFIX( ""_load_buffer_state"" );
		GEN_PREFIX( ""_switch_to_buffer"" );
		GEN_PREFIX( ""in"" );
		GEN_PREFIX( ""leng"" );
		GEN_PREFIX( ""lex"" );
		GEN_PREFIX( ""out"" );
		GEN_PREFIX( ""restart"" );
		GEN_PREFIX( ""text"" );
		GEN_PREFIX( ""wrap"" );
		printf( ""\n"" );
		}
	lastdfa = lastnfa = 0;
	num_rules = num_eof_rules = default_rule = 0;
	numas = numsnpairs = tmpuses = 0;
	numecs = numeps = eps2 = num_reallocs = hshcol = dfaeql = totnst = 0;
	numuniq = numdup = hshsave = eofseen = datapos = dataline = 0;
	num_backing_up = onesp = numprots = 0;
	variable_trailing_context_rules = bol_needed = false;
	linenum = sectnum = 1;
	firstprot = NIL;
	lastprot = 1;
	if ( useecs )
		{
		ecgroup[1] = NIL;
		for ( i = 2; i <= csize; ++i )
			{
			ecgroup[i] = i - 1;
			nextecm[i - 1] = i;
			}
		nextecm[csize] = NIL;
		}
	else
		{
		for ( i = 1; i <= csize; ++i )
			{
			ecgroup[i] = i;
			nextecm[i] = BAD_SUBSCRIPT;	 
			}
		}
	set_up_initial_allocations();
	}",
1579,"	lastccl = 0;
	lastsc = 0;
	if ( skelname && (skelfile = fopen( skelname, ""r"" )) == NULL )
		lerrsf( ""can't open skeleton file %s"", skelname );
	if ( strcmp( prefix, ""yy"" ) )
		{
#define GEN_PREFIX(name) printf( ""#define yy%s %s%s\n"", name, prefix, name );
		GEN_PREFIX( ""FlexLexer"" );
		GEN_PREFIX( ""_create_buffer"" );
		GEN_PREFIX( ""_delete_buffer"" );
		GEN_PREFIX( ""_flex_debug"" );
		GEN_PREFIX( ""_init_buffer"" );
		GEN_PREFIX( ""_load_buffer_state"" );
		GEN_PREFIX( ""_switch_to_buffer"" );
		GEN_PREFIX( ""in"" );
		GEN_PREFIX( ""leng"" );
		GEN_PREFIX( ""lex"" );
		GEN_PREFIX( ""out"" );
		GEN_PREFIX( ""restart"" );
		GEN_PREFIX( ""text"" );
		GEN_PREFIX( ""wrap"" );
		printf( ""\n"" );
		}
	lastdfa = lastnfa = 0;
	num_rules = num_eof_rules = default_rule = 0;
	numas = numsnpairs = tmpuses = 0;
	numecs = numeps = eps2 = num_reallocs = hshcol = dfaeql = totnst = 0;
	numuniq = numdup = hshsave = eofseen = datapos = dataline = 0;
	num_backing_up = onesp = numprots = 0;
	variable_trailing_context_rules = bol_needed = false;
	linenum = sectnum = 1;
	firstprot = NIL;
	lastprot = 1;
	if ( useecs )
		{
		ecgroup[1] = NIL;
		for ( i = 2; i <= csize; ++i )
			{
			ecgroup[i] = i - 1;
			nextecm[i - 1] = i;
			}
		nextecm[csize] = NIL;
		}
	else
		{
		for ( i = 1; i <= csize; ++i )
			{
			ecgroup[i] = i;
			nextecm[i] = BAD_SUBSCRIPT;	 
			}
		}
	set_up_initial_allocations();
	}","<mb:mutant#d54c5ac4f5e7ad0bf79e9099de5b269d82e8c0de> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -1377 +1377 @@
-	input_files = argv;
+	input_files = abs(argv);
@@ -1770 +1769 @@
-			tblsiz = tblsiz + csize;
+			tblsiz = tblsiz + abs(csize);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Flex.c> ."
1580,"	}
	if ( lex_compat )
	{
		if ( C_plus_plus )
			flexerror( ""Can't use -+ with -l option"" );
		if ( fulltbl || fullspd )
			flexerror( ""Can't use -f or -F with -l option"" );
		yymore_really_used = reject_really_used = true;
		yytext_is_array = true;
		use_read = false;
	}
	if ( (fulltbl || fullspd) && usemecs )
		flexerror( ""-Cf/-CF and -Cm don't make sense together"" );
	if ( (fulltbl || fullspd) && interactive )
		flexerror( ""-Cf/-CF and -I are incompatible"" );
	if ( fulltbl && fullspd )
		flexerror( ""-Cf and -CF are mutually exclusive"" );
	if ( C_plus_plus && fullspd )
		flexerror( ""Can't use -+ with -CF option"" );
	if ( ! use_stdout )
	{
		FILE *prev_stdout;
		char *suffix;
		if ( C_plus_plus )
			suffix = ""cc"";
		else
			suffix = ""c"";
		sprintf( outfile_path, outfile_template, prefix, suffix );
		prev_stdout = freopen( outfile_path, ""w"", stdout );
		if ( prev_stdout == NULL )
			lerrsf( ""could not create %s"", outfile_path );
		outfile_created = 1;
	}
	num_input_files = argc;
	input_files = argv;
	set_input_file( num_input_files > 0 ? input_files[0] : NULL );
	if ( backing_up_report )
		{
#ifndef SHORT_FILE_NAMES
		backing_up_file = fopen( ""lex.backup"", ""w"" );
#else
		backing_up_file = fopen( ""lex.bck"", ""w"" );
#endif
		if ( backing_up_file == NULL )
			flexerror( ""could not create lex.backup"" );
		}
	else
		backing_up_file = NULL;
	lastccl = 0;
	lastsc = 0;
	if ( skelname && (skelfile = fopen( skelname, ""r"" )) == NULL )
		lerrsf( ""can't open skeleton file %s"", skelname );
	if ( strcmp( prefix, ""yy"" ) )
		{
#define GEN_PREFIX(name) printf( ""#define yy%s %s%s\n"", name, prefix, name );",
1581,"	}
	if ( lex_compat )
	{
		if ( C_plus_plus )
			flexerror( ""Can't use -+ with -l option"" );
		if ( fulltbl || fullspd )
			flexerror( ""Can't use -f or -F with -l option"" );
		yymore_really_used = reject_really_used = true;
		yytext_is_array = true;
		use_read = false;
	}
	if ( (fulltbl || fullspd) && usemecs )
		flexerror( ""-Cf/-CF and -Cm don't make sense together"" );
	if ( (fulltbl || fullspd) && interactive )
		flexerror( ""-Cf/-CF and -I are incompatible"" );
	if ( fulltbl && fullspd )
		flexerror( ""-Cf and -CF are mutually exclusive"" );
	if ( C_plus_plus && fullspd )
		flexerror( ""Can't use -+ with -CF option"" );
	if ( ! use_stdout )
	{
		FILE *prev_stdout;
		char *suffix;
		if ( C_plus_plus )
			suffix = ""cc"";
		else
			suffix = ""c"";
		sprintf( outfile_path, outfile_template, prefix, suffix );
		prev_stdout = freopen( outfile_path, ""w"", stdout );
		if ( prev_stdout == NULL )
			lerrsf( ""could not create %s"", outfile_path );
		outfile_created = 1;
	}
	num_input_files = argc;
	input_files = argv;
	set_input_file( num_input_files > 0 ? input_files[0] : NULL );
	if ( backing_up_report )
		{
#ifndef SHORT_FILE_NAMES
		backing_up_file = fopen( ""lex.backup"", ""w"" );
#else
		backing_up_file = fopen( ""lex.bck"", ""w"" );
#endif
		if ( backing_up_file == NULL )
			flexerror( ""could not create lex.backup"" );
		}
	else
		backing_up_file = NULL;
	lastccl = 0;
	lastsc = 0;
	if ( skelname && (skelfile = fopen( skelname, ""r"" )) == NULL )
		lerrsf( ""can't open skeleton file %s"", skelname );
	if ( strcmp( prefix, ""yy"" ) )
		{
#define GEN_PREFIX(name) printf( ""#define yy%s %s%s\n"", name, prefix, name );","<mb:mutant#06e48f5f88fbaad479775b1c7cc5b53a61a45f78> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -1247 +1247 @@
-					prefix = arg + i + 1;
+					prefix = arg + abs(i) + 1;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Flex.c> ."
1582,"	lastccl = 0;
	lastsc = 0;
	if ( skelname && (skelfile = fopen( skelname, ""r"" )) == NULL )
		lerrsf( ""can't open skeleton file %s"", skelname );
	if ( strcmp( prefix, ""yy"" ) )
		{
#define GEN_PREFIX(name) printf( ""#define yy%s %s%s\n"", name, prefix, name );
		GEN_PREFIX( ""FlexLexer"" );
		GEN_PREFIX( ""_create_buffer"" );
		GEN_PREFIX( ""_delete_buffer"" );
		GEN_PREFIX( ""_flex_debug"" );
		GEN_PREFIX( ""_init_buffer"" );
		GEN_PREFIX( ""_load_buffer_state"" );
		GEN_PREFIX( ""_switch_to_buffer"" );
		GEN_PREFIX( ""in"" );
		GEN_PREFIX( ""leng"" );
		GEN_PREFIX( ""lex"" );
		GEN_PREFIX( ""out"" );
		GEN_PREFIX( ""restart"" );
		GEN_PREFIX( ""text"" );
		GEN_PREFIX( ""wrap"" );
		printf( ""\n"" );
		}
	lastdfa = lastnfa = 0;
	num_rules = num_eof_rules = default_rule = 0;
	numas = numsnpairs = tmpuses = 0;
	numecs = numeps = eps2 = num_reallocs = hshcol = dfaeql = totnst = 0;
	numuniq = numdup = hshsave = eofseen = datapos = dataline = 0;
	num_backing_up = onesp = numprots = 0;
	variable_trailing_context_rules = bol_needed = false;
	linenum = sectnum = 1;
	firstprot = NIL;
	lastprot = 1;
	if ( useecs )
		{
		ecgroup[1] = NIL;
		for ( i = 2; i <= csize; ++i )
			{
			ecgroup[i] = i - 1;
			nextecm[i - 1] = i;
			}
		nextecm[csize] = NIL;
		}
	else
		{
		for ( i = 1; i <= csize; ++i )
			{
			ecgroup[i] = i;
			nextecm[i] = BAD_SUBSCRIPT;	 
			}
		}
	set_up_initial_allocations();
	}",
1583,"	lastccl = 0;
	lastsc = 0;
	if ( skelname && (skelfile = fopen( skelname, ""r"" )) == NULL )
		lerrsf( ""can't open skeleton file %s"", skelname );
	if ( strcmp( prefix, ""yy"" ) )
		{
#define GEN_PREFIX(name) printf( ""#define yy%s %s%s\n"", name, prefix, name );
		GEN_PREFIX( ""FlexLexer"" );
		GEN_PREFIX( ""_create_buffer"" );
		GEN_PREFIX( ""_delete_buffer"" );
		GEN_PREFIX( ""_flex_debug"" );
		GEN_PREFIX( ""_init_buffer"" );
		GEN_PREFIX( ""_load_buffer_state"" );
		GEN_PREFIX( ""_switch_to_buffer"" );
		GEN_PREFIX( ""in"" );
		GEN_PREFIX( ""leng"" );
		GEN_PREFIX( ""lex"" );
		GEN_PREFIX( ""out"" );
		GEN_PREFIX( ""restart"" );
		GEN_PREFIX( ""text"" );
		GEN_PREFIX( ""wrap"" );
		printf( ""\n"" );
		}
	lastdfa = lastnfa = 0;
	num_rules = num_eof_rules = default_rule = 0;
	numas = numsnpairs = tmpuses = 0;
	numecs = numeps = eps2 = num_reallocs = hshcol = dfaeql = totnst = 0;
	numuniq = numdup = hshsave = eofseen = datapos = dataline = 0;
	num_backing_up = onesp = numprots = 0;
	variable_trailing_context_rules = bol_needed = false;
	linenum = sectnum = 1;
	firstprot = NIL;
	lastprot = 1;
	if ( useecs )
		{
		ecgroup[1] = NIL;
		for ( i = 2; i <= csize; ++i )
			{
			ecgroup[i] = i - 1;
			nextecm[i - 1] = i;
			}
		nextecm[csize] = NIL;
		}
	else
		{
		for ( i = 1; i <= csize; ++i )
			{
			ecgroup[i] = i;
			nextecm[i] = BAD_SUBSCRIPT;	 
			}
		}
	set_up_initial_allocations();
	}","<mb:mutant#953acdb859fbff23291dc3249205e50bc50e51bc> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -1293 +1293 @@
-					csize = CSIZE;
+					csize = abs(CSIZE);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Flex.c> ."
1584,"	lastccl = 0;
	lastsc = 0;
	if ( skelname && (skelfile = fopen( skelname, ""r"" )) == NULL )
		lerrsf( ""can't open skeleton file %s"", skelname );
	if ( strcmp( prefix, ""yy"" ) )
		{
#define GEN_PREFIX(name) printf( ""#define yy%s %s%s\n"", name, prefix, name );
		GEN_PREFIX( ""FlexLexer"" );
		GEN_PREFIX( ""_create_buffer"" );
		GEN_PREFIX( ""_delete_buffer"" );
		GEN_PREFIX( ""_flex_debug"" );
		GEN_PREFIX( ""_init_buffer"" );
		GEN_PREFIX( ""_load_buffer_state"" );
		GEN_PREFIX( ""_switch_to_buffer"" );
		GEN_PREFIX( ""in"" );
		GEN_PREFIX( ""leng"" );
		GEN_PREFIX( ""lex"" );
		GEN_PREFIX( ""out"" );
		GEN_PREFIX( ""restart"" );
		GEN_PREFIX( ""text"" );
		GEN_PREFIX( ""wrap"" );
		printf( ""\n"" );
		}
	lastdfa = lastnfa = 0;
	num_rules = num_eof_rules = default_rule = 0;
	numas = numsnpairs = tmpuses = 0;
	numecs = numeps = eps2 = num_reallocs = hshcol = dfaeql = totnst = 0;
	numuniq = numdup = hshsave = eofseen = datapos = dataline = 0;
	num_backing_up = onesp = numprots = 0;
	variable_trailing_context_rules = bol_needed = false;
	linenum = sectnum = 1;
	firstprot = NIL;
	lastprot = 1;
	if ( useecs )
		{
		ecgroup[1] = NIL;
		for ( i = 2; i <= csize; ++i )
			{
			ecgroup[i] = i - 1;
			nextecm[i - 1] = i;
			}
		nextecm[csize] = NIL;
		}
	else
		{
		for ( i = 1; i <= csize; ++i )
			{
			ecgroup[i] = i;
			nextecm[i] = BAD_SUBSCRIPT;	 
			}
		}
	set_up_initial_allocations();
	}",
1585,"	lastccl = 0;
	lastsc = 0;
	if ( skelname && (skelfile = fopen( skelname, ""r"" )) == NULL )
		lerrsf( ""can't open skeleton file %s"", skelname );
	if ( strcmp( prefix, ""yy"" ) )
		{
#define GEN_PREFIX(name) printf( ""#define yy%s %s%s\n"", name, prefix, name );
		GEN_PREFIX( ""FlexLexer"" );
		GEN_PREFIX( ""_create_buffer"" );
		GEN_PREFIX( ""_delete_buffer"" );
		GEN_PREFIX( ""_flex_debug"" );
		GEN_PREFIX( ""_init_buffer"" );
		GEN_PREFIX( ""_load_buffer_state"" );
		GEN_PREFIX( ""_switch_to_buffer"" );
		GEN_PREFIX( ""in"" );
		GEN_PREFIX( ""leng"" );
		GEN_PREFIX( ""lex"" );
		GEN_PREFIX( ""out"" );
		GEN_PREFIX( ""restart"" );
		GEN_PREFIX( ""text"" );
		GEN_PREFIX( ""wrap"" );
		printf( ""\n"" );
		}
	lastdfa = lastnfa = 0;
	num_rules = num_eof_rules = default_rule = 0;
	numas = numsnpairs = tmpuses = 0;
	numecs = numeps = eps2 = num_reallocs = hshcol = dfaeql = totnst = 0;
	numuniq = numdup = hshsave = eofseen = datapos = dataline = 0;
	num_backing_up = onesp = numprots = 0;
	variable_trailing_context_rules = bol_needed = false;
	linenum = sectnum = 1;
	firstprot = NIL;
	lastprot = 1;
	if ( useecs )
		{
		ecgroup[1] = NIL;
		for ( i = 2; i <= csize; ++i )
			{
			ecgroup[i] = i - 1;
			nextecm[i - 1] = i;
			}
		nextecm[csize] = NIL;
		}
	else
		{
		for ( i = 1; i <= csize; ++i )
			{
			ecgroup[i] = i;
			nextecm[i] = BAD_SUBSCRIPT;	 
			}
		}
	set_up_initial_allocations();
	}","<mb:mutant#d54c5ac4f5e7ad0bf79e9099de5b269d82e8c0de> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -1377 +1377 @@
-	input_files = argv;
+	input_files = abs(argv);
@@ -1770 +1769 @@
-			tblsiz = tblsiz + csize;
+			tblsiz = tblsiz + abs(csize);
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Flex.c> ."
1586,"	}
	if ( lex_compat )
	{
		if ( C_plus_plus )
			flexerror( ""Can't use -+ with -l option"" );
		if ( fulltbl || fullspd )
			flexerror( ""Can't use -f or -F with -l option"" );
		yymore_really_used = reject_really_used = true;
		yytext_is_array = true;
		use_read = false;
	}
	if ( (fulltbl || fullspd) && usemecs )
		flexerror( ""-Cf/-CF and -Cm don't make sense together"" );
	if ( (fulltbl || fullspd) && interactive )
		flexerror( ""-Cf/-CF and -I are incompatible"" );
	if ( fulltbl && fullspd )
		flexerror( ""-Cf and -CF are mutually exclusive"" );
	if ( C_plus_plus && fullspd )
		flexerror( ""Can't use -+ with -CF option"" );
	if ( ! use_stdout )
	{
		FILE *prev_stdout;
		char *suffix;
		if ( C_plus_plus )
			suffix = ""cc"";
		else
			suffix = ""c"";
		sprintf( outfile_path, outfile_template, prefix, suffix );
		prev_stdout = freopen( outfile_path, ""w"", stdout );
		if ( prev_stdout == NULL )
			lerrsf( ""could not create %s"", outfile_path );
		outfile_created = 1;
	}
	num_input_files = argc;
	input_files = argv;
	set_input_file( num_input_files > 0 ? input_files[0] : NULL );
	if ( backing_up_report )
		{
#ifndef SHORT_FILE_NAMES
		backing_up_file = fopen( ""lex.backup"", ""w"" );
#else
		backing_up_file = fopen( ""lex.bck"", ""w"" );
#endif
		if ( backing_up_file == NULL )
			flexerror( ""could not create lex.backup"" );
		}
	else
		backing_up_file = NULL;
	lastccl = 0;
	lastsc = 0;
	if ( skelname && (skelfile = fopen( skelname, ""r"" )) == NULL )
		lerrsf( ""can't open skeleton file %s"", skelname );
	if ( strcmp( prefix, ""yy"" ) )
		{
#define GEN_PREFIX(name) printf( ""#define yy%s %s%s\n"", name, prefix, name );",
1587,"	}
	if ( lex_compat )
	{
		if ( C_plus_plus )
			flexerror( ""Can't use -+ with -l option"" );
		if ( fulltbl || fullspd )
			flexerror( ""Can't use -f or -F with -l option"" );
		yymore_really_used = reject_really_used = true;
		yytext_is_array = true;
		use_read = false;
	}
	if ( (fulltbl || fullspd) && usemecs )
		flexerror( ""-Cf/-CF and -Cm don't make sense together"" );
	if ( (fulltbl || fullspd) && interactive )
		flexerror( ""-Cf/-CF and -I are incompatible"" );
	if ( fulltbl && fullspd )
		flexerror( ""-Cf and -CF are mutually exclusive"" );
	if ( C_plus_plus && fullspd )
		flexerror( ""Can't use -+ with -CF option"" );
	if ( ! use_stdout )
	{
		FILE *prev_stdout;
		char *suffix;
		if ( C_plus_plus )
			suffix = ""cc"";
		else
			suffix = ""c"";
		sprintf( outfile_path, outfile_template, prefix, suffix );
		prev_stdout = freopen( outfile_path, ""w"", stdout );
		if ( prev_stdout == NULL )
			lerrsf( ""could not create %s"", outfile_path );
		outfile_created = 1;
	}
	num_input_files = argc;
	input_files = argv;
	set_input_file( num_input_files > 0 ? input_files[0] : NULL );
	if ( backing_up_report )
		{
#ifndef SHORT_FILE_NAMES
		backing_up_file = fopen( ""lex.backup"", ""w"" );
#else
		backing_up_file = fopen( ""lex.bck"", ""w"" );
#endif
		if ( backing_up_file == NULL )
			flexerror( ""could not create lex.backup"" );
		}
	else
		backing_up_file = NULL;
	lastccl = 0;
	lastsc = 0;
	if ( skelname && (skelfile = fopen( skelname, ""r"" )) == NULL )
		lerrsf( ""can't open skeleton file %s"", skelname );
	if ( strcmp( prefix, ""yy"" ) )
		{
#define GEN_PREFIX(name) printf( ""#define yy%s %s%s\n"", name, prefix, name );","<mb:mutant#28f4e603821bff003997ce318a76c945378acaea> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -1247 +1247 @@
-					prefix = arg + i + 1;
+					prefix = abs(arg) + i + 1;
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ABSI> ;
    mb:program <mb:program#Flex.c> ."
1588,"		get_next_arg: ;
		}
	if ( ! csize_given )
	{
		if ( (fulltbl || fullspd) && ! useecs )
			csize = DEFAULT_CSIZE;
		else
			csize = CSIZE;
	}
	if ( ! interactive_given )
	{
		if ( fulltbl || fullspd )
			interactive = false;
		else
			interactive = true;
	}
	if ( lex_compat )
	{
		if ( C_plus_plus )
			flexerror( ""Can't use -+ with -l option"" );
		if ( fulltbl || fullspd )
			flexerror( ""Can't use -f or -F with -l option"" );
		yymore_really_used = reject_really_used = true;
		yytext_is_array = true;
		use_read = false;
	}
	if ( (fulltbl || fullspd) && usemecs )
		flexerror( ""-Cf/-CF and -Cm don't make sense together"" );
	if ( (fulltbl || fullspd) && interactive )
		flexerror( ""-Cf/-CF and -I are incompatible"" );
	if ( fulltbl && fullspd )
		flexerror( ""-Cf and -CF are mutually exclusive"" );
	if ( C_plus_plus && fullspd )
		flexerror( ""Can't use -+ with -CF option"" );
	if ( ! use_stdout )
	{
		FILE *prev_stdout;
		char *suffix;
		if ( C_plus_plus )
			suffix = ""cc"";
		else
			suffix = ""c"";
		sprintf( outfile_path, outfile_template, prefix, suffix );
		prev_stdout = freopen( outfile_path, ""w"", stdout );
		if ( prev_stdout == NULL )
			lerrsf( ""could not create %s"", outfile_path );
		outfile_created = 1;
	}
	num_input_files = argc;
	input_files = argv;
	set_input_file( num_input_files > 0 ? input_files[0] : NULL );
	if ( backing_up_report )
		{
#ifndef SHORT_FILE_NAMES
		backing_up_file = fopen( ""lex.backup"", ""w"" );
#else
		backing_up_file = fopen( ""lex.bck"", ""w"" );
#endif
		if ( backing_up_file == NULL )
			flexerror( ""could not create lex.backup"" );
		}
	else
		backing_up_file = NULL;
	lastccl = 0;",
1589,"		get_next_arg: ;
		}
	if ( ! csize_given )
	{
		if ( (fulltbl || fullspd) && ! useecs )
			csize = DEFAULT_CSIZE;
		else
			csize = CSIZE;
	}
	if ( ! interactive_given )
	{
		if ( fulltbl || fullspd )
			interactive = false;
		else
			interactive = true;
	}
	if ( lex_compat )
	{
		if ( C_plus_plus )
			flexerror( ""Can't use -+ with -l option"" );
		if ( fulltbl || fullspd )
			flexerror( ""Can't use -f or -F with -l option"" );
		yymore_really_used = reject_really_used = true;
		yytext_is_array = true;
		use_read = false;
	}
	if ( (fulltbl || fullspd) && usemecs )
		flexerror( ""-Cf/-CF and -Cm don't make sense together"" );
	if ( (fulltbl || fullspd) && interactive )
		flexerror( ""-Cf/-CF and -I are incompatible"" );
	if ( fulltbl && fullspd )
		flexerror( ""-Cf and -CF are mutually exclusive"" );
	if ( C_plus_plus && fullspd )
		flexerror( ""Can't use -+ with -CF option"" );
	if ( ! use_stdout )
	{
		FILE *prev_stdout;
		char *suffix;
		if ( C_plus_plus )
			suffix = ""cc"";
		else
			suffix = ""c"";
		sprintf( outfile_path, outfile_template, prefix, suffix );
		prev_stdout = freopen( outfile_path, ""w"", stdout );
		if ( prev_stdout == NULL )
			lerrsf( ""could not create %s"", outfile_path );
		outfile_created = 1;
	}
	num_input_files = argc;
	input_files = argv;
	set_input_file( num_input_files > 0 ? input_files[0] : NULL );
	if ( backing_up_report )
		{
#ifndef SHORT_FILE_NAMES
		backing_up_file = fopen( ""lex.backup"", ""w"" );
#else
		backing_up_file = fopen( ""lex.bck"", ""w"" );
#endif
		if ( backing_up_file == NULL )
			flexerror( ""could not create lex.backup"" );
		}
	else
		backing_up_file = NULL;
	lastccl = 0;","<mb:mutant#9955b8bd22a76f05f7a2560a15a2c6454f49d0bb> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -1243 +1243 @@
-					if ( i != 1 )
+					if ( i > 1 )
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Flex.c> ."
1590,"	lastccl = 0;
	lastsc = 0;
	if ( skelname && (skelfile = fopen( skelname, ""r"" )) == NULL )
		lerrsf( ""can't open skeleton file %s"", skelname );
	if ( strcmp( prefix, ""yy"" ) )
		{
#define GEN_PREFIX(name) printf( ""#define yy%s %s%s\n"", name, prefix, name );
		GEN_PREFIX( ""FlexLexer"" );
		GEN_PREFIX( ""_create_buffer"" );
		GEN_PREFIX( ""_delete_buffer"" );
		GEN_PREFIX( ""_flex_debug"" );
		GEN_PREFIX( ""_init_buffer"" );
		GEN_PREFIX( ""_load_buffer_state"" );
		GEN_PREFIX( ""_switch_to_buffer"" );
		GEN_PREFIX( ""in"" );
		GEN_PREFIX( ""leng"" );
		GEN_PREFIX( ""lex"" );
		GEN_PREFIX( ""out"" );
		GEN_PREFIX( ""restart"" );
		GEN_PREFIX( ""text"" );
		GEN_PREFIX( ""wrap"" );
		printf( ""\n"" );
		}
	lastdfa = lastnfa = 0;
	num_rules = num_eof_rules = default_rule = 0;
	numas = numsnpairs = tmpuses = 0;
	numecs = numeps = eps2 = num_reallocs = hshcol = dfaeql = totnst = 0;
	numuniq = numdup = hshsave = eofseen = datapos = dataline = 0;
	num_backing_up = onesp = numprots = 0;
	variable_trailing_context_rules = bol_needed = false;
	linenum = sectnum = 1;
	firstprot = NIL;
	lastprot = 1;
	if ( useecs )
		{
		ecgroup[1] = NIL;
		for ( i = 2; i <= csize; ++i )
			{
			ecgroup[i] = i - 1;
			nextecm[i - 1] = i;
			}
		nextecm[csize] = NIL;
		}
	else
		{
		for ( i = 1; i <= csize; ++i )
			{
			ecgroup[i] = i;
			nextecm[i] = BAD_SUBSCRIPT;	 
			}
		}
	set_up_initial_allocations();
	}",
1591,"	lastccl = 0;
	lastsc = 0;
	if ( skelname && (skelfile = fopen( skelname, ""r"" )) == NULL )
		lerrsf( ""can't open skeleton file %s"", skelname );
	if ( strcmp( prefix, ""yy"" ) )
		{
#define GEN_PREFIX(name) printf( ""#define yy%s %s%s\n"", name, prefix, name );
		GEN_PREFIX( ""FlexLexer"" );
		GEN_PREFIX( ""_create_buffer"" );
		GEN_PREFIX( ""_delete_buffer"" );
		GEN_PREFIX( ""_flex_debug"" );
		GEN_PREFIX( ""_init_buffer"" );
		GEN_PREFIX( ""_load_buffer_state"" );
		GEN_PREFIX( ""_switch_to_buffer"" );
		GEN_PREFIX( ""in"" );
		GEN_PREFIX( ""leng"" );
		GEN_PREFIX( ""lex"" );
		GEN_PREFIX( ""out"" );
		GEN_PREFIX( ""restart"" );
		GEN_PREFIX( ""text"" );
		GEN_PREFIX( ""wrap"" );
		printf( ""\n"" );
		}
	lastdfa = lastnfa = 0;
	num_rules = num_eof_rules = default_rule = 0;
	numas = numsnpairs = tmpuses = 0;
	numecs = numeps = eps2 = num_reallocs = hshcol = dfaeql = totnst = 0;
	numuniq = numdup = hshsave = eofseen = datapos = dataline = 0;
	num_backing_up = onesp = numprots = 0;
	variable_trailing_context_rules = bol_needed = false;
	linenum = sectnum = 1;
	firstprot = NIL;
	lastprot = 1;
	if ( useecs )
		{
		ecgroup[1] = NIL;
		for ( i = 2; i <= csize; ++i )
			{
			ecgroup[i] = i - 1;
			nextecm[i - 1] = i;
			}
		nextecm[csize] = NIL;
		}
	else
		{
		for ( i = 1; i <= csize; ++i )
			{
			ecgroup[i] = i;
			nextecm[i] = BAD_SUBSCRIPT;	 
			}
		}
	set_up_initial_allocations();
	}","<mb:mutant#687349d4a1b1ba316065d37ab6c8c2409d4ccc4c> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -1370 +1370 @@
-		if ( prev_stdout == NULL )
+		if ( prev_stdout <= NULL )
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Flex.c> ."
1592,"			putc( 'i', err );
		if ( lex_compat )
			putc( 'l', err );
		if ( performance_report > 0 )
			putc( 'p', err );
		if ( performance_report > 1 )
			putc( 'p', err );
		if ( spprdflt )
			putc( 's', err );
		if ( use_stdout )
			putc( 't', err );
		if ( printstats )
			putc( 'v', err );	 
		if ( nowarn )
			putc( 'w', err );
		if ( ! interactive )
			putc( 'B', err );
		if ( interactive )
			putc( 'I', err );
		if ( ! gen_line_dirs )
			putc( 'L', err );
		if ( trace )
			putc( 'T', err );
		if ( csize == 128 )
			putc( '7', err );
		else
			putc( '8', err );
		fprintf( err, "" -C"" );
		if ( long_align )
			putc( 'a', err );
		if ( fulltbl )
			putc( 'f', err );
		if ( fullspd )
			putc( 'F', err );
		if ( useecs )
			putc( 'e', err );
		if ( usemecs )
			putc( 'm', err );
		if ( use_read )
			putc( 'r', err );
		if ( skelname )
			fprintf( err, "" -S%s"", skelname );
		if ( strcmp( prefix, ""yy"" ) )
			fprintf( err, "" -P%s"", prefix );
		putc( '\n', err );
		fprintf( err, ""  %d/%d NFA states\n"", lastnfa, current_mns );
		fprintf( err, ""  %d/%d DFA states (%d words)\n"", lastdfa,
			current_max_dfas, totnst );
		fprintf( err, ""  %d rules\n"",
		num_rules + num_eof_rules - 1   );
		if ( num_backing_up == 0 )
			fprintf( err, ""  No backing up\n"" );
		else if ( fullspd || fulltbl )
			fprintf( err,
				""  %d backing-up (non-accepting) states\n"",
				num_backing_up );",
1593,"			putc( 'i', err );
		if ( lex_compat )
			putc( 'l', err );
		if ( performance_report != 0 )
			putc( 'p', err );
		if ( performance_report > 1 )
			putc( 'p', err );
		if ( spprdflt )
			putc( 's', err );
		if ( use_stdout )
			putc( 't', err );
		if ( printstats )
			putc( 'v', err );	 
		if ( nowarn )
			putc( 'w', err );
		if ( ! interactive )
			putc( 'B', err );
		if ( interactive )
			putc( 'I', err );
		if ( ! gen_line_dirs )
			putc( 'L', err );
		if ( trace )
			putc( 'T', err );
		if ( csize == 128 )
			putc( '7', err );
		else
			putc( '8', err );
		fprintf( err, "" -C"" );
		if ( long_align )
			putc( 'a', err );
		if ( fulltbl )
			putc( 'f', err );
		if ( fullspd )
			putc( 'F', err );
		if ( useecs )
			putc( 'e', err );
		if ( usemecs )
			putc( 'm', err );
		if ( use_read )
			putc( 'r', err );
		if ( skelname )
			fprintf( err, "" -S%s"", skelname );
		if ( strcmp( prefix, ""yy"" ) )
			fprintf( err, "" -P%s"", prefix );
		putc( '\n', err );
		fprintf( err, ""  %d/%d NFA states\n"", lastnfa, current_mns );
		fprintf( err, ""  %d/%d DFA states (%d words)\n"", lastdfa,
			current_max_dfas, totnst );
		fprintf( err, ""  %d rules\n"",
		num_rules + num_eof_rules - 1   );
		if ( num_backing_up == 0 )
			fprintf( err, ""  No backing up\n"" );
		else if ( fullspd || fulltbl )
			fprintf( err,
				""  %d backing-up (non-accepting) states\n"",
				num_backing_up );","<mb:mutant#7e4bc95c574cb710b1f46568832d6aaa18ff25f1> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -1655 +1655 @@
-		if ( performance_report > 0 )
+		if ( performance_report != 0 )
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Flex.c> ."
1594,"void flexinit( argc, argv )
int argc;
char **argv;
	{
	int i, sawcmpflag;
	int csize_given, interactive_given;
	char *arg, *mktemp();
	printstats = syntaxerror = trace = spprdflt = caseins = false;
	lex_compat = false;
	C_plus_plus = backing_up_report = ddebug = fulltbl = fullspd = false;
	long_align = nowarn = yymore_used = continued_action = reject = false;
	yytext_is_array = yymore_really_used = reject_really_used = false;
	gen_line_dirs = usemecs = useecs = true;
	performance_report = 0;
	sawcmpflag = false;
	use_read = use_stdout = false;
	csize_given = false;
	interactive_given = false;
	action_size = 2048;	 
	action_array = allocate_character_array( action_size );
	defs1_offset = prolog_offset = action_offset = action_index = 0;
	action_array[0] = '\0';
        program_name = ""Executable"";
	if ( program_name[0] != '\0' && program_name[strlen( program_name ) - 1] == '+' )
		C_plus_plus = true;
        ++argv;--argc;
	for ( --argc, ++argv; argc ; --argc, ++argv )
	{
		if ( argv[0][0] != '-' || argv[0][1] == '\0' )
			break;
		arg = argv[0];
		for ( i = 1; arg[i] != '\0'; ++i )
			switch ( arg[i] )
				{
				case '+':
					C_plus_plus = true;
					break;
				case 'B':
					interactive = false;
					interactive_given = true;
					break;
				case 'b':
					backing_up_report = true;
					break;
				case 'c':
					fprintf( err,""%s: Assuming use of deprecated -c flag is really intended to be -C\n"",
					program_name );
				case 'C':
					if ( i != 1 )
						flexerror(""-C flag must be given separately"" );
					if ( ! sawcmpflag )
						{
						useecs = false;
						usemecs = false;
						fulltbl = false;
						sawcmpflag = true;
						}
					for ( ++i; arg[i] != '\0'; ++i )
						switch ( arg[i] )",
1595,"void flexinit( argc, argv )
int argc;
char **argv;
	{
	int i, sawcmpflag;
	int csize_given, interactive_given;
	char *arg, *mktemp();
	printstats = syntaxerror = trace = spprdflt = caseins = false;
	lex_compat = false;
	C_plus_plus = backing_up_report = ddebug = fulltbl = fullspd = false;
	long_align = nowarn = yymore_used = continued_action = reject = false;
	yytext_is_array = yymore_really_used = reject_really_used = false;
	gen_line_dirs = usemecs = useecs = true;
	performance_report = 0;
	sawcmpflag = false;
	use_read = use_stdout = false;
	csize_given = false;
	interactive_given = false;
	action_size = 2048;	 
	action_array = allocate_character_array( action_size );
	defs1_offset = prolog_offset = action_offset = action_index = 0;
	action_array[0] = '\0';
        program_name = ""Executable"";
	if ( program_name[0] != '\0' && program_name[strlen( program_name ) - 1] == '+' )
		C_plus_plus = true;
        ++argv;--argc;
	for ( --argc, ++argv; argc ; --argc, ++argv )
	{
		if ( argv[0][0] != '-' || argv[0][1] <= '\0' )
			break;
		arg = argv[0];
		for ( i = 1; arg[i] != '\0'; ++i )
			switch ( arg[i] )
				{
				case '+':
					C_plus_plus = true;
					break;
				case 'B':
					interactive = false;
					interactive_given = true;
					break;
				case 'b':
					backing_up_report = true;
					break;
				case 'c':
					fprintf( err,""%s: Assuming use of deprecated -c flag is really intended to be -C\n"",
					program_name );
				case 'C':
					if ( i != 1 )
						flexerror(""-C flag must be given separately"" );
					if ( ! sawcmpflag )
						{
						useecs = false;
						usemecs = false;
						fulltbl = false;
						sawcmpflag = true;
						}
					for ( ++i; arg[i] != '\0'; ++i )
						switch ( arg[i] )","<mb:mutant#4a7de89376e25bb4302a47b4cbda9ff80ff917ba> a mb:Mutant ;
    schema:citation <mb:paper#yao2015study> ;
    mb:difference """"""@@ -1127 +1127 @@
-		if ( argv[0][0] != '-' || argv[0][1] == '\\0' )
+		if ( argv[0][0] != '-' || argv[0][1] <= '\\0' )
"""""" ;
    mb:equivalence ""true""^^schema:boolean ;
    mb:operator <mb:operator#ROR> ;
    mb:program <mb:program#Flex.c> ."
